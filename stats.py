from roputils import *

import time
import pickle
import matplotlib.pyplot as plt

BINPATH_X86 = "./stats_binaries/x86_64/"
BINPATH_ARM = "./stats_binaries/arm64/"
STATSPATH_X86 = "../rop_payload_gen_doc/stats_plots/x86/"
STATSPATH_ARM = "../rop_payload_gen_doc/stats_plots/arm/"
STATSPATH = "../rop_payload_gen_doc/stats_plots/"

X86_BINS = ["ld-2.31.so",
            "libc-2.31.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.6.0",
            "libm-2.31.so",
            "libpthread-2.31.so"]

ARM_BINS = ["ld-2.33.so",
            "libc-2.33.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.7.0",
            "libm-2.33.so",
            "libpthread-2.33.so"]

def gadget_distribution_stats():

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _x86():
        
        distrib_x86 = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in Platform.X86_64.SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_x86 = ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64)   
        r_x86.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in Platform.X86_64.SUPPORTED_REGS:
                distrib_x86["libc"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in X86_BINS:
            if binname != X86_BINS[1]:

                r_x86 = ROP_util(BINPATH_X86 + binname, Platform.X86_64)   
                r_x86.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in Platform.X86_64.SUPPORTED_REGS:
                        distrib_x86["other binaries (summed)"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_x86)
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _arm():

        ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
        ARM_SUPPORTED_REGS.remove("x30")
        
        distrib_arm = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in ARM_SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_arm = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)   
        r_arm.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in ARM_SUPPORTED_REGS:
                distrib_arm["libc"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in ARM_BINS:
            if binname != ARM_BINS[1]:

                r_arm = ROP_util(BINPATH_ARM + binname, Platform.ARM64)   
                r_arm.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in ARM_SUPPORTED_REGS:
                        distrib_arm["other binaries (summed)"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_arm)
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _plot_x86():
        
        g_distrib_stats = None
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )

                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    def _plot_arm():
        
        g_distrib_stats = None
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )
                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    #_x86()
    #_arm()

    #_plot_x86()
    #_plot_arm()

    return None

def average_elements_stats():

    constant_el_cnt_types = {"ct_val", "64b_stack_val", "reg_in", "reg_out"}
    ops = {"add", "sub", "and", "or", "xor", "neg", "mul", "lsh", "rsh"}

    def _el_cnt(e: Structured_element):

        if e is None:
            return 0

        if e.type in constant_el_cnt_types:
            return 1

        if e.type == "deref":
            return _el_cnt(e.info["expr"])

        if e.type in ops:
            return _el_cnt(e.info["term_1"]) + _el_cnt(e.info["term_2"])

    assert(len(X86_BINS) == len(ARM_BINS))
    for bin_idx in range(2, len(X86_BINS)):

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[bin_idx], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[bin_idx], Platform.ARM64)}

        r["x86"].scout_for_gadgets()
        r["arm"].scout_for_gadgets()

        res = \
            {
                _arch:
                {   
                    l:
                    {
                        "peref": 0,
                        "perefraw": 0,
                        "perg": 0,
                        "pergraw": 0,
                        "efcnt": 0,
                        "efcntraw": 0,
                        "gcnt": 0,
                        "gcntraw": 0
                    }
                    for l in {"1g", "2g"}
                }
                for _arch in {"x86", "arm"}
            }

        # arm raw valid gadgets

        for g in r["arm"].rop_searcher.raw_gadgets:
            if g.valid_jump is True and g.valid_stack_access is True:
                
                res["arm"]["1g"]["gcntraw"] += 1

                for ef in g.effects:
                    ecnt = _el_cnt(ef.params[0])

                    res["arm"]["1g"]["pergraw"] += ecnt

                    if ef.type == "ARITH":

                        res["arm"]["1g"]["efcntraw"] += 1
                        res["arm"]["1g"]["perefraw"] += ecnt

        # 1 gadget chains 
        for _arch in ["x86", "arm"]:
            for g in r[_arch].rop_searcher.gadgets:
                
                res[_arch]["1g"]["gcnt"] += 1

                for ef in g.effects:
                    ecnt = _el_cnt(ef.params[0])

                    res[_arch]["1g"]["perg"] += ecnt

                    if ef.type == "ARITH":

                        res[_arch]["1g"]["efcnt"] += 1
                        res[_arch]["1g"]["peref"] += ecnt

        # 2 gadget chains
        for _arch in ["x86", "arm"]:
            for g1 in r[_arch].rop_searcher.gadgets:
                for g2 in r[_arch].rop_searcher.gadgets:

                    ch = g1.join(g2)
                    if ch is None:
                        continue

                    res[_arch]["2g"]["gcnt"] += 1

                    for ef in ch.effects:
                        ecnt = _el_cnt(ef.params[0])

                        res[_arch]["2g"]["perg"] += ecnt

                        if ef.type == "ARITH":

                            res[_arch]["2g"]["efcnt"] += 1
                            res[_arch]["2g"]["peref"] += ecnt

                    ch.remove_stack_ids()

        with open(STATSPATH + f"avg_elem_{bin_idx}.bin", "wb+") as f:
            f.write(pickle.dumps(res))

        for _arch in ["x86", "arm"]:
            for l in ["1g", "2g"]:

                if res[_arch][l]["efcnt"] != 0:

                    res[_arch][l]["peref"] /= res[_arch][l]["efcnt"]
                    res[_arch][l]["perg"] /= res[_arch][l]["gcnt"]
                
                if res[_arch][l]["efcntraw"] != 0:

                    res[_arch][l]["perefraw"] /= res[_arch][l]["efcntraw"]
                    res[_arch][l]["pergraw"] /= res[_arch][l]["gcntraw"]

        print(res)

        print(f'{bin_idx}: {res["x86"]["1g"]["peref"]} {res["arm"]["1g"]["perefraw"]} {res["arm"]["1g"]["peref"]} {res["x86"]["2g"]["peref"]} {res["arm"]["2g"]["peref"]}')
        print(f'{bin_idx}: {res["x86"]["1g"]["perg"]} {res["arm"]["1g"]["pergraw"]} {res["arm"]["1g"]["perg"]} {res["x86"]["2g"]["perg"]} {res["arm"]["2g"]["perg"]}')

def gadget_validation_stats():

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _execute():

        res = \
            {   
                _bin:
                {   
                    _type:
                    {   
                        _ef:
                        {
                            _r: 0
                            for _r in ARM_SUPPORTED_REGS
                        }
                        for _ef in EFFECT_TYPES
                    }
                    for _type in ["raw", "validated"]
                }
                for _bin in ["libc", "other"]
            }     
        for _bin in ["libc", "other"]:
            for _type in ["raw", "validated"]:
                res[_bin][_type].update({"total": 0})

        for _bin in ARM_BINS:

            if _bin == ARM_BINS[1]:
                _bink = "libc"
            else:
                _bink = "other"

            r = ROP_util(BINPATH_ARM + _bin, Platform.ARM64)
            r.scout_for_gadgets()

            res[_bink]["raw"]["total"] += len(r.rop_searcher.raw_gadgets)
            res[_bink]["validated"]["total"] += len(r.rop_searcher.gadgets)
                
            for _eftype in EFFECT_TYPES:
                for _rout in ARM_SUPPORTED_REGS:

                    res[_bink]["raw"][_eftype][_rout] += len(r.rop_searcher.raw_effects_to_gadgets[_eftype][_rout])
                    res[_bink]["validated"][_eftype][_rout] += len(r.rop_searcher.effects_to_gadgets[_eftype][_rout])

        with open(STATSPATH_ARM + "validator_efficiency.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():
    
        res = None
        with open(STATSPATH_ARM + "validator_efficiency.bin", "rb") as f_:
            res = f_.read()

        res = pickle.loads(res)

        print(res)

        for _bins in ["libc", "other"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)

                bars_raw = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["raw"][_eftype].keys()],
                                                [fr for fr in res[_bins]["raw"][_eftype].values()]
                                            )
                bars_val = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["validated"][_eftype].keys()],
                                                [fr for fr in res[_bins]["validated"][_eftype].values()]
                                            )

                #regs_to_fr[idx].bar_label(bars_raw)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    _execute()
    _plot()

if __name__ == "__main__":

    #gadget_distribution_stats()
    #average_elements_stats()
    gadget_validation_stats()

