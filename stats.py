from roputils import *

import time
import pickle
import matplotlib.pyplot as plt
import numpy as np

BINPATH_X86 = "./stats_binaries/x86_64/"
BINPATH_ARM = "./stats_binaries/arm64/"
STATSPATH_X86 = "../rop_payload_gen_doc/stats_plots/x86/"
STATSPATH_ARM = "../rop_payload_gen_doc/stats_plots/arm/"
STATSPATH = "../rop_payload_gen_doc/stats_plots/"

X86_BINS = ["ld-2.31.so",
            "libc-2.31.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.6.0",
            "libm-2.31.so",
            "libpthread-2.31.so"]

ARM_BINS = ["ld-2.33.so",
            "libc-2.33.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.7.0",
            "libm-2.33.so",
            "libpthread-2.33.so"]

def gadget_distribution_stats():

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _x86():
        
        distrib_x86 = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in Platform.X86_64.SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_x86 = ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64)   
        r_x86.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in Platform.X86_64.SUPPORTED_REGS:
                distrib_x86["libc"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in X86_BINS:
            if binname != X86_BINS[1]:

                r_x86 = ROP_util(BINPATH_X86 + binname, Platform.X86_64)   
                r_x86.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in Platform.X86_64.SUPPORTED_REGS:
                        distrib_x86["other binaries (summed)"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_x86)
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _arm():

        ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
        ARM_SUPPORTED_REGS.remove("x30")
        
        distrib_arm = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in ARM_SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_arm = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)   
        r_arm.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in ARM_SUPPORTED_REGS:
                distrib_arm["libc"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in ARM_BINS:
            if binname != ARM_BINS[1]:

                r_arm = ROP_util(BINPATH_ARM + binname, Platform.ARM64)   
                r_arm.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in ARM_SUPPORTED_REGS:
                        distrib_arm["other binaries (summed)"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_arm)
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _plot_x86():
        
        g_distrib_stats = None
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )

                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    def _plot_arm():
        
        g_distrib_stats = None
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )
                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    #_x86()
    #_arm()

    #_plot_x86()
    #_plot_arm()

    return None

def average_elements_stats():

    constant_el_cnt_types = {"ct_val", "64b_stack_val", "reg_in", "reg_out"}
    ops = {"add", "sub", "and", "or", "xor", "neg", "mul", "lsh", "rsh"}

    def _el_cnt(e: Structured_element):

        if e is None:
            return 0

        if e.type in constant_el_cnt_types:
            return 1

        if e.type == "deref":
            return _el_cnt(e.info["expr"])

        if e.type in ops:
            return _el_cnt(e.info["term_1"]) + _el_cnt(e.info["term_2"])

    assert(len(X86_BINS) == len(ARM_BINS))
    for bin_idx in range(len(X86_BINS)):

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[bin_idx], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[bin_idx], Platform.ARM64)}

        r["x86"].scout_for_gadgets()
        r["arm"].scout_for_gadgets()

        res = \
            {
                _arch:
                {   
                    l:
                    {
                        "peref": 0,
                        "perefraw": 0,
                        "perg": 0,
                        "pergraw": 0,
                        "efcnt": 0,
                        "efcntraw": 0,
                        "gcnt": 0,
                        "gcntraw": 0
                    }
                    for l in {"1g", "2g"}
                }
                for _arch in {"x86", "arm"}
            }

        # arm raw valid gadgets

        for _arch in ["x86", "arm"]:
            for g in r[_arch].rop_searcher.raw_gadgets:
                if g.valid_jump is True and g.valid_stack_access is True:
                    
                    res[_arch]["1g"]["gcntraw"] += 1

                    for ef in g.effects:
                        ecnt = _el_cnt(ef.params[0])

                        res[_arch]["1g"]["pergraw"] += ecnt

                        if ef.type == "ARITH":

                            res[_arch]["1g"]["efcntraw"] += 1
                            res[_arch]["1g"]["perefraw"] += ecnt

        # 1 gadget chains 
        for _arch in ["x86", "arm"]:
            for g in r[_arch].rop_searcher.gadgets:
                
                res[_arch]["1g"]["gcnt"] += 1

                for ef in g.effects:
                    ecnt = _el_cnt(ef.params[0])

                    res[_arch]["1g"]["perg"] += ecnt

                    if ef.type == "ARITH":

                        res[_arch]["1g"]["efcnt"] += 1
                        res[_arch]["1g"]["peref"] += ecnt

        # 2 gadget chains
        for _arch in ["x86", "arm"]:
            for g1 in r[_arch].rop_searcher.gadgets:
                for g2 in r[_arch].rop_searcher.gadgets:

                    ch = g1.join(g2)
                    if ch is None:
                        continue

                    res[_arch]["2g"]["gcnt"] += 1

                    for ef in ch.effects:
                        ecnt = _el_cnt(ef.params[0])

                        res[_arch]["2g"]["perg"] += ecnt

                        if ef.type == "ARITH":

                            res[_arch]["2g"]["efcnt"] += 1
                            res[_arch]["2g"]["peref"] += ecnt

                    ch.remove_stack_ids()

        with open(STATSPATH + f"avg_elem_{bin_idx}.bin", "wb+") as f:
            f.write(pickle.dumps(res))

        for _arch in ["x86", "arm"]:
            for l in ["1g", "2g"]:

                if res[_arch][l]["efcnt"] != 0:
                    res[_arch][l]["peref"] /= res[_arch][l]["efcnt"]
                
                if res[_arch][l]["gcnt"] != 0:
                    res[_arch][l]["perg"] /= res[_arch][l]["gcnt"]
                
                if res[_arch][l]["efcntraw"] != 0:
                    res[_arch][l]["perefraw"] /= res[_arch][l]["efcntraw"]
                
                if res[_arch][l]["gcntraw"] != 0:
                    res[_arch][l]["pergraw"] /= res[_arch][l]["gcntraw"]

        print(res)

        print(f'{bin_idx}: {res["x86"]["1g"]["perefraw"]} {res["arm"]["1g"]["perefraw"]} {res["x86"]["1g"]["peref"]} {res["arm"]["1g"]["peref"]} {res["x86"]["2g"]["peref"]} {res["arm"]["2g"]["peref"]}')
        print(f'{bin_idx}: {res["x86"]["1g"]["pergraw"]} {res["arm"]["1g"]["pergraw"]} {res["x86"]["1g"]["perg"]} {res["arm"]["1g"]["perg"]} {res["x86"]["2g"]["perg"]} {res["arm"]["2g"]["perg"]}')

def gadget_validation_stats():

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _get_valid_cnt(gs):

        cnt = 0

        g: ROP_gadget
        for g in gs:
            if g.valid_stack_access is True and g.valid_jump is True:
                cnt += 1

        return cnt

    def _execute():

        res = \
            {   
                _bin:
                {   
                    _type:
                    {   
                        _ef:
                        {
                            _r: 0
                            for _r in ARM_SUPPORTED_REGS
                        }
                        for _ef in EFFECT_TYPES
                    }
                    for _type in ["raw", "validated", "raw_total"]
                }
                for _bin in ["libc", "other"]
            }  

        for _bin in ["libc", "other"]:
            for _type in ["raw", "validated", "raw_total"]:
                res[_bin][_type].update({"total": 0})

        for _bin in ARM_BINS:

            if _bin == ARM_BINS[1]:
                _bink = "libc"
            else:
                _bink = "other"

            r = ROP_util(BINPATH_ARM + _bin, Platform.ARM64)
            r.scout_for_gadgets()

            raw_valid_total = _get_valid_cnt(r.rop_searcher.raw_gadgets)
            res[_bink]["raw"]["total"] += raw_valid_total
            res[_bink]["validated"]["total"] += len(r.rop_searcher.gadgets) - raw_valid_total
            res[_bink]["raw_total"]["total"] += len(r.rop_searcher.raw_gadgets)

            for _eftype in EFFECT_TYPES:
                for _rout in ARM_SUPPORTED_REGS:

                    raw_valid = _get_valid_cnt(r.rop_searcher.raw_effects_to_gadgets[_eftype][_rout])

                    res[_bink]["raw"][_eftype][_rout] += raw_valid
                    res[_bink]["validated"][_eftype][_rout] += len(r.rop_searcher.effects_to_gadgets[_eftype][_rout]) - raw_valid
                    res[_bink]["raw_total"][_eftype][_rout] += len(r.rop_searcher.raw_effects_to_gadgets[_eftype][_rout])

        with open(STATSPATH_ARM + "validator_efficiency.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():
    
        res = None
        with open(STATSPATH_ARM + "validator_efficiency.bin", "rb") as f_:
            res = f_.read()

        res = pickle.loads(res)

        for _bink in ["libc", "other"]:
            print(f'total valid raw {_bink} {res[_bink]["raw"]["total"]}')
            print(f'total (valid + invalid) raw {_bink} {res[_bink]["raw_total"]["total"]}')
            print(f'total validated {_bink} {res[_bink]["validated"]["total"]}')

        for _bink in ["libc", "other"]:
            for _eftype in EFFECT_TYPES:
                for reg in ARM_SUPPORTED_REGS:
                    print(f"{_eftype}, out reg {reg}: {res[_bink]['raw_total'][_eftype][reg]} | {res[_bink]['raw'][_eftype][reg]} | {res[_bink]['validated'][_eftype][reg]}")

        for _bins in ["libc", "other"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)

                bars_raw = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["raw"][_eftype].keys()],
                                                [fr for fr in res[_bins]["raw"][_eftype].values()],
                                                align = "edge",
                                                width = 0.2
                                            )
                bars_val = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["validated"][_eftype].keys()],
                                                [fr for fr in res[_bins]["validated"][_eftype].values()],
                                                align = "edge",
                                                width = 0.2,
                                                bottom = [fr for fr in res[_bins]["raw"][_eftype].values()]
                                            )
                bars_raw_total = regs_to_fr[idx].bar(
                                                    [r for r in res[_bins]["raw_total"][_eftype].keys()],
                                                    [fr for fr in res[_bins]["raw_total"][_eftype].values()],
                                                    align = "edge",
                                                    width = -0.2
                                                )

                regs_to_fr[idx].bar_label(bars_raw)
                regs_to_fr[idx].bar_label(bars_val)
                regs_to_fr[idx].bar_label(bars_raw_total)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

        for _bink in ["libc", "other"]:
            for _eftype in EFFECT_TYPES:

                if _eftype == "LOAD_S":
                    _eftype_formatted = "LOAD\\_S"
                elif _eftype == "LOAD_CT":
                    _eftype_formatted = "LOAD\\_CT"
                elif _eftype == "MOV_RR":
                    _eftype_formatted = "MOV\\_RR"
                elif _eftype == "ARITH":
                    _eftype_formatted = "ARITH"

                with open(STATSPATH_ARM + f"validator_efficiency_latexplot_{_bink}_{_eftype}.txt", "w+") as f:
                    for _reg in ARM_SUPPORTED_REGS:
                        f.write(f'{_eftype_formatted} & {_reg} & {res[_bink]["raw_total"][_eftype][_reg]} & {res[_bink]["raw"][_eftype][_reg]} & {res[_bink]["validated"][_eftype][_reg]} \\\\\n\\hline\n')

    #_execute()
    _plot()

def transition_graph_stats():

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    X86_SUPPORTED_REGS = deepcopy(Platform.X86_64.SUPPORTED_REGS)

    def _execute():

        assert(len(X86_BINS) == len(ARM_BINS))

        res = \
            {   
                _arch:
                {
                    _bin:
                    {
                        _what: None
                        for _what in ["graph", "path"]
                    }
                    for _bin in range(len(X86_BINS))
                }
                for _arch in ["x86", "arm"]
            }
        
        for bin_idx in range(len(X86_BINS)):
            
            r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[bin_idx], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[bin_idx], Platform.ARM64)}

            r["x86"].scout_for_gadgets()
            r["arm"].scout_for_gadgets()

            gx86, px86 = r["x86"].rop_searcher.get_trans_reg_graph()
            garm, parm = r["arm"].rop_searcher.get_trans_reg_graph()

            # only the main graph, subgraphs are discarded
            gx86, px86 = gx86[""], px86[""]
            garm, parm = garm[""], parm[""]

            res["x86"][bin_idx]["path"] = px86
            res["arm"][bin_idx]["path"] = parm

            res["x86"][bin_idx]["graph"] = \
                {
                    r1:
                    {
                        r2: len(gx86[r1][r2])
                        for r2 in X86_SUPPORTED_REGS
                    }
                    for r1 in X86_SUPPORTED_REGS
                }

            res["arm"][bin_idx]["graph"] = \
                {
                    r1:
                    {
                        r2: len(garm[r1][r2])
                        for r2 in ARM_SUPPORTED_REGS
                    }
                    for r1 in ARM_SUPPORTED_REGS
                }

        with open(STATSPATH + "transgraph.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():

        with open(STATSPATH + "transgraph.bin", "rb") as f:
            res = pickle.loads(f.read())

        bin_idx = 1

        adj_mat_x86 = np.zeros((len(X86_SUPPORTED_REGS), len(X86_SUPPORTED_REGS)), dtype=np.int16)
        adj_mat_arm = np.zeros((len(ARM_SUPPORTED_REGS), len(ARM_SUPPORTED_REGS)), dtype=np.int16)

        path_mat_x86 = np.zeros((len(X86_SUPPORTED_REGS), len(X86_SUPPORTED_REGS)), dtype=np.int16)
        path_mat_arm = np.zeros((len(ARM_SUPPORTED_REGS), len(ARM_SUPPORTED_REGS)), dtype=np.int16)

        _exists = lambda x: 1 if x else 0

        # variables for better heatmap visualization
        _third_x86_sum = 0
        _third_x86_cnt = 0
        _third_arm_sum = 0
        _third_arm_cnt = 0

        for r1 in X86_SUPPORTED_REGS:
            for r2 in X86_SUPPORTED_REGS:
                
                if res["x86"][bin_idx]["graph"][r1][r2] > 0:
                    _third_x86_cnt += 1
                    _third_x86_sum += res["x86"][bin_idx]["graph"][r1][r2]

        for r1 in ARM_SUPPORTED_REGS:
            for r2 in ARM_SUPPORTED_REGS:
                
                if res["arm"][bin_idx]["graph"][r1][r2] > 0:
                    _third_arm_cnt += 1
                    _third_arm_sum += res["arm"][bin_idx]["graph"][r1][r2]

        _third_x86_sum /= _third_x86_cnt
        _third_arm_sum /= _third_arm_cnt

        def _heatx86(c):
            if c == 0:
                return 0
            elif c <= _third_x86_sum:
                return 1
            elif c <= 2 * _third_x86_sum:
                return 2
            else:
                return 3

        def _heatarm(c):
            if c == 0:
                return 0
            elif c <= _third_arm_sum:
                return 1
            elif c <= 2 * _third_arm_sum:
                return 2
            else:
                return 3

        for r1i, r1 in enumerate(X86_SUPPORTED_REGS):
            for r2i, r2 in enumerate(X86_SUPPORTED_REGS):

                adj_mat_x86[r1i, r2i] = _heatx86(res["x86"][bin_idx]["graph"][r1][r2])
                path_mat_x86[r1i, r2i] = _exists(res["x86"][bin_idx]["path"][r1][r2])

        for r1i, r1 in enumerate(ARM_SUPPORTED_REGS):
            for r2i, r2 in enumerate(ARM_SUPPORTED_REGS):

                adj_mat_arm[r1i, r2i] = _heatarm(res["arm"][bin_idx]["graph"][r1][r2])
                path_mat_arm[r1i, r2i] = _exists(res["arm"][bin_idx]["path"][r1][r2])

        fix_x86, mats_x86 = plt.subplots(1, 2)
        fig_arm, mats_arm = plt.subplots(1, 2)

        mats_x86[0].imshow(adj_mat_x86)
        mats_x86[1].imshow(path_mat_x86)

        mats_arm[0].imshow(adj_mat_arm)
        mats_arm[1].imshow(path_mat_arm)

        mats_x86[0].set_xticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)
        mats_x86[0].set_yticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)

        mats_x86[1].set_xticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)
        mats_x86[1].set_yticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)

        mats_arm[0].set_xticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)
        mats_arm[0].set_yticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)

        mats_arm[1].set_xticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)
        mats_arm[1].set_yticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)

        mats_x86[0].set_title("Adjacency matrix for libc, x86_64")
        mats_x86[1].set_title("Path matrix for libc, x86_64")

        mats_arm[0].set_title("Adjacency matrix for libc, ARM64")
        mats_arm[1].set_title("Path matrix for libc, ARM64")

        #fig.tight_layout()
        plt.show()

    def _transition_gen_timing():

        r = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)
        r.scout_for_gadgets()

        graph, path = r.rop_searcher.get_trans_reg_graph()
        graph = graph[""]
        path = path[""]

        combs = [("x0", "x27"), ("x0", "x21"), ("x3", "x7"), ("x9", "x22"), ("x27", "x19")]
        res = {}

        for src, dest in combs:
            
            print(f"searching path from {dest} <- {src}")

            if path[dest][src] is False:
                print("path does not exist")
                continue
            
            cnt = 0
            max_len = 0

            _t = time.time()

            for glist, _ in r.rop_searcher.transition_chain_generator(dest, src, graph, path, 2 ** 63):
                cnt += 1
                if len(glist) > max_len:
                    max_len = len(glist)

            _t = time.time() - _t

            res.update({(dest, src): (cnt, max_len, _t)})

        with open(STATSPATH_ARM + "trans_gen_timing.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _transition_gen_plot():

        with open(STATSPATH_ARM + "trans_gen_timing.bin", "rb") as f:
            res = pickle.loads(f.read())

        print(res)

    _execute()
    _plot()
    _transition_gen_timing()
    _transition_gen_plot()

def stack_join_failure_stats():

    res = \
        {
            _arch:
            {
                _stat: 0
                for _stat in ["p sp<end 1g", "p sp<end 2g", "p fail"]
            }
            for _arch in ["x86", "arm"]
        }

    r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64),
            "arm": ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)}

    for _arch in ["x86", "arm"]:

        for g in r[_arch].rop_searcher.gadgets:

            if g.end_sp_pos < len(g.stack.elements):
                res[_arch]["p sp<end 1g"] += 1

        res[_arch]["p sp<end 1g"] /= len(r[_arch].rop_searcher.gadgets)

    for _arch in ["x86", "arm"]:

        ch_cnt = 0

        for g1 in r[_arch].rop_searcher.gadgets:
            for g2 in r[_arch].rop_searcher.gadgets:

                ch = g1.join(g2)

                if ch is None:
                    res[_arch]["p fail"] += 1

                else:

                    ch_cnt += 1

                    if ch.end_sp_pos < len(ch.stack.elements):
                        res[_arch]["p sp<end 2g"] += 1

                    ch.remove_stack_ids()
                    
        res[_arch]["p fail"] /= len(r[_arch].rop_searcher.gadgets) ** 2
        res[_arch]["p sp<end 2g"] /= ch_cnt

    with open(STATSPATH_ARM + "sjoin_stats.bin", "wb+") as f:
        f.write(pickle.dumps(res))

    print(f'done: {res}')

def gsearch_stats():

    wefs = {"x86": ["rax = r8 + 0xcaffee", "rcx = 0xaabbccddeeff", "rdx = rax ^ rbx", "r8 = r8 + r9", "rdx = rcx", "rax = rax & 0xffffffff",
                    "rbx = r9 + (r10 & 0xffffffff)", "rax = 0x0"],
                "arm": ["x0 = x1 + 0xcaffee", "x5 = 0xaabbccddeeff", "x7 = x8 ^ x9", "x2 = x1 + x2", "x5 = x10", "x0 = x0 & 0xffffffff",
                        "x2 = x4 + (x5 & 0xffffffff)", "x0 = 0x0"]}

    mss = {"x86": [0x60, 2 ** 63],
            "arm": [0x100, 2 ** 63]}

    fixed_regs = {"x86": [[], ["rbx", "rdx"]],
                    "arm": [[], ["x5", "x6"]]}

    reg_start_values = {"x86": ["", "r9 = rax", "r10 = 0x0, r12 = 0x0"],
                        "arm": ["", "x8 = x0", "x25 = 0x0, x26 = 0x0"]}

    def _execute():
    
        res = []

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)}

        for _arch in ["x86", "arm"]:        
            for wef in wefs[_arch]:
                for mss_ in mss[_arch]:
                    for frs in fixed_regs[_arch]:
                        for rstart in reg_start_values[_arch]:
                            
                            _t = time.time()
                            for gs in r[_arch].search_chain(wanted_effects=wef, max_stack_byte_size=mss_, fixed_regs=frs,
                                                            reg_start_values=rstart, max_search_cnt=2**63,
                                                            only_gadgets=True):
                                break

                            _t = time.time() - _t 
                            res.append((wef, mss_, frs, rstart, 2**63, _t))

        print("done")
        with open(STATSPATH + "gsearch_stats.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():

        with open(STATSPATH + "gsearch_stats.bin", "rb") as f:
            res = pickle.loads(f.read())

        '''gets_ = "$\\gets$"
        inf_ = "$2^{63}$"

        for wef, mss_, frs, rstart, _, _t in res:
            
            formatted_mss = f"{hex(mss_)}" if mss_ < 2 ** 63 else inf_
            wef = wef.replace("=", gets_)
            rstart = rstart.replace("=", gets_)

            print(f"{wef} & {formatted_mss} & {frs} & {rstart} & {inf_} & {_t} \\\\\n\\hline")'''

        _, (hx86, harm) = plt.subplots(2)

        _, _, hist_x86 = hx86.hist(x = [sample[5] for sample in res if "r" in sample[0]], 
                                    bins = 50)

        _, _, hist_arm = harm.hist(x = [sample[5] for sample in res if "r" not in sample[0]], 
                                    bins = 50)

        hx86.set_title("x86_64")
        harm.set_title("ARM64")

        plt.show()

    #_execute()
    _plot()

def mov_rr_search_stats():

    '''
        NOTE: to use only the substitution based mov search, 
                comment the corresponding lines in the search_chain() method
                in ROP_searcher class
    '''

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    X86_SUPPORTED_REGS = deepcopy(Platform.X86_64.SUPPORTED_REGS)

    supregs = {"x86": X86_SUPPORTED_REGS, "arm": ARM_SUPPORTED_REGS}

    def _avgtime():

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)}

        r["x86"].rop_searcher.get_trans_reg_graph()
        r["arm"].rop_searcher.get_trans_reg_graph()
        
        res = \
            {
                _arch:
                {
                    freg_cnt: 0
                    for freg_cnt in [0, 1, 2] 
                }
                for _arch in ["x86", "arm"]
            }

        for _arch in ["x86", "arm"]:
            for freg_cnt in [0, 1, 2]:

                #print(_arch, freg_cnt)

                found_cnt = 0

                for rd in supregs[_arch]:
                    for rs in supregs[_arch]:

                        if freg_cnt == 0:
                            fregs = []

                        elif freg_cnt == 1:

                            fr1 = random.choice(supregs[_arch])
                            while fr1 == rd or fr1 == rs:
                                fr1 = random.choice(supregs[_arch])

                            fregs = [fr1]

                        elif freg_cnt == 2:

                            fr1 = random.choice(supregs[_arch])
                            while fr1 == rd or fr1 == rs:
                                fr1 = random.choice(supregs[_arch])

                            fr2 = random.choice(supregs[_arch])
                            while fr2 == rd or fr2 == rs or fr2 == fr1:
                                fr2 = random.choice(supregs[_arch])

                            fregs = [fr1, fr2]

                        _t = time.time()
                        for g in r[_arch].search_chain(wanted_effects = f"{rd} = {rs}", fixed_regs = fregs):
                            
                            _t = time.time() - _t

                            res[_arch][freg_cnt] += _t
                            found_cnt += 1
                            break             

                res[_arch][freg_cnt] /= found_cnt

        print(f"done: {res}")
        with open(STATSPATH + "movrr_search_avg.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _extremes():

        fex = open(STATSPATH + "movrr_search_extremes.txt", "w+")

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)}

        r["x86"].rop_searcher.get_trans_reg_graph()
        r["arm"].rop_searcher.get_trans_reg_graph()

        g_ = []
        
        for _arch in ["x86", "arm"]:

            for rd in supregs[_arch]:
                for rs in supregs[_arch]:

                    if rs == rd:
                        continue

                    fregs = []

                    supregs_ = deepcopy(supregs[_arch])
                    supregs_.remove(rd)
                    supregs_.remove(rs)

                    while len(fregs) < 5:

                        freg = random.choice(supregs_)
                        supregs_.remove(freg)

                        fregs.append(freg)

                    _t = time.time()
                    for g in r[_arch].search_chain(wanted_effects = f"{rd} = {rs}", fixed_regs = fregs):

                        g_.append(g)
                    
                        _t = time.time() - _t
                        fex.write(f"{rd} <- {rs}: {_t}")
                        fex.flush()

                        break             

        print("done")

    _avgtime()
    _extremes()

def subst_arith_search_stats():
    
    def _x86():
        
        r = ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64)

        wef_ok = "rax = rdx + 0xdeadbeef"
        wef_notfound = "rdx = (rcx & 0xbadcaffee) + r9"


    def _arm():

        r = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)

        wef_ok = "x0 = x2 + 0xdeadbeef"
        wef_notfound = ""

    def _plot_x86():
        pass

    def _plot_arm():
        pass

    _x86()
    _arm()
    _plot_x86()
    _plot_arm()

if __name__ == "__main__":

    #gadget_distribution_stats()
    #average_elements_stats()
    #gadget_validation_stats()
    #transition_graph_stats()
    #stack_join_failure_stats()
    gsearch_stats()
    #mov_rr_search_stats()
    #subst_arith_search_stats()
    pass