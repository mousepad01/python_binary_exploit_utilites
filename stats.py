from roputils import *

import time
import pickle
import matplotlib.pyplot as plt
import numpy as np

BINPATH_X86 = "./stats_binaries/x86_64/"
BINPATH_ARM = "./stats_binaries/arm64/"
STATSPATH_X86 = "../rop_payload_gen_doc/stats_plots/x86/"
STATSPATH_ARM = "../rop_payload_gen_doc/stats_plots/arm/"
STATSPATH = "../rop_payload_gen_doc/stats_plots/"

X86_BINS = ["ld-2.31.so",
            "libc-2.31.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.6.0",
            "libm-2.31.so",
            "libpthread-2.31.so"]

ARM_BINS = ["ld-2.33.so",
            "libc-2.33.so",
            "libcrypt.so.1.1.0",
            "libcurl.so.4.7.0",
            "libm-2.33.so",
            "libpthread-2.33.so"]

def gadget_distribution_stats():

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _x86():
        
        distrib_x86 = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in Platform.X86_64.SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_x86 = ROP_util(BINPATH_X86 + X86_BINS[1], Platform.X86_64)   
        r_x86.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in Platform.X86_64.SUPPORTED_REGS:
                distrib_x86["libc"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in X86_BINS:
            if binname != X86_BINS[1]:

                r_x86 = ROP_util(BINPATH_X86 + binname, Platform.X86_64)   
                r_x86.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in Platform.X86_64.SUPPORTED_REGS:
                        distrib_x86["other binaries (summed)"][ef][reg] += len(r_x86.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_x86)
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _arm():

        ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
        ARM_SUPPORTED_REGS.remove("x30")
        
        distrib_arm = \
        {
            _bins:
            {
                _eftype:
                {
                    reg: 0 for reg in ARM_SUPPORTED_REGS
                }
                for _eftype in EFFECT_TYPES
            }
            for _bins in ["libc", "other binaries (summed)"]
        }

        r_arm = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)   
        r_arm.scout_for_gadgets()
        
        for ef in EFFECT_TYPES:
            for reg in ARM_SUPPORTED_REGS:
                distrib_arm["libc"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        for binname in ARM_BINS:
            if binname != ARM_BINS[1]:

                r_arm = ROP_util(BINPATH_ARM + binname, Platform.ARM64)   
                r_arm.scout_for_gadgets()
                
                for ef in EFFECT_TYPES:
                    for reg in ARM_SUPPORTED_REGS:
                        distrib_arm["other binaries (summed)"][ef][reg] += len(r_arm.rop_searcher.effects_to_gadgets[ef][reg])

        g_distrib_stats = pickle.dumps(distrib_arm)
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "wb+") as f_:
            f_.write(g_distrib_stats)

    def _plot_x86():
        
        g_distrib_stats = None
        with open(STATSPATH_X86 + "g_distrib_x86.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )

                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    def _plot_arm():
        
        g_distrib_stats = None
        with open(STATSPATH_ARM + "g_distrib_arm.bin", "rb") as f_:
            g_distrib_stats = f_.read()

        g_distrib_stats = pickle.loads(g_distrib_stats)

        for _bins in ["libc", "other binaries (summed)"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)
                bars = regs_to_fr[idx].bar(
                                            [r for r in g_distrib_stats[_bins][_eftype].keys()],
                                            [fr for fr in g_distrib_stats[_bins][_eftype].values()]
                                        )
                regs_to_fr[idx].bar_label(bars)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

    #_x86()
    #_arm()

    #_plot_x86()
    #_plot_arm()

    return None

def average_elements_stats():

    constant_el_cnt_types = {"ct_val", "64b_stack_val", "reg_in", "reg_out"}
    ops = {"add", "sub", "and", "or", "xor", "neg", "mul", "lsh", "rsh"}

    def _el_cnt(e: Structured_element):

        if e is None:
            return 0

        if e.type in constant_el_cnt_types:
            return 1

        if e.type == "deref":
            return _el_cnt(e.info["expr"])

        if e.type in ops:
            return _el_cnt(e.info["term_1"]) + _el_cnt(e.info["term_2"])

    assert(len(X86_BINS) == len(ARM_BINS))
    for bin_idx in range(2, len(X86_BINS)):

        r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[bin_idx], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[bin_idx], Platform.ARM64)}

        r["x86"].scout_for_gadgets()
        r["arm"].scout_for_gadgets()

        res = \
            {
                _arch:
                {   
                    l:
                    {
                        "peref": 0,
                        "perefraw": 0,
                        "perg": 0,
                        "pergraw": 0,
                        "efcnt": 0,
                        "efcntraw": 0,
                        "gcnt": 0,
                        "gcntraw": 0
                    }
                    for l in {"1g", "2g"}
                }
                for _arch in {"x86", "arm"}
            }

        # arm raw valid gadgets

        for g in r["arm"].rop_searcher.raw_gadgets:
            if g.valid_jump is True and g.valid_stack_access is True:
                
                res["arm"]["1g"]["gcntraw"] += 1

                for ef in g.effects:
                    ecnt = _el_cnt(ef.params[0])

                    res["arm"]["1g"]["pergraw"] += ecnt

                    if ef.type == "ARITH":

                        res["arm"]["1g"]["efcntraw"] += 1
                        res["arm"]["1g"]["perefraw"] += ecnt

        # 1 gadget chains 
        for _arch in ["x86", "arm"]:
            for g in r[_arch].rop_searcher.gadgets:
                
                res[_arch]["1g"]["gcnt"] += 1

                for ef in g.effects:
                    ecnt = _el_cnt(ef.params[0])

                    res[_arch]["1g"]["perg"] += ecnt

                    if ef.type == "ARITH":

                        res[_arch]["1g"]["efcnt"] += 1
                        res[_arch]["1g"]["peref"] += ecnt

        # 2 gadget chains
        for _arch in ["x86", "arm"]:
            for g1 in r[_arch].rop_searcher.gadgets:
                for g2 in r[_arch].rop_searcher.gadgets:

                    ch = g1.join(g2)
                    if ch is None:
                        continue

                    res[_arch]["2g"]["gcnt"] += 1

                    for ef in ch.effects:
                        ecnt = _el_cnt(ef.params[0])

                        res[_arch]["2g"]["perg"] += ecnt

                        if ef.type == "ARITH":

                            res[_arch]["2g"]["efcnt"] += 1
                            res[_arch]["2g"]["peref"] += ecnt

                    ch.remove_stack_ids()

        with open(STATSPATH + f"avg_elem_{bin_idx}.bin", "wb+") as f:
            f.write(pickle.dumps(res))

        for _arch in ["x86", "arm"]:
            for l in ["1g", "2g"]:

                if res[_arch][l]["efcnt"] != 0:
                    res[_arch][l]["peref"] /= res[_arch][l]["efcnt"]
                
                if res[_arch][l]["gcnt"] != 0:
                    res[_arch][l]["perg"] /= res[_arch][l]["gcnt"]
                
                if res[_arch][l]["efcntraw"] != 0:
                    res[_arch][l]["perefraw"] /= res[_arch][l]["efcntraw"]
                
                if res[_arch][l]["gcntraw"] != 0:
                    res[_arch][l]["pergraw"] /= res[_arch][l]["gcntraw"]

        print(res)

        print(f'{bin_idx}: {res["x86"]["1g"]["peref"]} {res["arm"]["1g"]["perefraw"]} {res["arm"]["1g"]["peref"]} {res["x86"]["2g"]["peref"]} {res["arm"]["2g"]["peref"]}')
        print(f'{bin_idx}: {res["x86"]["1g"]["perg"]} {res["arm"]["1g"]["pergraw"]} {res["arm"]["1g"]["perg"]} {res["x86"]["2g"]["perg"]} {res["arm"]["2g"]["perg"]}')

def gadget_validation_stats():

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    EFFECT_TYPES = ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]

    def _get_valid_cnt(gs):

        cnt = 0

        g: ROP_gadget_ARM64
        for g in gs:
            if g.valid_stack_access is True and g.valid_jump is True:
                cnt += 1

        return cnt

    def _execute():

        res = \
            {   
                _bin:
                {   
                    _type:
                    {   
                        _ef:
                        {
                            _r: 0
                            for _r in ARM_SUPPORTED_REGS
                        }
                        for _ef in EFFECT_TYPES
                    }
                    for _type in ["raw", "validated", "raw_total"]
                }
                for _bin in ["libc", "other"]
            }  

        for _bin in ["libc", "other"]:
            for _type in ["raw", "validated", "raw_total"]:
                res[_bin][_type].update({"total": 0})

        for _bin in ARM_BINS:

            if _bin == ARM_BINS[1]:
                _bink = "libc"
            else:
                _bink = "other"

            r = ROP_util(BINPATH_ARM + _bin, Platform.ARM64)
            r.scout_for_gadgets()

            raw_valid_total = _get_valid_cnt(r.rop_searcher.raw_gadgets)
            res[_bink]["raw"]["total"] += raw_valid_total
            res[_bink]["validated"]["total"] += len(r.rop_searcher.gadgets) - raw_valid_total
            res[_bink]["raw_total"]["total"] += len(r.rop_searcher.raw_gadgets)

            for _eftype in EFFECT_TYPES:
                for _rout in ARM_SUPPORTED_REGS:

                    raw_valid = _get_valid_cnt(r.rop_searcher.raw_effects_to_gadgets[_eftype][_rout])

                    res[_bink]["raw"][_eftype][_rout] += raw_valid
                    res[_bink]["validated"][_eftype][_rout] += len(r.rop_searcher.effects_to_gadgets[_eftype][_rout]) - raw_valid
                    res[_bink]["raw_total"][_eftype][_rout] += len(r.rop_searcher.raw_effects_to_gadgets[_eftype][_rout])

        with open(STATSPATH_ARM + "validator_efficiency.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():
    
        res = None
        with open(STATSPATH_ARM + "validator_efficiency.bin", "rb") as f_:
            res = f_.read()

        res = pickle.loads(res)

        for _bink in ["libc", "other"]:
            print(f'total valid raw {_bink} {res[_bink]["raw"]["total"]}')
            print(f'total (valid + invalid) raw {_bink} {res[_bink]["raw_total"]["total"]}')
            print(f'total validated {_bink} {res[_bink]["validated"]["total"]}')

        for _bink in ["libc", "other"]:
            for _eftype in EFFECT_TYPES:
                for reg in ARM_SUPPORTED_REGS:
                    print(f"{_eftype}, out reg {reg}: {res[_bink]['raw_total'][_eftype][reg]} | {res[_bink]['raw'][_eftype][reg]} | {res[_bink]['validated'][_eftype][reg]}")

        for _bins in ["libc", "other"]:

            fig, regs_to_fr = plt.subplots(len(EFFECT_TYPES))
    
            for idx, _eftype in enumerate(EFFECT_TYPES):
                
                regs_to_fr[idx].set_title(_eftype)

                bars_raw = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["raw"][_eftype].keys()],
                                                [fr for fr in res[_bins]["raw"][_eftype].values()],
                                                align = "edge",
                                                width = 0.2
                                            )
                bars_val = regs_to_fr[idx].bar(
                                                [r for r in res[_bins]["validated"][_eftype].keys()],
                                                [fr for fr in res[_bins]["validated"][_eftype].values()],
                                                align = "edge",
                                                width = 0.2,
                                                bottom = [fr for fr in res[_bins]["raw"][_eftype].values()]
                                            )
                bars_raw_total = regs_to_fr[idx].bar(
                                                    [r for r in res[_bins]["raw_total"][_eftype].keys()],
                                                    [fr for fr in res[_bins]["raw_total"][_eftype].values()],
                                                    align = "edge",
                                                    width = -0.2
                                                )

                regs_to_fr[idx].bar_label(bars_raw)
                regs_to_fr[idx].bar_label(bars_val)
                regs_to_fr[idx].bar_label(bars_raw_total)

            fig.tight_layout()
            #fig.suptitle(_bins)

        plt.show()

        for _bink in ["libc", "other"]:
            for _eftype in EFFECT_TYPES:

                if _eftype == "LOAD_S":
                    _eftype_formatted = "LOAD\\_S"
                elif _eftype == "LOAD_CT":
                    _eftype_formatted = "LOAD\\_CT"
                elif _eftype == "MOV_RR":
                    _eftype_formatted = "MOV\\_RR"
                elif _eftype == "ARITH":
                    _eftype_formatted = "ARITH"

                with open(STATSPATH_ARM + f"validator_efficiency_latexplot_{_bink}_{_eftype}.txt", "w+") as f:
                    for _reg in ARM_SUPPORTED_REGS:
                        f.write(f'{_eftype_formatted} & {_reg} & {res[_bink]["raw_total"][_eftype][_reg]} & {res[_bink]["raw"][_eftype][_reg]} & {res[_bink]["validated"][_eftype][_reg]} \\\\\n\\hline\n')

    #_execute()
    _plot()

def transition_graph_stats():

    ARM_SUPPORTED_REGS = deepcopy(Platform.ARM64.SUPPORTED_REGS)
    ARM_SUPPORTED_REGS.remove("x30")

    X86_SUPPORTED_REGS = deepcopy(Platform.X86_64.SUPPORTED_REGS)

    def _execute():

        assert(len(X86_BINS) == len(ARM_BINS))

        res = \
            {   
                _arch:
                {
                    _bin:
                    {
                        _what: None
                        for _what in ["graph", "path"]
                    }
                    for _bin in range(len(X86_BINS))
                }
                for _arch in ["x86", "arm"]
            }
        
        for bin_idx in range(len(X86_BINS)):
            
            r = {"x86": ROP_util(BINPATH_X86 + X86_BINS[bin_idx], Platform.X86_64),
                "arm": ROP_util(BINPATH_ARM + ARM_BINS[bin_idx], Platform.ARM64)}

            r["x86"].scout_for_gadgets()
            r["arm"].scout_for_gadgets()

            gx86, px86 = r["x86"].rop_searcher.get_trans_reg_graph()
            garm, parm = r["arm"].rop_searcher.get_trans_reg_graph()

            # only the main graph, subgraphs are discarded
            gx86, px86 = gx86[""], px86[""]
            garm, parm = garm[""], parm[""]

            res["x86"][bin_idx]["path"] = px86
            res["arm"][bin_idx]["path"] = parm

            res["x86"][bin_idx]["graph"] = \
                {
                    r1:
                    {
                        r2: len(gx86[r1][r2])
                        for r2 in X86_SUPPORTED_REGS
                    }
                    for r1 in X86_SUPPORTED_REGS
                }

            res["arm"][bin_idx]["graph"] = \
                {
                    r1:
                    {
                        r2: len(garm[r1][r2])
                        for r2 in ARM_SUPPORTED_REGS
                    }
                    for r1 in ARM_SUPPORTED_REGS
                }

        with open(STATSPATH + "transgraph.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    def _plot():

        with open(STATSPATH + "transgraph.bin", "rb") as f:
            res = pickle.loads(f.read())

        bin_idx = 1

        adj_mat_x86 = np.zeros((len(X86_SUPPORTED_REGS), len(X86_SUPPORTED_REGS)), dtype=np.int16)
        adj_mat_arm = np.zeros((len(ARM_SUPPORTED_REGS), len(ARM_SUPPORTED_REGS)), dtype=np.int16)

        path_mat_x86 = np.zeros((len(X86_SUPPORTED_REGS), len(X86_SUPPORTED_REGS)), dtype=np.int16)
        path_mat_arm = np.zeros((len(ARM_SUPPORTED_REGS), len(ARM_SUPPORTED_REGS)), dtype=np.int16)

        _exists = lambda x: 1 if x else 0

        # variables for better heatmap visualization
        _third_x86_sum = 0
        _third_x86_cnt = 0
        _third_arm_sum = 0
        _third_arm_cnt = 0

        for r1 in X86_SUPPORTED_REGS:
            for r2 in X86_SUPPORTED_REGS:
                
                if res["x86"][bin_idx]["graph"][r1][r2] > 0:
                    _third_x86_cnt += 1
                    _third_x86_sum += res["x86"][bin_idx]["graph"][r1][r2]

        for r1 in ARM_SUPPORTED_REGS:
            for r2 in ARM_SUPPORTED_REGS:
                
                if res["arm"][bin_idx]["graph"][r1][r2] > 0:
                    _third_arm_cnt += 1
                    _third_arm_sum += res["arm"][bin_idx]["graph"][r1][r2]

        _third_x86_sum /= _third_x86_cnt
        _third_arm_sum /= _third_arm_cnt

        def _heatx86(c):
            if c == 0:
                return 0
            elif c <= _third_x86_sum:
                return 1
            elif c <= 2 * _third_x86_sum:
                return 2
            else:
                return 3

        def _heatarm(c):
            if c == 0:
                return 0
            elif c <= _third_arm_sum:
                return 1
            elif c <= 2 * _third_arm_sum:
                return 2
            else:
                return 3

        for r1i, r1 in enumerate(X86_SUPPORTED_REGS):
            for r2i, r2 in enumerate(X86_SUPPORTED_REGS):

                adj_mat_x86[r1i, r2i] = _heatx86(res["x86"][bin_idx]["graph"][r1][r2])
                path_mat_x86[r1i, r2i] = _exists(res["x86"][bin_idx]["path"][r1][r2])

        for r1i, r1 in enumerate(ARM_SUPPORTED_REGS):
            for r2i, r2 in enumerate(ARM_SUPPORTED_REGS):

                adj_mat_arm[r1i, r2i] = _heatarm(res["arm"][bin_idx]["graph"][r1][r2])
                path_mat_arm[r1i, r2i] = _exists(res["arm"][bin_idx]["path"][r1][r2])

        fix_x86, mats_x86 = plt.subplots(1, 2)
        fig_arm, mats_arm = plt.subplots(1, 2)

        mats_x86[0].imshow(adj_mat_x86)
        mats_x86[1].imshow(path_mat_x86)

        mats_arm[0].imshow(adj_mat_arm)
        mats_arm[1].imshow(path_mat_arm)

        mats_x86[0].set_xticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)
        mats_x86[0].set_yticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)

        mats_x86[1].set_xticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)
        mats_x86[1].set_yticks(np.arange(len(X86_SUPPORTED_REGS)), labels=X86_SUPPORTED_REGS)

        mats_arm[0].set_xticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)
        mats_arm[0].set_yticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)

        mats_arm[1].set_xticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)
        mats_arm[1].set_yticks(np.arange(len(ARM_SUPPORTED_REGS)), labels=ARM_SUPPORTED_REGS)

        mats_x86[0].set_title("Adjacency matrix for libc, x86_64")
        mats_x86[1].set_title("Path matrix for libc, x86_64")

        mats_arm[0].set_title("Adjacency matrix for libc, ARM64")
        mats_arm[1].set_title("Path matrix for libc, ARM64")

        #fig.tight_layout()
        plt.show()

    def _transition_gen_timing():

        r = ROP_util(BINPATH_ARM + ARM_BINS[1], Platform.ARM64)
        r.scout_for_gadgets()

        graph, path = r.rop_searcher.get_trans_reg_graph()
        graph = graph[""]
        path = path[""]

        combs = [("x0", "x27"), ("x0", "x21"), ("x3", "x7"), ("x9", "x22"), ("x27", "x19")]
        res = {}

        _tmp = []

        for src, dest in combs:
            
            print(f"searching path from {dest} <- {src}")

            if path[dest][src] is False:
                print("path does not exist")
                continue
            
            cnt = 0

            _t = time.time()

            for glist in r.rop_searcher.transition_chain_generator(dest, src, graph, path, 2 ** 63):
                cnt += 1
                _tmp.append(glist)

            _t = time.time() - _t

            _tmp = []

            res.update({(dest, src): (cnt, _t)})

        with open(BINPATH_ARM + "trans_gen_timing.bin", "wb+") as f:
            f.write(pickle.dumps(res))

    #_execute()
    #_plot()
    _transition_gen_timing()

if __name__ == "__main__":

    #gadget_distribution_stats()
    #average_elements_stats()
    #gadget_validation_stats()
    transition_graph_stats()
