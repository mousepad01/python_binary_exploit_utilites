from typing import List, Tuple

from logger import Logger

# the implementations presented here 
# are limited to some types of binaries on some types of architectures
# the binary is not fully parsed, 
# but rather some base classes are implemented,
# that easily allow any functionality extension required to be implemented "on the spot"
# so, mostly, only the functionalities used up to the current moment are implemented (and also a few general, easy to implement ones)
        
SIZE_UINT64 = 8
SIZE_UINT32 = 4
SIZE_UINT16 = 2

class Elf_util:

    def _load_sh_list(self):
        
        sh_offset = self.header.section_headers_file_offset
        if sh_offset is None:
            return

        sh_size = self.header.section_headers_entry_size
        sh_count = self.header.section_headers_count

        offset = sh_offset
        self.sh_list = []

        for i in range(sh_count):

            self.sh_list.append(Elf_sh(self.bin, offset))
            offset += sh_size

    def _load_ph_list(self):
        
        ph_offset = self.header.program_headers_file_offset
        if ph_offset is None:
            return

        ph_size = self.header.program_headers_entry_size
        ph_count = self.header.program_headers_count

        offset = ph_offset
        self.ph_list = []

        for i in range(ph_count):

            self.ph_list.append(Elf_ph(self.bin, offset))
            offset += ph_size

    def __init__(self, filepath, print_log=True, session_name=None):
        
        self.bin = open(filepath, "rb")
        self.bin_memory_loaded = None

        self.header = Elf_header(self.bin)

        self.sh_list = None
        self._load_sh_list()

        self.ph_list = None
        self._load_ph_list()

        self.logger = Logger(session_name = session_name, print_log = print_log)

    def load_in_memory(self):
        self.bin_memory_loaded = self.bin.read()

    def load_x_bytes(self) -> List[Tuple[int, bytes]]:

        if self.ph_list is None:
            raise RuntimeError("Cannot find executable bytes if no program header has been found")

        loaded_bytes = []
        
        ph: Elf_ph
        for ph in self.ph_list:

            if ph.is_executable():

                self.bin.seek(ph.file_offset)
                loaded_bytes.append((ph.vaddr_offset, self.bin.read(ph.file_size)))

        return loaded_bytes

class Elf_header:

    '''
    typedef struct {
        unsigned char e_ident[16];
        uint16_t e_type;
        uint16_t e_machine;
        uint32_t e_version;
        uint64_t e_entry;
        uint64_t e_phoff;
        uint64_t e_shoff;
        uint32_t e_flags;
        uint16_t e_ehsize;
        uint16_t e_phentsize;
        uint16_t e_phnum;
        uint16_t e_shentsize;
        uint16_t e_shnum;
        uint16_t e_shstrndx;
    } Elf64_Ehdr;
    '''

    def __init__(self, bin):
        
        self.e_ident = bin.read(16)

        if self.e_ident[0: 4] != b'\x7f\x45\x4c\x46':
            raise RuntimeError("The opened file is not an ELF")

        if self.e_ident[4: 5] != b'\x02':
            raise RuntimeError("The file is not a 64 bit ELF (not supported)")

        if self.e_ident[5: 6] != b'\x01':
            raise RuntimeError("The file is big endian (not supported)")

        #if self.e_ident[7: 8] != b'\x00':
        #    raise RuntimeError("The file does not use System V ABI (not supported)") 

        self.e_type = bin.read(SIZE_UINT16)
        self.e_machine = bin.read(SIZE_UINT16)
        self.e_version = bin.read(SIZE_UINT32)
        self.e_entry = bin.read(SIZE_UINT64)
        self.e_phoff = bin.read(SIZE_UINT64)
        self.e_shoff = bin.read(SIZE_UINT64)
        self.e_flags = bin.read(SIZE_UINT32)
        self.e_ehsize = bin.read(SIZE_UINT16)
        self.e_phentsize = bin.read(SIZE_UINT16)
        self.e_phnum = bin.read(SIZE_UINT16)
        self.e_shentsize = bin.read(SIZE_UINT16)
        self.e_shnum = bin.read(SIZE_UINT16)
        self.e_shstrndx = bin.read(SIZE_UINT16)

        if self.e_machine != b'\x3e\x00' and self.e_machine != b'\xb7\x00':
            raise RuntimeError("This file is not for x86_64, nor ARM64 (not supported)")

        self.section_headers_file_offset = int.from_bytes(self.e_shoff, 'little')
        if self.section_headers_file_offset == 0:
            self.section_headers_file_offset = None

        self.program_headers_file_offset = int.from_bytes(self.e_phoff, 'little')
        if self.program_headers_file_offset == 0:
            self.program_headers_file_offset = None

        self.section_headers_entry_size = int.from_bytes(self.e_shentsize, 'little')
        self.program_headers_entry_size = int.from_bytes(self.e_phentsize, 'little')

        self.section_headers_count = int.from_bytes(self.e_shnum, 'little')
        self.program_headers_count = int.from_bytes(self.e_phnum, 'little')

        self.entry_point_addr = int.from_bytes(self.e_entry, 'little')

        self.sh_str_table_index = int.from_bytes(self.e_shstrndx, 'little')

class Elf_sh:

    '''
    typedef struct {
        uint32_t sh_name;
        uint32_t sh_type;
        uint64_t sh_flags;
        uint64_t sh_addr;
        uint64_t sh_offset;
        uint64_t sh_size;
        uint32_t sh_link;
        uint32_t sh_info;
        uint64_t sh_addralign;
        uint64_t sh_entsize;
    } Elf64_Shdr;
    '''

    def __init__(self, bin, offset):
        
        self.bin = bin
        self.bin.seek(offset)

        self.sh_name = bin.read(SIZE_UINT32)
        self.sh_type = bin.read(SIZE_UINT32)
        self.sh_flags = bin.read(SIZE_UINT64)
        self.sh_addr = bin.read(SIZE_UINT64)
        self.sh_offset = bin.read(SIZE_UINT64)
        self.sh_size = bin.read(SIZE_UINT64)
        self.sh_link = bin.read(SIZE_UINT32)
        self.sh_info = bin.read(SIZE_UINT32)
        self.sh_addralign = bin.read(SIZE_UINT64)
        self.sh_entsize = bin.read(SIZE_UINT64)

class Elf_ph:

    '''
    typedef struct {
        uint32_t p_type;
        uint32_t p_flags;
        uint64_t p_offset;
        uint64_t p_vaddr;
        uint64_t p_paddr;
        uint64_t p_filesz;
        uint64_t p_memsz;
        uint64_t p_align;
    } Elf64_Phdr;
    '''

    def is_executable(self):

        if (self.flags & 0x01) > 0:
            return True
        return False

    def __init__(self, bin, offset):
        
        self.bin = bin
        self.bin.seek(offset)

        self.p_type = bin.read(SIZE_UINT32)
        self.p_flags = bin.read(SIZE_UINT32)
        self.p_offset = bin.read(SIZE_UINT64)
        self.p_vaddr = bin.read(SIZE_UINT64)
        self.p_paddr = bin.read(SIZE_UINT64)
        self.p_filesz = bin.read(SIZE_UINT64)
        self.p_memsz = bin.read(SIZE_UINT64)
        self.p_align = bin.read(SIZE_UINT64)

        self.flags = int.from_bytes(self.p_flags, 'little')
        
        self.file_offset = int.from_bytes(self.p_offset, 'little')
        self.file_size = int.from_bytes(self.p_filesz, 'little')

        self.vaddr_offset = int.from_bytes(self.p_vaddr, 'little')
