from typing import Dict, Generator, List, Tuple
from parsebin import *
from capstone import *

# NOTE: this file (currently) only implements functionality for x86_64 ELF files
# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# class that stores any kind of entity that can have a value
# eg. stack bytes, registers, register value "snapshot" at some point of execution, and so on
# the design choice of using such an ambiguous class 
# is based on the fact that the implementation is way easier to understand, to extend, or to modify
# compared to the situation in which every use case of this class would get its own class
class _structured_element:

    # dictionary of currently used structured elements types
    # {"ELEMENT_TYPE": [info param 1 type, ...]}
    # NOTE: the fields described here only represent the keys of the self.info dict
    #       populating it with the corresponding (valid) values is the programmer's responsability
    ELEMENT_TYPES = {"val": ["id", "value"],            # an integer value
                        "64b_stack_val": ["val"],       # integer value from the stack
                        "ct_val": ["val"],              # integer constant (non-stack / non-register) value

                        "reg_in": ["reg_name"],         # register value at the beginning of a gadget / chain
                        "reg_out": ["reg_name"],        # register value after executing a gadget / chain

                        "add_ct": ["ct_val"],           # operations with ct_val (non-register values)
                        "sub_ct": ["ct_val"],           
                        "and_ct": ["ct_val"],
                        "or_ct": ["ct_val"],
                        "xor_ct": ["ct_val"],
                        "neg": [],

                        "add_reg": ["reg_in"],          # operations with (other) registers (given as input to the gadget / chain)
                        "sub_reg": ["reg_in"],
                        "and_reg": ["reg_in"],
                        "or_reg": ["reg_in"],
                        "xor_reg": ["reg_in"],
                        
                        "add_expr": [],                 # recursive operations on other elements
                        "sub_expr": [],                 # the self.info dict keys are not specified here  
                        "and_expr": [],
                        "or_expr": [],
                        "xor_expr": [],
                    }

    @staticmethod
    def _instantiate_structured_element(element_type: str):

        if element_type not in _structured_element.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _structured_element with type {element_type}")
        
        element = _structured_element(element_type)
        for info_field in _structured_element.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

# class to simulate the real stack on which a gadget or chain is executed
# the self.elements list must contain _structured_element objects
class _64b_stack_view:

    def __init__(self):
        self.elements: List[_structured_element] = []

    def push(self, element: _structured_element):
        self.elements.append(element)

# class to store the semantics of all the gadgets
# again, some ambiguity is intentionally provided, for same reasoning as the above mentioned classes
# but it has some constrains:
#   * every effect has an id that should be part of an implementation convention
#   * the effect, if seen as an operation, stores the result value in a single destination element (currently, by convention, only registers)
class _effect:

    # dictionary of currently used effect types
    # {"EFFECT_TYPE": (destination_element type, [param1 type, ...]), ...}
    # NOTE: ARITH type has parameter type configurable: "<op>_<ct/reg>" or "neg"
    EFFECT_TYPES = {"LOAD_S": ("reg_out", ["64b_stack_val"]),       # load value in register from the stack (RSP value increase NOT included)
                    "LOAD_CT": ("reg_out", ["ct_val"]),             # load value that is constant (that does not originate from registers or stack)
                    "MOV_RR": ("reg_out", ["reg_in"]),              # copying value from one register to another
                    "ARITH": ("reg_out", []),                       # operations (add, sub, bitewise operations, etc) - the PARAMS are not included
                    "ALTERED_REG": ("reg_out", []),                 # marks the fact that the register contained in the destination has been altered
                                                                    # but in an unspecified way, 
                                                                    # TODO: decide whether a chain / gadget can be chained with current one 
                                                                    # when containing this effect on input registers from the next gadget / chain
                    "NO_OP": (None, [])                             # no operation
                    }

    @staticmethod
    def _instantiate_effect(effect_type: str):
     
        if effect_type not in _effect.EFFECT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _effect with type {effect_type}")

        effect = _effect(effect_type, None, [])

        dest_type, param_type_list = _effect.EFFECT_TYPES[effect_type]

        if dest_type is not None:
            effect.destination_element = _structured_element._instantiate_structured_element(dest_type)
        
        for param_type in param_type_list:
            effect.params.append(_structured_element._instantiate_structured_element(param_type))

        return effect

    def __init__(self, effect_type: str, destination_element: _structured_element, params: List[_structured_element]):

        self.id: str = effect_type
        self.destination_element: _structured_element = destination_element
        self.params: List[_structured_element] = params

    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    @staticmethod
    def _analyse_instr(instr: CsInsn):
        
        # thunk to check whether a string is a number in base 10 or 16, and, if true, to return it
        def _is_int(to_check: str):
            
            failed_conversion = 0
            int_conversion = 0

            try:
                int_conversion = int(to_check, 10)
            except Exception:
                failed_conversion += 1

            if failed_conversion == 1:
                try:
                    int_conversion = int(to_check, 16)
                except Exception:
                    failed_conversion += 1

            if failed_conversion == 2:
                return None

            return int_conversion
        
        # RSP not included, treated only in some particular cases
        SUPPORTED_REGS = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp",
                            "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]

        try:

            instr_effects = []

            mnemonic = instr.mnemonic

            if mnemonic == "pop" and instr.op_str in SUPPORTED_REGS:

                load_s_effect = _effect._instantiate_effect("LOAD_S")
                load_s_effect.destination_element.info["reg_name"] = instr.op_str
                load_s_effect.params[0].info["val"] = _structured_element._instantiate_structured_element("val")
                load_s_effect.params[0].info["val"].info["id"] = 0   # CURRENTLY UNUSED
                
                add_rsp_effect = _effect._instantiate_effect("ARITH")
                add_rsp_effect.destination_element.info["reg_name"] = "rsp"
                add_rsp_effect.params.append(_structured_element._instantiate_structured_element("add_ct"))
                add_rsp_effect.params[0].info["ct_val"] = _structured_element._instantiate_structured_element("ct_val")
                add_rsp_effect.params[0].info["ct_val"].info["value"] = 8

                instr_effects.append(load_s_effect)
                instr_effects.append(add_rsp_effect)

            elif mnemonic == "mov":
                
                mov_args = instr.op_str.split(",")
                
                if len(mov_args) != 2:
                    return None

                dest = mov_args[0].strip()
                src = mov_args[1].strip()

                if dest not in SUPPORTED_REGS:
                    return None

                # TODO: add mov r, rsp support
                # TODO: test mov reg, QWORD PTR [rsp] support
                # TODO: add 32b / 16b registers support (at least for some cases)

                if src not in SUPPORTED_REGS:

                    int_src = _is_int(src)

                    if int_src is None:
                        
                        if src == "QWORD PTR [rsp]":
                            
                            load_s_effect = _effect._instantiate_effect("LOAD_S")
                            load_s_effect.destination_element.info["reg_name"] = instr.op_str
                            load_s_effect.params[0].info["val"] = _structured_element._instantiate_structured_element("val")
                            load_s_effect.params[0].info["val"].info["id"] = 0   # CURRENTLY UNUSED

                            instr_effects.append(load_s_effect)

                        else:
                            return None

                    else:

                        load_ct_effect = _effect._instantiate_effect("LOAD_CT")
                        load_ct_effect.destination_element.info["reg_name"] = dest
                        load_ct_effect.params[0].info["val"] = _structured_element._instantiate_structured_element("val")
                        load_ct_effect.params[0].info["val"].info["value"] = int_src
                        load_ct_effect.params[0].info["val"].info["id"] = 0   # CURRENTLY UNUSED

                        # add found constant in the global set of found constants
                        _existent_constants.add(int_src)

                        instr_effects.append(load_ct_effect)

                else:
                    
                    mov_rr_effect = _effect._instantiate_effect("MOV_RR")
                    mov_rr_effect.destination_element.info["reg_name"] = dest
                    mov_rr_effect.params[0].info["reg_name"] = src

                    instr_effects.append(mov_rr_effect)

            elif mnemonic == "xchg":
                pass

            else:
                return None

            return instr_effects          

        except Exception:
            return None

# gadget class that has associated a stack view and its effects (currently, operating on registers and/or stack popping)
class ROP_gadget:

    def __init__(self):

        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # this method is also responsible to pupulate the _effects_to_gadgets dictionary
    # TODO: check if Generator type hint behaves as predicted
    # TODO: rest of functionality !!!
    @staticmethod
    def _create_gadget(instr_generator: Generator[CsInsn, None, None], b_instr: bytes):
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag(instr: CsInsn, b_instr: bytes):
            return (len(b_instr) > 20)
        
        candidate_gadget = ROP_gadget()

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[_effect]] = []

        #print("new gadget:")
        for instr in instr_generator:

            instr_effects = _effect._analyse_instr(instr)
            if instr_effects is None:
                return None, _send_stop_flag(instr, b_instr)

            effects_per_instruction.append(instr_effects)

        # TODO: add in effects_to_gadgets dict before return
        return candidate_gadget, _send_stop_flag(None, b_instr)

# dictionary to map effect types to gadgets or chains, for ease of access
_effects_to_gadgets = {}

# retain the constants found during instruction analysis
# for optimising (yet to be implemented) automatic rop chain generator
_existent_constants = set()

# !!!!! currently unsure what this will be !!!!
# retain all the structured element values wrapped in stack elements
_stack_values = {}

# class to store more conveniently an (ordered) list of gadgets
# it also (redundantly) stores the whole stack view and the cummulated effects
# to be easier / faster to query for its properties
class ROP_chain:

    def __init__(self):

        self.gadgets: List[ROP_gadget] = []
        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

# main class, the "entry point" in using the functionalities implemented in this file
# it only implements a tiny fraction of the functionality the ROP concept can provide
# but it should be easy to extend at any time
class ROP_util:

    # all possible endpoints for a gadget
    # that transfer control to another gadget
    ENDPOINTS = { b'\xc3': "ret", b'\xff\xe0': "jmp rax", b'\xff\xe3': "jmp rbx", b'\xff\xe1': "jmp rcx", 
                    b'\xff\xe2': "jmp rdx", b'\xff\xe5': "jmp rbp", b'\xff\xe6': "jmp rsi", b'\xff\xe7': "jmp rdi", 
                    b'\x41\xff\xe0': "jmp r8", b'\x41\xff\xe1': "jmp r9", b'\x41\xff\xe2': "jmp r10", b'\x41\xff\xe3': "jmp r11", 
                    b'\x41\xff\xe4': "jmp r12", b'\x41\xff\xe5': "jmp r13", b'\x41\xff\xe6': "jmp r14", b'\x41\xff\xe7': "jmp r15" }

    def __init__(self, filepath: str):

        self.bin_handle = Elf_util(filepath)
        self.exec_bytes = self.bin_handle.load_x_bytes()

        self.capstone = Cs(CS_ARCH_X86, CS_MODE_64)

        self.bin_handle = None

        self.ret_gadgets = None
        self.ret_offsets = None
        self.endpoints_offsets = None

    def find_endpoints_offsets(self) -> List[Tuple[int, int]]:

        if self.endpoints_offsets is None:

            self.endpoints_offsets = []
            
            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] in ROP_util.ENDPOINTS.keys():
                        self.endpoints_offsets.append((i, xc_offset + ib))
                        

        return self.endpoints_offsets

    def find_ret_offsets(self) -> List[Tuple[int, int]]:

        if self.ret_offsets is None:

            self.ret_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] == b'\xc3':
                        self.ret_offsets.append((i, xc_offset + ib))

        return self.ret_offsets

    def find_ret_gadgets(self):

        if self.ret_gadgets is None:
            
            self.ret_gadgets = []

            ret_offsets = self.find_ret_offsets()
            for xc_index, ret_offset in ret_offsets:
                
                neg_offset = 1
                while True:
                    
                    b_vaddr = self.exec_bytes[xc_index][0]
                    b_instr = self.exec_bytes[xc_index][1][ret_offset - neg_offset - b_vaddr: ret_offset - b_vaddr]
                    
                    stop = False

                    disas_instr_generator = self.capstone.disasm(b_instr, b_vaddr)

                    g, stop = ROP_gadget._create_gadget(disas_instr_generator, b_instr)
                    if g is not None:
                        self.ret_gadgets.append(g)
                    
                    if stop is True:
                        break
                        
                    neg_offset += 1

            return self.ret_gadgets

r = ROP_util("app")    
#r = ROP_util("/usr/lib/x86_64-linux-gnu/libc-2.31.so")

os = r.find_ret_gadgets()



