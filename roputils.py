from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from rand import random
from utils import _is_int
from logger import Logger

from rop_platform import Platform
from stackview import Stack_view
from structured_element import Structured_element
from effect import Effect

from roputils_x86_64 import *
from roputils_arm64 import *

from capstone import *
# import z3

class ROP_util:
    """main class for creating a ROP payload
        how to create a payload:
        TODO"""

    def __init__(self, filepath: str, platform: Platform, session_name = "ROP_util", print_log = True):
        '''
        initialize a ROP_util object
            * filepath: str -> file path for the binary to be analysed (only ONE binary at a time supported)
            * platform = Platform.X86_64 | Platform.ARM64 -> platform of the binary
            * session_name: str -> strictly for log output, does NOT influence in any way the logic itself
            * print_log: bool -> whether to print the log output, does NOT influence in any way the logic itself
        '''

        self.platform = platform
        self.filepath = filepath

        self.rop_searcher: ROP_searcher_ARM64 | ROP_searcher_x86_64
        '''internal variable, the platform-dependent rop searcher'''

        self.structured_element: type
        '''internal variable, the type for the structured element internal representation'''

        self.effect: type
        '''internal variable, the type for the effect internal representation'''
        
        if self.platform is Platform.X86_64:

            self.rop_searcher = ROP_searcher_x86_64(filepath)
            self.structured_element = Structured_element
            self.effect = Effect

        elif self.platform is Platform.ARM64:

            self.rop_searcher = ROP_searcher_ARM64(filepath)
            self.structured_element = Structured_element_ARM64
            self.effect = Effect_ARM64

        else:
            raise RuntimeError(f"Requested platform {platform} unknown or not supported")

        self.logger = Logger(session_name = session_name, print_log = print_log)
        '''the logger'''

    def scout_for_gadgets(self, scout_mode: str = 'fast') -> None:
        '''
        main method that needs to be called BEFORE any actual search
            it needs to be executed only ONCE, after ROP_util object initialization
            * scout_mode = 'fast' | 'complete', ONLY for ARM64 (ignored on x86_64)
            * FAST mode preforms limited preprocessing, with shorter runtime,
                    but sacrifices some limited types of gadgets / chains 
                    that might be possible to construct
            * COMPLETE mode is considerably slower than FAST mode,
                        but might detect a few more types of gadgets\n
            example of runtime differences: FAST ~70 seconds, COMPLETE ~650 seconds
            NOTE: COMPLETE mode does NOT exhaust all options
        '''

        if scout_mode not in ['fast', 'complete']:
            raise RuntimeError(f'Unknown preprocessing mode: {scout_mode} (should be \'fast\' or \'complete\')')

        _t = self.logger.log_info(f"Analysing the binary {self.filepath} ...", start_timer = True)

        self.rop_searcher.find_gadgets()

        if self.platform is Platform.ARM64:

            self.logger.log_success("Done collecting gadgets.", end_timer = _t)
            _t = self.logger.log_info("Trying to validate jumps and stack accesses ...", start_timer = True)
            
            self.rop_searcher.validate_raw_gadgets(q0 = 3, q1 = 3)

            self.logger.log_success("Done validating gadgets.", end_timer = _t)
            
            if scout_mode == 'complete':

                _t = self.logger.log_info(f"({scout_mode} preprocessing mode) Additional preprocessing ...", start_timer = True)
                self.rop_searcher._search_arith_to_mov(q = 10)

        self.logger.log_success(f"Done analysing the binary {self.filepath}", end_timer = _t)

    def _parse_input(self, wanted_effects_raw: str, reg_start_values_raw: str) -> Tuple[List[Effect], List[Effect]]:
        '''internal method that parses some of the input for the self.search_chain() method'''

        def _parse_expr(raw: str) -> Structured_element:

            # reg
            if raw in self.platform.SUPPORTED_REGS:

                el = self.structured_element.instantiate_structured_element("reg_in")
                el.info["reg_name"] = raw

                return el

            # value
            ct = _is_int(raw)
            if ct is not None:

                el = self.structured_element.instantiate_structured_element("ct_val")
                el.info["value"] = ct

                return el

            # negation
            if raw[0] == "!":

                to_negate = _parse_expr(raw[1:].strip())

                el = self.structured_element.instantiate_structured_element("neg")
                el.info["term_1"] = to_negate

                return el           

            # binary operations and paranthesis     

            if self.platform is Platform.X86_64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor"}

            elif self.platform is Platform.ARM64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor", 
                            "<<": "lsh", ">>": "rsh", "*": "mul"}

            open_paranthesis = 0

            op = None
            left_operand_raw = None
            right_operand_raw = None

            for i in range(len(raw)):
                c = raw[i]

                if c == "(":
                    open_paranthesis += 1

                elif c == ")":
                    open_paranthesis -= 1

                elif (open_paranthesis == 0) and (c in bin_ops.keys()):
                    
                    op = c
                    left_operand_raw, right_operand_raw = raw[:i].strip(), raw[i + 1:].strip()
                    break
            
            if op is not None:
                
                el = self.structured_element.instantiate_structured_element(bin_ops[op])
                el.info["term_1"] = _parse_expr(left_operand_raw)
                el.info["term_2"] = _parse_expr(right_operand_raw)

                return el

            elif open_paranthesis == 0 and raw[0] == "(" and raw[-1] == ")":
                return _parse_expr(raw[1:-1].strip())

            raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")

        def _parse_effect(raw: str, split_s = "="):
            
            dest_reg, raw_assign = raw.split(split_s)
            dest_reg = dest_reg.strip()
            raw_assign = raw_assign.strip()

            if dest_reg not in self.platform.SUPPORTED_REGS:
                raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")
            
            wef = None
            wef_param = _parse_expr(raw_assign)

            if wef_param.type == "ct_val":
                wef = self.effect.make_load_ct_effect(dest_reg, wef_param.info["value"])

            elif wef_param.type == "reg_in":
                wef = self.effect.make_mov_rr_effect(dest_reg, wef_param.info["reg_name"])

            elif wef_param.is_op():
                wef = self.effect.make_arith_custom_effect(dest_reg, wef_param)

            return wef

        wefs: List[Effect] = []
        start_values: List[Effect] = []

        raw_wefs = wanted_effects_raw.split(",")
        for raw_wef in raw_wefs:
            wefs.append(_parse_effect(raw_wef.strip(), split_s = "="))

        if "==" in reg_start_values_raw:
            raw_rsvs = reg_start_values_raw.split(",")
            for raw_rsv in raw_rsvs:
                start_values.append(_parse_effect(raw_rsv.strip(), split_s = "=="))

        return wefs, start_values

    def search_chain(self, wanted_effects: str, fixed_regs: List[str] = [], reg_start_values: str = '', 
                        max_stack_byte_size: int = 160, max_search_cnt: int = 3, only_gadgets = False) -> Generator[ROP_chain_x86_64 | ROP_chain_ARM64]:
        '''
        main search method\n
            it is a GENERATOR, not a function\n
            search a chain with different properties:

            * wanted_effects: str -> specify in string format the wanted effects (TODO add fomat doc)

            * fixed_regs: List[str] -> specify the registers that should have the same 
                                        value when exiting the chain as before entering the chain

            * reg_start_values: str -> specify in string format the values the registers have at the beginning;
                                        for example, 'rax == rax + 0x10' means the rax value from the right member
                                        is considered the 'original' value of rax, and the effective value of
                                        rax ragister when entering the chain (the value from the left member)
                                        is equal to the original rax value plus 0x10; in the same case, if the
                                        wanted effect is 'rbx = rax' it means at the end of the chain,
                                        rbx will have the ORIGINAL rax value, which, because of the rax start value
                                        from above, the rbx register value will have the rax value at the beginning
                                        of the chain MINUS 0x10
                                        in other words, for this example, the following identity holds:
                                        (output) rbx == (original) rax == (rax at the beginning) - 0x10
                                        NOTE that while in some examples (such as this one) the semantics of searching
                                            for [wanted effect: 'rbx = rax', start value: 'rax == rax + 0x10']
                                            might appear the same as for [wanted effect: 'rbx = rax - 0x10', start value: ''] 
                                            the SECOND approach (the one with no start value) will almost always be more efficient
                                            and have a considerably bigger chance of finding a chain, due to the way in which
                                            the algorithms are implemented
                                            
            * max_stack_byte_size: int -> specify the maximum size the payload corresponding to this chain can have
            
            * max_search_cnt: int -> maximum number of chains that will be yielded from this generator
                                        (smaller values for this param might speed up the search in some cases)
                                        if the byte values in the chain addresses or payload might be a problem
                                        you might want to choose a value > 1, otherwise 1 is a good choice
                                        
            * only_gadgets: bool -> restrict the search only to inidividual gadgets (i.e. no chain is built 
                                    even if it would saatisfy the wanted effects)
        '''

        _t = self.logger.log_info(f"Searching for chains in {self.filepath}...", start_timer = True)
        
        wanted_effects, reg_start_values = self._parse_input(wanted_effects, reg_start_values)
        max_stack_size = max_stack_byte_size // 8

        found_cnt = 0
        
        for ch in self.rop_searcher.search_chain(wanted_effects = wanted_effects, max_stack_size = max_stack_size,
                                                fixed_reg_list = fixed_regs, reg_start_values = reg_start_values, only_gadgets = only_gadgets):
            yield ch

            found_cnt += 1
            if found_cnt == max_search_cnt:

                self.logger.log_success(f"Done searching for chains in {self.filepath}", end_timer = _t)
                return

        self.logger.log_warning(f"Could not find requested chains in {self.filepath}", end_timer = _t)

    def disable_bruteforce(self) -> None:
        '''disable bruteforce search\n
            equivalent with self.enable_bruteforce(0)'''
        self.rop_searcher.BRUTEFORCE_DEPTH = 0

    def enable_bruteforce(self, chain_g_depth = 2) -> None:
        '''enable bruteforce when searching for chains\n
            chain_g_depth -> max number of gadgets to form a chain (distinct or not)'''
        self.rop_searcher.BRUTEFORCE_DEPTH = chain_g_depth

    def make_payload(self) -> ROP_payload_x86_64 | ROP_payload_ARM64:
        '''
        returns a payload object\n
            NOTE: it does NOT return payload bytes\n
            to build a payload:
            * call this method to get a payload object
            * add the content to the payload object via its methods
            * build the payload object with payload.build() method which returns bytes
        '''

        if self.platform is Platform.X86_64:
            return ROP_payload_x86_64(self.rop_searcher)

        elif self.platform is Platform.ARM64:
            return ROP_payload_ARM64(self.rop_searcher)

    def show_gadgets(self) -> None:
        '''show all gadgets'''

        self.logger.log_success(f"found {len(self.rop_searcher.gadgets)} gadgets:\n")
        for g in self.rop_searcher.gadgets:
            g.show()
            print('\n')

    def use_z3(self, use_z3: bool = True) -> None:
        '''decide whether to use Z3 or not\n
            default is True'''
        self.platform.use_z3 = use_z3
