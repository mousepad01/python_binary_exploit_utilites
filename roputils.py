from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from utils import _is_int
from logger import Logger

from rop_platform import Platform, x86_64, arm64
from stackview import Stack_view
from structured_element import Structured_element
from effect import Effect

from roputils_algs import *

from capstone import *

class ROP_util:
    """
        Main class for searching a binary for chains, and build the payload\n
        Fast usage:
        * initialize a ROP_util object, giving the file path and the platform (x86_64 or arm64)
        * search a specific chain with search_chain() method, specifying the wanted effects as a string
        * get the payload bytes with build_payload() method\n
        For a more detailed explanation, check the documentation
    """

    def __init__(self, filepath: str, platform: Platform, scout: bool = True, session_name = "ROP_util", print_log = True, log_fd = stdout):
        '''
            initialize a ROP_util object
            * filepath: str -> file path for the binary to be analysed (only ONE binary at a time supported)
            * platform = Platform.X86_64 | Platform.ARM64 -> platform of the binary
            * scout: bool -> if true, automatically executes the preprocessing phase; if it is false,
                    it must manually be called with scout_for_gadgets()
            * session_name: str -> strictly for log output, does NOT influence in any way the algorithms
            * print_log: bool -> whether to print the log output, does NOT influence in any way the algorithms
            * log_filepath: TextIO -> file where to print the log; stdout by default; does NOT influence in any way the algorithms
        '''

        if platform not in [Platform.X86_64, Platform.ARM64]:
            raise RuntimeError(f"Requested platform {platform} unknown or not supported")

        self.platform = platform
        self.filepath = filepath

        self.logger = Logger(session_name = session_name, print_log = print_log, output_handle = log_fd)
        '''The logger'''

        self.rop_searcher = ROP_searcher(filepath = self.filepath, platform = self.platform, logger = self.logger)
        '''Internal rop searcher\n
            It implements the search algorithms'''

        self.preprocessed = False
        '''
            Whether the preprocessing phase was executed or not (i.e. scout_for_gadgets() was called or not)
        '''

        if scout is True:
            self.scout_for_gadgets(scout_mode = 'fast', show_stats = False)

    def scout_for_gadgets(self, scout_mode: str = 'fast', show_stats: bool = False) -> None:
        '''
            Call this before any actual search
            it needs to be executed only ONCE, after ROP_util object initialization
            * scout_mode = 'fast' | 'complete'
            * FAST mode preforms limited preprocessing, with shorter runtime,
                    but sacrifices some limited types of gadgets / chains 
                    that might be possible to construct
            * COMPLETE mode is considerably slower than FAST mode,
                        but might detect a few more types of gadgets
                        (this mode executes the 'ARITH to MOV_RR' feature presented
                        in the documentation)\n
            example of runtime differences: FAST ~70 seconds, COMPLETE ~650 seconds
            NOTE: COMPLETE mode does NOT exhaust all options
            * show_stats -> show stats at the end of this phase or not; default is False
        '''

        if scout_mode not in ['fast', 'complete']:
            raise RuntimeError(f'Unknown preprocessing mode: {scout_mode} (should be \'fast\' or \'complete\')')

        _t = self.logger.log_info(f"Analysing the binary {self.filepath} (might take seconds)...", start_timer = True)
        self.rop_searcher.scout_gadgets()
        self.logger.log_success(f"Done collecting gadgets.", end_timer = _t)

        _t = self.logger.log_info(f"Trying to validate jumps and stack accesses (might take minutes)...", start_timer = True)
        self.rop_searcher.validate_raw_gadgets(q0 = 3, q1 = 3)
        self.logger.log_success(f"Done validating gadgets.", end_timer = _t)
        
        if scout_mode == 'complete':

            _t = self.logger.log_info(f"({scout_mode} preprocessing mode) Additional preprocessing (might take minutes)...", start_timer = True)
            self.rop_searcher.search_arith_to_mov(q = 10)

        self.logger.log_success(f"Done analysing the binary {self.filepath}", end_timer = _t)
        
        self.preprocessed = True
        if show_stats is True:
            self.stats()

    def _parse_input(self, wanted_effects_raw: str, reg_start_values_raw: str) -> Tuple[List[Effect], List[Effect]]:
        '''internal method that parses some of the input for the self.search_chain() method'''

        def _parse_expr(raw: str) -> Structured_element:

            # reg
            if raw in self.platform.SUPPORTED_REGS:

                el = Structured_element.instantiate_structured_element("reg_in")
                el.info["reg_name"] = raw

                return el

            # value
            ct = _is_int(raw)
            if ct is not None:

                el = Structured_element.instantiate_structured_element("ct_val")
                el.info["value"] = ct % (2 ** 64)

                return el

            # negation
            if raw[0] == "!":

                to_negate = _parse_expr(raw[1:].strip())

                el = Structured_element.instantiate_structured_element("neg")
                el.info["term_1"] = to_negate

                return el           

            # binary operations and paranthesis     

            if self.platform is Platform.X86_64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor"}

            elif self.platform is Platform.ARM64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor", 
                            "<<": "lsh", ">>": "rsh", "*": "mul"}

            open_paranthesis = 0

            op = None
            left_operand_raw = None
            right_operand_raw = None

            for i in range(len(raw)):
                c = raw[i]

                if c == "(":
                    open_paranthesis += 1

                elif c == ")":
                    open_paranthesis -= 1

                elif (open_paranthesis == 0) and (c in bin_ops.keys()):
                    
                    op = c
                    left_operand_raw, right_operand_raw = raw[:i].strip(), raw[i + 1:].strip()
                    break
            
            if op is not None:
                
                el = Structured_element.instantiate_structured_element(bin_ops[op])
                el.info["term_1"] = _parse_expr(left_operand_raw)
                el.info["term_2"] = _parse_expr(right_operand_raw)

                return el

            elif open_paranthesis == 0 and raw[0] == "(" and raw[-1] == ")":
                return _parse_expr(raw[1:-1].strip())

            raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")

        def _parse_effect(raw: str):
            
            dest_reg, raw_assign = raw.split("=")
            dest_reg = dest_reg.strip()
            raw_assign = raw_assign.strip()

            if dest_reg not in self.platform.SUPPORTED_REGS:
                raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")
            
            wef = None
            wef_param = _parse_expr(raw_assign)

            if wef_param.type == "ct_val":
                wef = Effect.make_load_ct_effect(dest_reg, wef_param.info["value"])

            elif wef_param.type == "reg_in":
                wef = Effect.make_mov_rr_effect(dest_reg, wef_param.info["reg_name"])

            elif wef_param.is_op():
                wef = Effect.make_arith_custom_effect(dest_reg, wef_param)

            return wef

        wefs: List[Effect] = []
        start_values: List[Effect] = []

        raw_wefs = wanted_effects_raw.split(",")
        for raw_wef in raw_wefs:
            wefs.append(_parse_effect(raw_wef.strip()))

        if "=" in reg_start_values_raw:
            raw_rsvs = reg_start_values_raw.split(",")
            for raw_rsv in raw_rsvs:
                start_values.append(_parse_effect(raw_rsv.strip()))

        return wefs, start_values

    def search_chain(self, wanted_effects: str, fixed_regs: List[str] = [], reg_start_values: str = '', 
                        max_stack_byte_size: int = 2**63, max_search_cnt: int = 1, only_gadgets = False) -> Generator[ROP_chain]:
        '''
        main search method\n
            it is a GENERATOR, not a function\n
            search a chain with different properties:

            * wanted_effects: str -> specify in string format the wanted effects (check the doc section 'Search input parsing')

            * fixed_regs: List[str] -> specify the registers that should have the same 
                                        value when exiting the chain as before entering the chain

            * reg_start_values: str -> specify in string format the values the registers have at the beginning;
                                        for example, 'rax == rax + 0x10' means the rax value from the right member
                                        is considered the 'original' value of rax, and the effective value of
                                        rax ragister when entering the chain (the value from the left member)
                                        is equal to the original rax value plus 0x10; in the same case, if the
                                        wanted effect is 'rbx = rax' it means at the end of the chain,
                                        rbx will have the ORIGINAL rax value, which, because of the rax start value
                                        from above, the rbx register value will have the rax value at the beginning
                                        of the chain MINUS 0x10
                                        in other words, for this example, the following identity holds:
                                        (output) rbx == (original) rax == (rax at the beginning) - 0x10
                                        NOTE that while in some examples (such as this one) the semantics of searching
                                            for [wanted effect: 'rbx = rax', start value: 'rax == rax + 0x10']
                                            might appear the same as for [wanted effect: 'rbx = rax - 0x10', start value: ''] 
                                            the SECOND approach (the one with no start value) will almost always be more efficient
                                            and have a considerably bigger chance of finding a chain, due to the way in which
                                            the algorithms are implemented
                                            
            * max_stack_byte_size: int -> specify the maximum size the payload corresponding to this chain can have
            
            * max_search_cnt: int -> maximum number of chains that will be yielded from this generator
                                        (smaller values for this param might speed up the search in some cases)
                                        if the byte values in the chain addresses or payload might be a problem
                                        you might want to choose a value > 1, otherwise 1 is a good choice
                                        
            * only_gadgets: bool -> restrict the search only to inidividual gadgets (i.e. no chain is built 
                                    even if it would saatisfy the wanted effects)
        '''

        _t = self.logger.log_info(f"Searching for chains in {self.filepath}...", start_timer = True)

        ''' 
            !!! ARM64 observation !!! 
            x30 should not be part of wanted effects due to inconsistencies that appear when using it for jumping:
            the implementation does NOT take into account the fact that its value is changed when executing blr instructions
            because of that, when searching for wanted effects containing x30, it might return wrong results
            the current approach (trick) is to *temporarily* remove x30 from Platform.ARM64.SUPPORTED_REGS list
            while the wanted effects are parsed, then add it back again
        '''
        Platform.ARM64.SUPPORTED_REGS.remove("x30")
        Platform.ARM64.SUPPORTED_EXTENDED_REGS.remove("x30")
        
        wanted_effects, reg_start_values = self._parse_input(wanted_effects, reg_start_values)
        max_stack_size = max_stack_byte_size // 8

        Platform.ARM64.SUPPORTED_REGS.append("x30")
        Platform.ARM64.SUPPORTED_EXTENDED_REGS.append("x30")

        found_cnt = 0
        
        for ch in self.rop_searcher.search_chain(wanted_effects = wanted_effects, max_stack_size = max_stack_size,
                                                fixed_reg_list = fixed_regs, reg_start_values = reg_start_values, only_gadgets = only_gadgets):
            yield ch

            found_cnt += 1
            if found_cnt == max_search_cnt:

                self.logger.log_success(f"Done searching for chains in {self.filepath}", end_timer = _t)
                return

        self.logger.log_warning(f"Could not find requested chains in {self.filepath}", end_timer = _t)

    def disable_bruteforce(self) -> None:
        '''
            Disable bruteforce search (disabled by default)\n
            equivalent with self.enable_bruteforce(0)\n
        '''
        self.rop_searcher.bruteforce_depth = 0

    def enable_bruteforce(self, chain_g_depth = 2) -> None:
        '''
            Enable bruteforce search, with specified depth (disabled by default)\n
            chain_g_depth -> max number of gadgets to form a chain (distinct or not)
        '''
        self.rop_searcher.bruteforce_depth = chain_g_depth

    def build_payload(self, chain_list: List[ROP_chain], exit_address: int, address_offset: int = 0,
                        alignment_on_entry: int = None, alignment_on_exit: int = None) -> bytes:
        '''
            Build a payload\n
            Arguments:
            * chain_list -> an ordered list of chains to be chained and transformed in payload bytes
            * exit_address -> the address where the last chain will return (jump) - ASLR offset must be manually added to this value
            * address_offset -> add this offset to all gadget addresses inside the chains from chain_list
            * (x86_64 only) alignment_on_entry -> if specified, indicates the alignment of the stack pointer 
                                                    when entering the (first) chain - default 8 bytes
            * (x86_64 only) alignment_on_exit -> if specified, in conjunction with alignment_on_entry, will use a ret-only gadget 
                                                    to align the stack pointer before exiting the chain\n
            NOTE: on arm64, the stack pointer is always 16 byte aligned, considering the alignment on entry is 0
        '''
        return self.rop_searcher.build_payload(chain_list = chain_list, exit_address = exit_address, address_offset = address_offset,
                                                alignment_on_entry = alignment_on_entry, alignment_on_exit = alignment_on_exit)

    def show_gadgets(self) -> None:
        '''show all gadgets'''

        self.logger.log_success(f"found {len(self.rop_searcher.gadgets)} gadgets:\n")
        for g in self.rop_searcher.gadgets:
            g.show(capstone_handle = self.rop_searcher.capstone)
            print('\n')

    def use_z3(self, use_z3: bool = True) -> None:
        '''
            Decide whether to use Z3 or not (default is True)
        '''
        Effect.USE_Z3 = use_z3

    def stats(self):
        '''
            Print some stats:
            * the gadget distribution w.r.t. 
                the effects it contains and their destination register
            * post-validation stats
        '''
        self.rop_searcher.gadget_distribution_stats()
        self.rop_searcher.validation_stats()
