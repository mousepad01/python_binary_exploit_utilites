from __future__ import annotations
from typing import Dict, Generator, List, Tuple
# both above imports only for type hints

from copy import deepcopy

from parsebin import *
from capstone import *

# NOTE: this file (currently) only implements functionality for x86_64 ELF files
# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# dictionary to map effect types to gadgets or chains, for ease of access
_effects_to_gadgets = {}

# retain the constants found during instruction analysis
# for optimising (yet to be implemented) automatic rop chain generator
_existent_constants = set()

# class that stores any kind of entity that can have a value
# eg. stack bytes, registers, register value "snapshot" at some point of execution, and so on
# the design choice of using such an ambiguous class 
# is based on the fact that the implementation is way easier to understand, to extend, or to modify
# compared to the situation in which every use case of this class would get its own class
class _structured_element:

    # dictionary of currently used structured elements types
    # {"ELEMENT_TYPE": [info param 1 type / info param 1 name, ...]}
    # NOTE: the fields described here only represent the keys of the self.info dict
    #       populating it with the corresponding (valid) values is the programmer's responsability
    ELEMENT_TYPES = {"64b_stack_val": ["id"],                                   # integer value from the stack, indicated by an id
                        "ct_val": ["value"],                                    # integer constant (non-stack / non-register) value

                        "reg_in": ["reg_name"],                                 # register value at the beginning of a gadget / chain
                        "reg_out": ["reg_name"],                                # register value after executing a gadget / chain
                        
                        "add": ["r_independent", "const"],                      # arithmetic operations (can be recursive)
                        "sub": ["r_independent", "const"],                      # the complete dict will have the keys: ["term_1", "term_2", "r_independent", "const"]
                        "and": ["r_independent", "const"],  
                        "or": ["r_independent", "const"],  
                        "xor": ["r_independent", "const"],  
                        "neg": ["r_independent", "const"],                      # for negation, term2 will always be None

                        "64b_stack_pad": []                                     # marks padding (random value) for the stack view
                    }

                    # NOTE: regarding arithmetic element information:
                    #
                    #   * r_independent (def)= a structuled element that does NOT contain 
                    #                           in its arithmetic operations recursion any element with type "reg_in" 
                    #
                    #   * const (def)= a structured element (that is also r_independent) that contains in its aritmetic
                    #                   operations recursion only elements of type "ct_val" and other const elements (no stack values)
                    #
                    # it can be observed that r_independent and const arithmetic elements can only be obtained by chaining instructions
                    # because every arithmetic operation given by a single instruction 
                    # has at least a "reg_in" operand - that is, the destination register's initial value, before the operation
    
    @staticmethod
    def instantiate_structured_element(element_type: str):

        if element_type not in _structured_element.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _structured_element with type {element_type}")
        
        element = _structured_element(element_type)
        for info_field in _structured_element.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

# class to simulate the real stack on which a gadget or chain is executed
# the self.elements list must contain _structured_element objects
class _64b_stack_view:

    # retain all the stack elements id's and their value
    # except THE RETURN ADDRESSES
    stack_values = {}

    # stack id to uniquely identify the (same) stack values
    # INCLUDING THE RETURN ADDRESSES
    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[_structured_element] = []

    def push(self, element: _structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = _64b_stack_view.stack_id_cnt

        _64b_stack_view.stack_id_cnt += 1
        _64b_stack_view.stack_values.update({to_deliver: None})
        
        return to_deliver

# class to store the semantics of all the gadgets
# again, some ambiguity is intentionally provided, for same reasoning as the above mentioned classes
# but it has some constrains:
#   * every effect has an id that should be part of an implementation convention
#   * the effect, if seen as an operation, stores the result value in a single destination element (currently, by convention, only registers)
class _effect:

    # dictionary of currently used effect types
    # {"EFFECT_TYPE": (destination_element type, [param1 type, ...]), ...}
    # NOTE: ARITH type has parameter type configurable: "<op>"
    EFFECT_TYPES = {"LOAD_S": ("reg_out", ["64b_stack_val"]),       # load value in register from the stack (RSP value increase NOT included)
                    "LOAD_CT": ("reg_out", ["ct_val"]),             # load value that is constant (that does not originate from registers or stack)
                    "MOV_RR": ("reg_out", ["reg_in"]),              # copying value from one register to another
                    "ARITH": ("reg_out", []),                       # operations (add, sub, bitewise operations, etc) - the PARAMS are not included
                    "ADD_RSP": (None, ["ct_val"]),                  # separate effect indicating incrementing RSP (with a constant value only)
                    # "ALTERED_REG": ("reg_out", []),                 # marks the fact that the register contained in the destination has been altered
                                                                    # but in an unspecified way, NOT YET USED
                                                                    # TODO: decide whether a chain / gadget can be chained with current one 
                                                                    # when containing this effect on input registers from the next gadget / chain
                    "NO_OP": (None, [])                             # no operation
                    }

    @staticmethod
    def instantiate_effect(effect_type: str):
     
        if effect_type not in _effect.EFFECT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _effect with type {effect_type}")

        effect = _effect(effect_type, None, [])

        dest_type, param_type_list = _effect.EFFECT_TYPES[effect_type]

        if dest_type is not None:
            effect.destination_element = _structured_element.instantiate_structured_element(dest_type)
        
        for param_type in param_type_list:
            effect.params.append(_structured_element.instantiate_structured_element(param_type))

        return effect

    # common code lines between any location (at least when interpreting instructions)
    # for creating an effect that marks an arithmetic operation with a constant
    # NOTE: no checks are done
    @staticmethod
    def make_arith_ct_effect(op_type: str, dest_reg_name: str, constant: int):

        arith_op_ct_effect = _effect.instantiate_effect("ARITH")
        arith_op_ct_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_ct_effect.params.append(_structured_element.instantiate_structured_element(op_type))
        arith_op_ct_effect.params[0].info["r_independent"] = False
        arith_op_ct_effect.params[0].info["const"] = False

        arith_op_ct_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_ct_effect.params[0].info.update({"term_2": _structured_element.instantiate_structured_element("ct_val")})
        arith_op_ct_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_ct_effect.params[0].info["term_2"].info["value"] = constant

        _existent_constants.add(constant)

        return arith_op_ct_effect

    # same as make_arith_ct_effect but for operations with (only) registers
    # NOTE: no checks are done
    @staticmethod
    def make_arith_reg_effect(op_type: str, dest_reg_name: str, src_reg_name: str):

        arith_op_reg_effect = _effect.instantiate_effect("ARITH")
        arith_op_reg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_reg_effect.params.append(_structured_element.instantiate_structured_element(op_type))
        arith_op_reg_effect.params[0].info["r_independent"] = False
        arith_op_reg_effect.params[0].info["const"] = False

        arith_op_reg_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_reg_effect.params[0].info.update({"term_2": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_reg_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_reg_effect.params[0].info["term_2"].info["reg_name"] = src_reg_name

        return arith_op_reg_effect

    @staticmethod
    def make_load_ct_effect(dest_reg_name: str, constant: int):

        load_ct_effect = _effect.instantiate_effect("LOAD_CT")
        load_ct_effect.destination_element.info["reg_name"] = dest_reg_name
        load_ct_effect.params[0].info["value"] = constant

        _existent_constants.add(constant)

        return load_ct_effect

    @staticmethod
    def make_load_s_effect(dest_reg_name: str):

        load_s_effect = _effect.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name
        load_s_effect.params[0].info["id"] = _64b_stack_view.get_elem_id()

        return load_s_effect

    @staticmethod
    def make_mov_rr_effect(dest_reg_name: str, src_reg_name: str):

        mov_rr_effect = _effect.instantiate_effect("MOV_RR")
        mov_rr_effect.destination_element.info["reg_name"] = dest_reg_name
        mov_rr_effect.params[0].info["reg_name"] = src_reg_name

        return mov_rr_effect

    @staticmethod
    def make_neg_effect(dest_reg_name: str):

        arith_neg_effect = _effect.instantiate_effect("ARITH")
        arith_neg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_neg_effect.params.append(_structured_element.instantiate_structured_element("neg"))
        arith_neg_effect.params[0].info["r_independent"] = False
        arith_neg_effect.params[0].info["const"] = False

        arith_neg_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_neg_effect.params[0].info.update({"term_2": None})
        arith_neg_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name

        return arith_neg_effect

    @staticmethod
    def make_add_rsp_effect(constant: int):

        add_rsp_effect = _effect.instantiate_effect("ADD_RSP")
        add_rsp_effect.params[0].info["value"] = constant

        # this constant is NOT added into known constants cache
        # because is limited in interacting only with RSP

        return add_rsp_effect

    def __init__(self, effect_type: str, destination_element: _structured_element, params: List[_structured_element]):

        self.type: str = effect_type
        self.destination_element: _structured_element = destination_element
        self.params: List[_structured_element] = params

    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    @staticmethod
    def analyse_instr(instr: CsInsn):
        
        # function to check whether a string is a number in base 10 or 16, and, if true, to return it
        def _is_int(to_check: str):
            
            failed_conversion = 0
            int_conversion = 0

            try:
                int_conversion = int(to_check, 10)
            except Exception:
                failed_conversion += 1

            if failed_conversion == 1:
                try:
                    int_conversion = int(to_check, 16)
                except Exception:
                    failed_conversion += 1

            if failed_conversion == 2:
                return None

            return int_conversion

        # separate the arguments from instr.op_str
        def _get_2_args(op_str: str):

            mov_args = op_str.split(",")
                
            if len(mov_args) != 2:
                return None, None

            dest = mov_args[0].strip()
            src = mov_args[1].strip()

            return dest, src

        # checks whether the instruction effects 
        # are ignored (from the point of view of this algorithm)
        # and are treated as NOP
        # TODO: ignore (most of) SSE/AVX operations
        def _ignored_instr(instr: CsInsn):

            # some ignored instructions
            IGNORED_INSTR_MNEMONICS = ["endbr64", "clc", "cld", "cldemote", "clflush", "clflushopt", 
                                        "cli", "clts", "clwb", "cmc", "fnop", "vzeroupper"]

            if instr.mnemonic in IGNORED_INSTR_MNEMONICS:
                return True

            return False

        # RSP not included, treated only in some particular cases
        SUPPORTED_REGS = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp",
                            "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]

        try:

            instr_effects = []

            mnemonic = instr.mnemonic

            if mnemonic == "pop":

                if instr.op_str not in SUPPORTED_REGS:
                    return None

                load_s_effect = _effect.make_load_s_effect(instr.op_str)
                add_rsp_effect = _effect.make_add_rsp_effect(8)

                instr_effects.append(load_s_effect)
                instr_effects.append(add_rsp_effect)

            elif mnemonic == "mov":
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in SUPPORTED_REGS:
                    return None

                # TODO: add mov r, rsp support
                # TODO: add 32b / 16b registers support (at least for some cases)

                if src not in SUPPORTED_REGS:

                    int_src = _is_int(src)
                    if int_src is None:
                        
                        if src == "qword ptr [rsp]":
                            load_s_effect = _effect.make_load_s_effect(instr.op_str)
                            instr_effects.append(load_s_effect)
                        else:
                            return None
                    else:
                        load_ct_effect = _effect.make_load_ct_effect(dest, int_src)
                        instr_effects.append(load_ct_effect)

                else:
                    mov_rr_effect = _effect.make_mov_rr_effect(dest, src)
                    instr_effects.append(mov_rr_effect)

            elif mnemonic == "xchg":

                r1, r2 = _get_2_args(instr.op_str)

                if (r1 not in SUPPORTED_REGS) or (r2 not in SUPPORTED_REGS):
                    return None

                if r1 == r2:

                    nop_effect = _effect.instantiate_effect("NO_OP")
                    instr_effects.append(nop_effect)

                else:
                
                    mov_rr_effect1 = _effect.make_mov_rr_effect(r1, r2)
                    mov_rr_effect2 = _effect.make_mov_rr_effect(r2, r1)

                    instr_effects.append(mov_rr_effect1)
                    instr_effects.append(mov_rr_effect2)

            elif mnemonic in ["add", "sub"]:

                dest, src = _get_2_args(instr.op_str)

                if (dest not in SUPPORTED_REGS) and (dest != "rsp"):
                    return None

                if dest == "rsp":

                    if mnemonic != "add":
                        return None

                    int_src = _is_int(src)

                    if (int_src is None) or (int_src % 8 != 0):
                        return None

                    add_rsp_effect = _effect.make_add_rsp_effect(int_src)
                    instr_effects.append(add_rsp_effect)

                elif src in SUPPORTED_REGS:
                    
                    arith_add_reg_effect = _effect.make_arith_reg_effect(mnemonic, dest, src)
                    instr_effects.append(arith_add_reg_effect)
                    
                else:
                    
                    int_src = _is_int(src)

                    if int_src is None:
                        return None

                    op_type = "add"
                    if (int_src < 0 and mnemonic == "add") or (int_src >= 0 and mnemonic == "sub"):
                        op_type = "sub"

                    arith_add_ct_effect = _effect.make_arith_ct_effect(op_type, dest, int_src)
                    instr_effects.append(arith_add_ct_effect)

            elif mnemonic in ["dec", "inc"]:
                
                dest = instr.op_str

                if dest not in SUPPORTED_REGS:
                    return None

                op_type = "sub"
                if mnemonic == "inc":
                    op_type = "add"

                arith_1_effect = _effect.make_arith_ct_effect(op_type, dest, 1)
                instr_effects.append(arith_1_effect)

            elif mnemonic == "neg":
                
                if instr.op_str not in SUPPORTED_REGS:
                    return None

                arith_neg_effect = _effect.make_neg_effect(instr.op_str)
                instr_effects.append(arith_neg_effect)

            elif mnemonic in ["and", "or", "xor"]:
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in SUPPORTED_REGS:
                    return None

                if src not in SUPPORTED_REGS:

                    int_src = _is_int(src)

                    if int_src is None:
                        return None
                    
                    arith_bitwise_ct_effect = _effect.make_arith_ct_effect(mnemonic, dest, int_src)
                    instr_effects.append(arith_bitwise_ct_effect)

                else:
                    # particular case xor r, r <=> mov r, 0
                    if dest == src:

                        load_0_effect = _effect.make_load_ct_effect(dest, 0)
                        instr_effects.append(load_0_effect)

                    else:
                        arith_bitwise_reg_effect = _effect.make_arith_reg_effect(mnemonic, dest, src)
                        instr_effects.append(arith_bitwise_reg_effect)
                    
            elif mnemonic == "nop" or _ignored_instr(instr):
                
                nop_effect = _effect.instantiate_effect("NO_OP")
                instr_effects.append(nop_effect)

            else:
                return None

            return instr_effects          

        except Exception:
            return None

    # method responsible for creating a gadget from separate (but ordered) instruction effects
    # the joining should resemble joining effects when building (yet to be implemented) rop chains from gadgets
    @staticmethod
    def join_instr_effects(ordered_effects: List[List[_effect]]):
        
        # depth-first exploration of <op>-type _structured_element arithmetic tree
        # yielding every _structured_element of type "reg_in"
        def _recursive_arith_exploration(element: _structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.type in ["add", "sub", "and", "or", "xor", "neg"]:
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem
        
        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: _effect):

            if ef.type in ["NO_OP", "ADD_RSP"]:
                return True

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            # TODO simplify arith expressions

            return False

        # position of rsp in the stack view, considering 64 bit elements (real rsp byte offset = rsp_pos * 8 bytes)
        rsp_pos = 0
        acc_effects: List[_effect] = []
        acc_stack = _64b_stack_view()

        # the joining (currently) has 7 steps
        #
        #   1) initialize the joined effects list with the second effects list
        #   2) update the stack by analysing LOAD_S and ADD_RSP effects
        #   3) for every instruction in the joined effects list, 
        #       replace every "reg_in" with the corresponding "reg_out" from the first effects list
        #   4) copy every effect from the first effects list into the joined effects list, that has the destination reg
        #       different from any other destination reg from the joined effects list,
        #       and also skip NO_OP and ADD_RSP effects
        #   5) (optionally) iterate over all effects from the joined effects list and filter them
        #       so that effects of type move ri, ri are eliminated, or for simplifying arithmetic effects
        #   6) the first effects list is assigned the newly created joined effects list, and the loop continues 
        #       until all effect lists are processed
        #   7) a new gadget is created with the final effects list and the obtained stack, and some validity constraints are imposed

        # NOTE: no two effects from a single effect list contain the same destination register
        #       proof by induction: base case assured by the analyse_instr, 
        #                           induction step proven by the rest of the current algorithm's steps

        for i in range(len(ordered_effects)):
            
            # step 1)
            new_acc_effect_list = deepcopy(ordered_effects[i])

            # step 2)
            for ef in new_acc_effect_list:

                if ef.type == "LOAD_S":
                    
                    if rsp_pos == len(acc_stack.elements):

                        acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_val"))
                        acc_stack.elements[rsp_pos].info["id"] = ef.params[0].info["id"]

                    else:
                        ef.params[0].info["id"] = acc_stack.elements[rsp_pos].info["id"]

                elif ef.type == "ADD_RSP":
                    
                    inc_pos_cnt = ef.params[0].info["value"] // 8

                    while inc_pos_cnt > 0:

                        if rsp_pos == len(acc_stack.elements):
                            acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_pad"))

                        rsp_pos += 1
                        inc_pos_cnt -= 1

            # step 3)
            for ef in new_acc_effect_list:

                if ef.type == "MOV_RR":
                    
                    reg_in_name = ef.params[0].info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in acc_effects:

                        if before_ef.destination_element.info["reg_name"] == reg_in_name:
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:
                        
                        if corresp_before_ef.type == "MOV_RR":
                            ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:
                            
                            # example for ARITH, analogous for rest
                            # r1 = t1 <op> t2
                            # r2 = r1
                            # joined (for r2): r2 = t1 <op> t2

                            ef.type = corresp_before_ef.type
                            ef.params = deepcopy(corresp_before_ef.params)

                elif ef.type == "ARITH":
                    
                    expr = ef.params[0]
                    for reg_in_elem in _recursive_arith_exploration(expr):
                        
                        reg_in_name = reg_in_elem.info["reg_name"]

                        corresp_before_ef = None
                        for before_ef in acc_effects:

                            if before_ef.destination_element.info["reg_name"] == reg_in_name:
                                corresp_before_ef = before_ef
                                break

                        if corresp_before_ef is not None:

                            if corresp_before_ef.type == "LOAD_S":

                                reg_in_elem.type = "64b_stack_val"
                                reg_in_elem.info = {"id": corresp_before_ef.params[0].info["id"]}

                            elif corresp_before_ef.type == "LOAD_CT":
                                
                                reg_in_elem.type = "ct_val"
                                reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                            elif corresp_before_ef.type == "MOV_RR":
                                reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                            elif corresp_before_ef.type == "ARITH":
                                
                                reg_in_elem.type = corresp_before_ef.params[0].type
                                reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)
        
            # step 4) and 5)
            for before_ef in acc_effects:
                if before_ef.destination_element is not None:

                    before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                    overridden = False
                    for ef in new_acc_effect_list:

                        if (ef.destination_element is not None) and (ef.destination_element.info["reg_name"] == before_ef_dest_reg_name):
                            overridden = True

                    if overridden is False:
                        new_acc_effect_list.append(before_ef)
                    
            # step 5) and 6)
            acc_effects.clear()
            for ef in new_acc_effect_list:
                
                if _ignored_effect(ef) is False:
                    acc_effects.append(ef)

        # step 7)

        # the rsp must be at the end of the stack view, 
        # so that the return address of the gadget can be added
        if rsp_pos != len(acc_stack.elements):
            return None

        gadget = ROP_gadget()

        acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_val"))
        acc_stack.elements[rsp_pos].info["id"] = gadget.addr
        rsp_pos += 1

        gadget.stack = acc_stack
        gadget.effects = acc_effects

        return gadget

# gadget class that has associated a stack view and its effects (currently, operating on registers and/or stack popping)
class ROP_gadget:

    def __init__(self):

        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

        self.addr = _64b_stack_view.get_elem_id()

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # this method is also responsible to pupulate the _effects_to_gadgets dictionary
    # TODO: check if Generator type hint behaves as predicted
    # TODO: rest of functionality !!!
    @staticmethod
    def create_gadget(instr_generator: Generator[CsInsn, None, None], b_instr: bytes):
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag(instr: CsInsn, b_instr: bytes):
            return (len(b_instr) > 20)

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[_effect]] = []

        for instr in instr_generator:

            instr_effects = _effect.analyse_instr(instr)
            if instr_effects is None:
                return None, _send_stop_flag(instr, b_instr)

            effects_per_instruction.append(instr_effects)

        candidate_gadget = _effect.join_instr_effects(effects_per_instruction)
        if candidate_gadget is None:
            return None, _send_stop_flag(None, b_instr)

        # TODO: add in effects_to_gadgets dict before return
        return candidate_gadget, _send_stop_flag(None, b_instr)

# class to store more conveniently an (ordered) list of gadgets
# it also (redundantly) stores the whole stack view and the cummulated effects
# to be easier / faster to query for its properties
class ROP_chain:

    def __init__(self):

        self.gadgets: List[ROP_gadget] = []
        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

# main class, the "entry point" in using the functionalities implemented in this file
# it only implements a tiny fraction of the functionality the ROP concept can provide
# but it should be easy to extend at any time
class ROP_util:

    # all possible endpoints for a gadget
    # that transfer control to another gadget
    ENDPOINTS = { b'\xc3': "ret", b'\xff\xe0': "jmp rax", b'\xff\xe3': "jmp rbx", b'\xff\xe1': "jmp rcx", 
                    b'\xff\xe2': "jmp rdx", b'\xff\xe5': "jmp rbp", b'\xff\xe6': "jmp rsi", b'\xff\xe7': "jmp rdi", 
                    b'\x41\xff\xe0': "jmp r8", b'\x41\xff\xe1': "jmp r9", b'\x41\xff\xe2': "jmp r10", b'\x41\xff\xe3': "jmp r11", 
                    b'\x41\xff\xe4': "jmp r12", b'\x41\xff\xe5': "jmp r13", b'\x41\xff\xe6': "jmp r14", b'\x41\xff\xe7': "jmp r15" }

    def __init__(self, filepath: str):

        self.bin_handle = Elf_util(filepath)
        self.exec_bytes = self.bin_handle.load_x_bytes()

        self.capstone = Cs(CS_ARCH_X86, CS_MODE_64)

        self.bin_handle = None

        self.ret_gadgets = None
        self.ret_offsets = None
        self.endpoints_offsets = None

    def find_endpoints_offsets(self) -> List[Tuple[int, int]]:

        if self.endpoints_offsets is None:

            self.endpoints_offsets = []
            
            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] in ROP_util.ENDPOINTS.keys():
                        self.endpoints_offsets.append((i, xc_offset + ib))
                        

        return self.endpoints_offsets

    def find_ret_offsets(self) -> List[Tuple[int, int]]:

        if self.ret_offsets is None:

            self.ret_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] == b'\xc3':
                        self.ret_offsets.append((i, xc_offset + ib))

        return self.ret_offsets

    def find_ret_gadgets(self):

        if self.ret_gadgets is None:
            
            self.ret_gadgets = []

            ret_offsets = self.find_ret_offsets()
            for xc_index, ret_offset in ret_offsets:
                
                neg_offset = 1
                while True:
                    
                    b_vaddr = self.exec_bytes[xc_index][0]
                    b_instr = self.exec_bytes[xc_index][1][ret_offset - neg_offset - b_vaddr: ret_offset - b_vaddr]
                    
                    stop = False

                    disas_instr_generator = self.capstone.disasm(b_instr, b_vaddr)

                    g, stop = ROP_gadget.create_gadget(disas_instr_generator, b_instr)
                    if g is not None:
                        self.ret_gadgets.append(g)
                    
                    if stop is True:
                        break
                        
                    neg_offset += 1

            return self.ret_gadgets

#r = ROP_util("app")    
r = ROP_util("/usr/lib/x86_64-linux-gnu/libc-2.31.so")

os = r.find_ret_gadgets()



