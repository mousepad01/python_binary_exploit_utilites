from typing import Dict, Generator, List, Tuple
from parsebin import *
from capstone import *

# NOTE: this file (currently) only implements functionality for x86_64 ELF files
# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# class that stores any kind of entity that can have a value
# eg. stack bytes, registers, register value "snapshot" at some point of execution, and so on
# the design choice of using such an ambiguous class 
# is based on the fact that the implementation is way easier to understand, to extend, or to modify
# compared to the situation in which every use case of this class would get its own class
class _structured_element:

    # dictionary of currently used structured elements types
    # {"ELEMENT_TYPE": [info param 1 type, ...]}
    # NOTE: the fields described here only represent the keys of the self.info dict
    #       populating it with the corresponding (valid) values is the programmer's responsability
    ELEMENT_TYPES = {"val": ["id", "value"],            # an integer value
                        "64b_stack_val": ["val"],       # integer value from the stack
                        "ct_val": ["val"],              # integer constant (non-stack / non-register) value

                        "reg_in": ["reg_name"],         # register value at the beginning of a gadget / chain
                        "reg_out": ["reg_name"],        # register value after executing a gadget / chain

                        "add_ct": ["ct_val"],           # operations with ct_val (non-register values)
                        "sub_ct": ["ct_val"],           
                        "and_ct": ["ct_val"],
                        "or_ct": ["ct_val"],
                        "xor_ct": ["ct_val"],
                        "neg": [],

                        "add_reg": ["reg_in"],          # operations with (other) registers (given as input to the gadget / chain)
                        "sub_reg": ["reg_in"],
                        "and_reg": ["reg_in"],
                        "or_reg": ["reg_in"],
                        "xor_reg": ["reg_in"],
                        
                        "add_expr": [],                 # recursive operations on other elements
                        "sub_expr": [],                 # the self.info dict keys are not specified here  
                        "and_expr": [],
                        "or_expr": [],
                        "xor_expr": [],
                    }

    @staticmethod
    def _instantiate_structured_element(element_type: str):

        if element_type not in _structured_element.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _structured_element with type {element_type}")
        
        element = _structured_element(element_type)
        for info_field in _structured_element.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

# class to simulate the real stack on which a gadget or chain is executed
# the self.elements list must contain _structured_element objects
class _64b_stack_view:

    def __init__(self):
        self.elements: List[_structured_element] = []

    def push(self, element: _structured_element):
        self.elements.append(element)

# class to store the semantics of all the gadgets
# again, some ambiguity is intentionally provided, for same reasoning as the above mentioned classes
# but it has some constrains:
#   * every effect has an id that should be part of an implementation convention
#   * the effect, if seen as an operation, stores the result value in a single destination element (currently, by convention, only registers)
class _effect:

    # dictionary of currently used effect types
    # {"EFFECT_TYPE": (destination_element type, [param1 type, ...]), ...}
    # NOTE: ARITH type has parameter type configurable: "<op>_<ct/reg>" or "neg"
    EFFECT_TYPES = {"LOAD_S": ("reg_out", ["64b_stack_val"]),
                    "LOAD_CT": ("reg_out", ["ct_val"]),
                    "MOV_RR": ("reg_out", ["reg_in"]),
                    "ARITH": ("reg_out", []),
                    "ALTERED_REG": ("reg_out", []),
                    "NO_OP": (None, [])
                    }

    @staticmethod
    def _instantiate_effect(effect_type: str):

        if effect_type not in _effect.EFFECT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _effect with type {effect_type}")

        effect = _effect(effect_type, None, None)
        for dest_type, param_type_list in _effect.EFFECT_TYPES[effect_type]:

            effect.destination_element = _structured_element._instantiate_structured_element(dest_type)

            for param_type in param_type_list:
                effect.params.append(_structured_element._instantiate_structured_element(param_type))

        return effect

    def __init__(self, effect_type: str, destination_element: _structured_element, params: List[_structured_element]):

        self.id: str = effect_type
        self.destination_element: _structured_element = destination_element
        self.params: List[_structured_element] = params

    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    @staticmethod
    def _analyse_instr(instr: CsInsn):
        
        pass


# gadget class that has associated a stack view and its effects (currently, operating on registers and/or stack popping)
class ROP_gadget:

    def __init__(self):

        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # this method is also responsible to pupulate the _effects_to_gadgets dictionary
    # TODO: check if Generator type hint behaves as predicted
    # TODO: rest of functionality !!!
    @staticmethod
    def _create_gadget(instr_generator: Generator[CsInsn, None, None], b_instr: bytes):
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag(instr: CsInsn, b_instr: bytes):
            return (len(b_instr) > 20)
        
        candidate_gadget = ROP_gadget()

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[_effect]] = []

        print("new gadget:")
        for instr in instr_generator:

            instr_effects = _effect._analyse_instr(instr)
            if instr_effects is None:
                return None, _send_stop_flag(instr, b_instr)

            effects_per_instruction.append(instr_effects)
            
            print(f"mnemonic is: {instr.mnemonic}", end="")
            try:
                i_args = instr.op_str
                print(f", arguments are {i_args}")
            except Exception:
                print(", no arguments")

        # TODO: add in effects_to_gadgets dict before return
        return candidate_gadget, _send_stop_flag(None, b_instr)

# dictionary to map effect types to gadgets or chains, for ease of access
_effects_to_gadgets: Dict = {}

# class to store more conveniently an (ordered) list of gadgets
# it also (redundantly) stores the whole stack view and the cummulated effects
# to be easier / faster to query for its properties
class ROP_chain:

    def __init__(self):

        self.gadgets: List[ROP_gadget] = []
        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

# main class, the "entry point" in using the functionalities implemented in this file
# it only implements a tiny fraction of the functionality the ROP concept can provide
# but it should be easy to extend at any time
class ROP_util:

    # all possible endpoints for a gadget
    # that transfer control to another gadget
    ENDPOINTS = { b'\xc3': "ret", b'\xff\xe0': "jmp rax", b'\xff\xe3': "jmp rbx", b'\xff\xe1': "jmp rcx", 
                    b'\xff\xe2': "jmp rdx", b'\xff\xe5': "jmp rbp", b'\xff\xe6': "jmp rsi", b'\xff\xe7': "jmp rdi", 
                    b'\x41\xff\xe0': "jmp r8", b'\x41\xff\xe1': "jmp r9", b'\x41\xff\xe2': "jmp r10", b'\x41\xff\xe3': "jmp r11", 
                    b'\x41\xff\xe4': "jmp r12", b'\x41\xff\xe5': "jmp r13", b'\x41\xff\xe6': "jmp r14", b'\x41\xff\xe7': "jmp r15" }

    def __init__(self, filepath: str):

        self.bin_handle = Elf_util(filepath)
        self.exec_bytes = self.bin_handle.load_x_bytes()

        self.capstone = Cs(CS_ARCH_X86, CS_MODE_64)

        self.bin_handle = None

        self.ret_gadgets = None
        self.ret_offsets = None
        self.endpoints_offsets = None

    def find_endpoints_offsets(self) -> List[Tuple[int, int]]:

        if self.endpoints_offsets is None:

            self.endpoints_offsets = []
            
            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] in ROP_util.ENDPOINTS.keys():
                        self.endpoints_offsets.append((i, xc_offset + ib))
                        

        return self.endpoints_offsets

    def find_ret_offsets(self) -> List[Tuple[int, int]]:

        if self.ret_offsets is None:

            self.ret_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] == b'\xc3':
                        self.ret_offsets.append((i, xc_offset + ib))

        return self.ret_offsets

    def find_ret_gadgets(self):

        if self.ret_gadgets is None:
            
            self.ret_gadgets = []

            ret_offsets = self.find_ret_offsets()
            for xc_index, ret_offset in ret_offsets:
                
                neg_offset = 1
                while True:
                    
                    b_vaddr = self.exec_bytes[xc_index][0]
                    b_instr = self.exec_bytes[xc_index][1][ret_offset - neg_offset - b_vaddr: ret_offset - b_vaddr]
                    
                    stop = False

                    disas_instr_generator = self.capstone.disasm(b_instr, b_vaddr)

                    g, stop = ROP_gadget._create_gadget(disas_instr_generator, b_instr)
                    if g is not None:
                        self.ret_gadgets.append(g)
                    
                    if stop is True:
                        break
                        
                    neg_offset += 1

            return self.ret_gadgets

r = ROP_util("app")    
#r = ROP_util("/usr/lib/x86_64-linux-gnu/libc-2.31.so")

os = r.find_ret_gadgets()



