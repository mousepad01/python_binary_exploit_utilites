from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from rand import random
from utils import _is_int
from logger import Logger

from rop_platform import Platform
from stackview import Stack_view
from structured_element import Structured_element
from effect import Effect

from roputils_x86_64 import *
from roputils_arm64 import *

from capstone import *
# import z3

class ROP_util:
    """main class, the "entry point" in using the functionalities implemented in this file
        it only implements a tiny fraction of the functionality the ROP concept can provide
        but it should be easy to extend at any time"""

    def __init__(self, filepath: str, platform: Platform, session_name = "ROP_util", print_log = True):

        self.platform = platform
        self.filepath = filepath
        
        if self.platform is Platform.X86_64:

            self.rop_searcher = ROP_searcher_x86_64(filepath)
            self.structured_element = Structured_element
            self.effect = Effect

        elif self.platform is Platform.ARM64:

            self.rop_searcher = ROP_searcher_ARM64(filepath)
            self.structured_element = Structured_element_ARM64
            self.effect = Effect_ARM64

        else:
            raise RuntimeError(f"Requested platform {platform} unknown or not supported")

        self.logger = Logger(session_name = session_name, print_log = print_log)

    def scout_for_gadgets(self) -> None:

        _t = self.logger.log_info(f"Analysing the binary {self.filepath} ...", start_timer = True)

        self.rop_searcher.find_gadgets()

        if self.platform is Platform.ARM64:

            self.logger.log_success("Done collecting gadgets.", end_timer = _t)
            _t = self.logger.log_info("Trying to validate jumps and stack accesses ...", start_timer = True)
            
            self.rop_searcher.validate_raw_gadgets(q0 = 3, q1 = 3)

        self.logger.log_success(f"Done analysing the binary {self.filepath}", end_timer = _t)

    # method that parses the input 
    # in an internal format
    def _parse_input(self, wanted_effects_raw: str, reg_start_values_raw: str) -> Tuple[List[Effect], List[Effect]]:

        def _parse_expr(raw: str) -> Structured_element:

            # reg
            if raw in self.platform.SUPPORTED_REGS:

                el = self.structured_element.instantiate_structured_element("reg_in")
                el.info["reg_name"] = raw

                return el

            # value
            ct = _is_int(raw)
            if ct is not None:

                el = self.structured_element.instantiate_structured_element("ct_val")
                el.info["value"] = ct

                return el

            # negation
            if raw[0] == "!":

                to_negate = _parse_expr(raw[1:].strip())

                el = self.structured_element.instantiate_structured_element("neg")
                el.info["term_1"] = to_negate

                return el           

            # binary operations and paranthesis     

            if self.platform is Platform.X86_64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor"}

            elif self.platform is Platform.ARM64:
                bin_ops = {"+": "add", "-": "sub", "&": "and", "|": "or", "^": "xor", 
                            "<<": "lsh", ">>": "rsh", "*": "mul"}

            open_paranthesis = 0

            op = None
            left_operand_raw = None
            right_operand_raw = None

            for i in range(len(raw)):
                c = raw[i]

                if c == "(":
                    open_paranthesis += 1

                elif c == ")":
                    open_paranthesis -= 1

                elif (open_paranthesis == 0) and (c in bin_ops.keys()):
                    
                    op = c
                    left_operand_raw, right_operand_raw = raw[:i].strip(), raw[i + 1:].strip()
                    break
            
            if op is not None:
                
                el = self.structured_element.instantiate_structured_element(bin_ops[op])
                el.info["term_1"] = _parse_expr(left_operand_raw)
                el.info["term_2"] = _parse_expr(right_operand_raw)

                return el

            elif open_paranthesis == 0 and raw[0] == "(" and raw[-1] == ")":
                return _parse_expr(raw[1:-1].strip())

            raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")

        def _parse_effect(raw: str, split_s = "="):
            
            dest_reg, raw_assign = raw.split(split_s)
            dest_reg = dest_reg.strip()
            raw_assign = raw_assign.strip()

            if dest_reg not in self.platform.SUPPORTED_REGS:
                raise RuntimeError(f"cannot parse statement {raw} while trying to search for chains")
            
            wef = None
            wef_param = _parse_expr(raw_assign)

            if wef_param.type == "ct_val":
                wef = self.effect.make_load_ct_effect(dest_reg, wef_param.info["value"])

            elif wef_param.type == "reg_in":
                wef = self.effect.make_mov_rr_effect(dest_reg, wef_param.info["reg_name"])

            elif wef_param.is_op():
                wef = self.effect.make_arith_custom_effect(dest_reg, wef_param)

            return wef

        wefs: List[Effect] = []
        start_values: List[Effect] = []

        raw_wefs = wanted_effects_raw.split(",")
        for raw_wef in raw_wefs:
            wefs.append(_parse_effect(raw_wef.strip(), split_s = "="))

        if "==" in reg_start_values_raw:
            raw_rsvs = reg_start_values_raw.split(",")
            for raw_rsv in raw_rsvs:
                start_values.append(_parse_effect(raw_rsv.strip(), split_s = "=="))

        return wefs, start_values

    # search a chain, specifying the Effects in a statement
    # statement is parsed and converted in an internal format
    def search_chain(self, wanted_effects: str, fixed_regs: List[str] = [], reg_start_values: str = '', 
                        max_stack_byte_size: int = 160, max_search_cnt: int = 3, only_gadgets = False) -> Generator[ROP_chain_x86_64 | ROP_chain_ARM64]:

        _t = self.logger.log_info(f"Searching for chains in {self.filepath}...", start_timer = True)
        
        wanted_effects, reg_start_values = self._parse_input(wanted_effects, reg_start_values)
        max_stack_size = max_stack_byte_size // 8

        found_cnt = 0
        
        for ch in self.rop_searcher.search_chain(wanted_effects = wanted_effects, max_stack_size = max_stack_size,
                                                fixed_reg_list = fixed_regs, reg_start_values = reg_start_values, only_gadgets = only_gadgets):
            yield ch

            found_cnt += 1
            if found_cnt == max_search_cnt:

                self.logger.log_success(f"Done searching for chains in {self.filepath}", end_timer = _t)
                return

        self.logger.log_warning(f"Could not find requested chains in {self.filepath}", end_timer = _t)

    def disable_bruteforce(self) -> None:
        self.rop_searcher.BRUTEFORCE_DEPTH = 0

    # enable bruteforce when searching chains
    # chain_g_depth - max number of gadgets to form a chain (distinct or not)
    def enable_bruteforce(self, chain_g_depth = 2) -> None:
        self.rop_searcher.BRUTEFORCE_DEPTH = chain_g_depth

    # returns a payload object
    # does NOT return payload bytes
    def make_payload(self) -> ROP_payload_x86_64 | ROP_payload_ARM64:

        if self.platform is Platform.X86_64:
            return ROP_payload_x86_64(self.rop_searcher)

        elif self.platform is Platform.ARM64:
            return ROP_payload_ARM64(self.rop_searcher)

    # decide whether to use z3 or not
    def use_z3(self, use_z3: bool) -> None:
        self.platform.use_z3 = use_z3
