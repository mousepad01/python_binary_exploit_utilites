from __future__ import annotations
from inspect import stack
from typing import Dict, Generator, List, Tuple
# both above imports only for type hints

from copy import deepcopy

from parsebin import *
from capstone import *

# NOTE: this file (currently) only implements functionality for x86_64 ELF files
# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# retain the constants found during instruction analysis
# for optimising (yet to be implemented) automatic rop chain generator
_existent_constants = set()

# class that stores any kind of entity that can have a value
# eg. stack bytes, registers, register value "snapshot" at some point of execution, and so on
# the design choice of using such an ambiguous class 
# is based on the fact that the implementation is way easier to understand, to extend, or to modify
# compared to the situation in which every use case of this class would get its own class
class _structured_element:

    # dictionary of currently used structured elements types
    # {"ELEMENT_TYPE": [info param 1 type / info param 1 name, ...]}
    # NOTE: the fields described here only represent the keys of the self.info dict
    #       populating it with the corresponding (valid) values is the programmer's responsability
    ELEMENT_TYPES = {"64b_stack_val": ["id"],                          # integer value from the stack, indicated by an id
                        "ct_val": ["value"],                           # integer constant (non-stack / non-register) value

                        "reg_in": ["reg_name"],                        # register value at the beginning of a gadget / chain
                        "reg_out": ["reg_name"],                       # register value after executing a gadget / chain
                        
                        "add": ["r_independent"],                      # arithmetic operations (can be recursive)
                        "sub": ["r_independent"],                      # the complete dict will have the keys: ["term_1", "term_2", "r_independent"]
                        "and": ["r_independent"],  
                        "or": ["r_independent"],  
                        "xor": ["r_independent"],  
                        "neg": ["r_independent"],                      # for negation, term2 will always be None

                        "64b_stack_pad": []                            # marks padding (random value) for the stack view
                    }

                    # NOTE: regarding arithmetic element information:
                    #
                    #       r_independent (def)= a structuled element that does NOT contain 
                    #                               in its arithmetic operations recursion any element with type "reg_in" 
                    #
                    # it can be observed that r_independent arithmetic elements can only be obtained by chaining instructions
                    # because every arithmetic operation given by a single instruction 
                    # has at least a "reg_in" operand - that is, the destination register's initial value, before the operation
    
    @staticmethod
    def instantiate_structured_element(element_type: str):

        if element_type not in _structured_element.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _structured_element with type {element_type}")
        
        element = _structured_element(element_type)
        for info_field in _structured_element.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

    def is_op(self):
        return self.type in ["add", "sub", "and", "or", "xor", "neg"]

    # mostly for debugging purposes
    def __str__(self):
        info_s = {str(k): str(v) for k, v in self.info.items()}
        return f"element type {self.type}, info {info_s}"

# class to simulate the real stack on which a gadget or chain is executed
class _64b_stack_view:

    # retain all the stack elements id's and their value
    # INCLUDING THE RETURN ADDRESSES
    stack_values = {}

    # stack id to uniquely identify the (same) stack values
    # INCLUDING THE RETURN ADDRESSES
    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[_structured_element] = []

    def push(self, element: _structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = _64b_stack_view.stack_id_cnt

        _64b_stack_view.stack_id_cnt += 1
        _64b_stack_view.stack_values.update({to_deliver: None})
        
        return to_deliver

    # mostly for debugging purposes
    def __str__(self):
        return f"stack view with elements {[str(el) for el in self.elements]}"

# class to store the semantics of all the gadgets
# again, some ambiguity is intentionally provided, for same reasoning as the above mentioned classes
# but it has some constrains:
#   * every effect has an id that should be part of an implementation convention
#   * the effect, if seen as an operation, stores the result value in a single destination element (currently, by convention, only registers)
class _effect:

    # RSP not included, treated only in some particular cases
    SUPPORTED_REGS = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp",
                        "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"]

    # dictionary of currently used effect types
    # {"EFFECT_TYPE": (destination_element type, [param1 type, ...]), ...}
    # NOTE: ARITH type has parameter type configurable: "<op>"
    EFFECT_TYPES = {"LOAD_S": ("reg_out", ["64b_stack_val"]),       # load value in register from the stack (RSP value increase NOT included)
                    "LOAD_CT": ("reg_out", ["ct_val"]),             # load value that is constant (that does not originate from registers or stack)
                    "MOV_RR": ("reg_out", ["reg_in"]),              # copying value from one register to another
                    "ARITH": ("reg_out", []),                       # operations (add, sub, bitewise operations, etc) - the PARAMS are not included
                    "ADD_RSP": (None, ["ct_val"]),                  # separate effect indicating incrementing RSP (with a constant value only)
                    # "ALTERED_REG": ("reg_out", []),                 # marks the fact that the register contained in the destination has been altered
                                                                    # but in an unspecified way, NOT YET USED
                                                                    # TODO: decide whether a chain / gadget can be chained with current one 
                                                                    # when containing this effect on input registers from the next gadget / chain
                    "NO_OP": (None, [])                             # no operation
                    }

    @staticmethod
    def instantiate_effect(effect_type: str):
     
        if effect_type not in _effect.EFFECT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate _effect with type {effect_type}")

        effect = _effect(effect_type, None, [])

        dest_type, param_type_list = _effect.EFFECT_TYPES[effect_type]

        if dest_type is not None:
            effect.destination_element = _structured_element.instantiate_structured_element(dest_type)
        
        for param_type in param_type_list:
            effect.params.append(_structured_element.instantiate_structured_element(param_type))

        return effect

    # common code lines between any location (at least when interpreting instructions)
    # for creating an effect that marks an arithmetic operation with a constant
    # NOTE: no checks are done
    @staticmethod
    def make_arith_ct_effect(op_type: str, dest_reg_name: str, constant: int):

        arith_op_ct_effect = _effect.instantiate_effect("ARITH")
        arith_op_ct_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_ct_effect.params.append(_structured_element.instantiate_structured_element(op_type))
        arith_op_ct_effect.params[0].info["r_independent"] = False

        arith_op_ct_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_ct_effect.params[0].info.update({"term_2": _structured_element.instantiate_structured_element("ct_val")})
        arith_op_ct_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_ct_effect.params[0].info["term_2"].info["value"] = constant

        _existent_constants.add(constant)

        return arith_op_ct_effect

    # same as make_arith_ct_effect but for operations with (only) registers
    # NOTE: no checks are done
    @staticmethod
    def make_arith_reg_effect(op_type: str, dest_reg_name: str, src_reg_name: str):

        arith_op_reg_effect = _effect.instantiate_effect("ARITH")
        arith_op_reg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_reg_effect.params.append(_structured_element.instantiate_structured_element(op_type))
        arith_op_reg_effect.params[0].info["r_independent"] = False

        arith_op_reg_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_reg_effect.params[0].info.update({"term_2": _structured_element.instantiate_structured_element("reg_in")})
        arith_op_reg_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_reg_effect.params[0].info["term_2"].info["reg_name"] = src_reg_name

        return arith_op_reg_effect

    @staticmethod
    def make_load_ct_effect(dest_reg_name: str, constant: int):

        load_ct_effect = _effect.instantiate_effect("LOAD_CT")
        load_ct_effect.destination_element.info["reg_name"] = dest_reg_name
        load_ct_effect.params[0].info["value"] = constant

        _existent_constants.add(constant)

        return load_ct_effect

    @staticmethod
    def make_load_s_effect(dest_reg_name: str):

        load_s_effect = _effect.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name
        load_s_effect.params[0].info["id"] = _64b_stack_view.get_elem_id()

        return load_s_effect

    @staticmethod
    def make_mov_rr_effect(dest_reg_name: str, src_reg_name: str):

        mov_rr_effect = _effect.instantiate_effect("MOV_RR")
        mov_rr_effect.destination_element.info["reg_name"] = dest_reg_name
        mov_rr_effect.params[0].info["reg_name"] = src_reg_name

        return mov_rr_effect

    @staticmethod
    def make_neg_effect(dest_reg_name: str):

        arith_neg_effect = _effect.instantiate_effect("ARITH")
        arith_neg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_neg_effect.params.append(_structured_element.instantiate_structured_element("neg"))
        arith_neg_effect.params[0].info["r_independent"] = False

        arith_neg_effect.params[0].info.update({"term_1": _structured_element.instantiate_structured_element("reg_in")})
        arith_neg_effect.params[0].info.update({"term_2": None})
        arith_neg_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name

        return arith_neg_effect

    @staticmethod
    def make_add_rsp_effect(constant: int):

        add_rsp_effect = _effect.instantiate_effect("ADD_RSP")
        add_rsp_effect.params[0].info["value"] = constant

        # this constant is NOT added into known constants cache
        # because is limited in interacting only with RSP

        return add_rsp_effect

    def __init__(self, effect_type: str, destination_element: _structured_element, params: List[_structured_element]):

        self.type: str = effect_type
        self.destination_element: _structured_element = destination_element
        self.params: List[_structured_element] = params

    # internal function for matching ARITH expressions
    def _match_arith(self, other: _effect, reg_start_values: List[Tuple(str, int)]):
        pass

    # function that matches two effects
    # also responsible for matching ARITH expressions
    # TODO: self and other copy so that they remain unchanged
    def match(self, other: _effect, reg_start_values: List[Tuple(str, int)]):
        pass

    # actualize the r_independent property value
    # ONLY for ARITH type effects
    def r_independent_check(self):

        def _check(element: _structured_element):
            
            if element.type == "reg_in":
                return False

            if element.type in ["64b_stack_val", "ct_val"]:
                return True

            if element.is_op():

                r_independent = True

                if element.info["term_1"] is not None:

                    rec_r_indep = _check(element.info["term_1"])
                    r_independent &= rec_r_indep

                if element.info["term_2"] is not None:

                    rec_r_indep = _check(element.info["term_2"])
                    r_independent &= rec_r_indep

                element.info["r_independent"] = r_independent
                return r_independent

        if self.type != "ARITH":
            raise RuntimeError("method called on non-ARITH type effect")

        _check(self.params[0])

    # tries to solve the ARITH operations tree
    # it automatically solves constant-only expressions
    # and, if ids are provided in the fixed stack values ids
    # it extracts the associated value from the _64b_stack_view.stack_values and uses it
    #
    # use_r_independent_prop argument makes use of r_independent property to shortcut some cases
    #
    # save_ct_into is an optional parameter, in which to store obtained constants (it can be a reference to _existent_constants)
    #
    # NOTE: the results of operation execution are ALWAYS CT_VAL even if one/both operands are (FIXED) STACK VALUES
    #       so make sure, after calling this method, the stack elements given as arguments REMAIN FIXED, 
    #       otherwise it is undefined behaviour
    def solve_ops(self, use_r_independent_prop = False, fixed_stack_val_ids: List[int] = [], save_ct_into: set = None):

        def _get_val(element: _structured_element):

            if element is None:
                return None

            if element.type == "ct_val":
                return element.info["value"]

            if element.type == "64b_stack_val" and (element.info["id"] in fixed_stack_val_ids):
                return _64b_stack_view.stack_values[element.info["id"]]

            return None
    
        def _solve(op_element: _structured_element):

            if (use_r_independent_prop is True) and (op_element.info["r_independent"] is False):
                return
            
            term_1: _structured_element = op_element.info["term_1"]
            term_2: _structured_element = op_element.info["term_2"]

            if (term_1 is not None) and (term_1.is_op() is True):
                _solve(term_1)

            if (term_2 is not None) and (term_2.is_op() is True):
                _solve(term_2)

            term_1_val = _get_val(term_1)
            term_2_val = _get_val(term_2)

            if (term_1_val is not None) and (term_2_val is not None):

                new_ct = None
                
                if op_element.type == "add":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": term_2_val + term_2_val}
                    new_ct = term_2_val + term_2_val

                elif op_element.type == "sub":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": term_2_val - term_2_val}
                    new_ct = term_2_val - term_2_val

                elif op_element.type == "and":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": term_2_val & term_2_val}
                    new_ct = term_2_val & term_2_val

                elif op_element.type == "or":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": term_2_val | term_2_val}
                    new_ct = term_2_val | term_2_val

                elif op_element.type == "xor":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": term_2_val ^ term_2_val}
                    new_ct = term_2_val ^ term_2_val

                elif op_element.type == "neg":
                    
                    op_element.type = "ct_val"
                    op_element.info = {"value": ~term_1_val}
                    new_ct = ~term_1_val

                if save_ct_into is not None:
                    save_ct_into.add(new_ct)

        if self.type != "ARITH":
            raise RuntimeError("method called on non-ARITH type effect")

        _solve(self.params[0])

    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    @staticmethod
    def analyse_instr(instr: CsInsn):
        
        # function to check whether a string is a number in base 10 or 16, and, if true, to return it
        def _is_int(to_check: str):
            
            failed_conversion = 0
            int_conversion = 0

            try:
                int_conversion = int(to_check, 10)
            except Exception:
                failed_conversion += 1

            if failed_conversion == 1:
                try:
                    int_conversion = int(to_check, 16)
                except Exception:
                    failed_conversion += 1

            if failed_conversion == 2:
                return None

            return int_conversion

        # separate the arguments from instr.op_str
        def _get_2_args(op_str: str):

            mov_args = op_str.split(",")
                
            if len(mov_args) != 2:
                return None, None

            dest = mov_args[0].strip()
            src = mov_args[1].strip()

            return dest, src

        # checks whether the instruction effects 
        # are ignored (from the point of view of this algorithm)
        # and are treated as NOP
        # TODO: ignore (most of) SSE/AVX operations
        def _ignored_instr(instr: CsInsn):

            # some ignored instructions
            IGNORED_INSTR_MNEMONICS = ["endbr64", "clc", "cld", "cldemote", "clflush", "clflushopt", 
                                        "cli", "clts", "clwb", "cmc", "fnop", "vzeroupper"]

            if instr.mnemonic in IGNORED_INSTR_MNEMONICS:
                return True

            return False

        try:

            instr_effects = []

            mnemonic = instr.mnemonic

            if mnemonic == "pop":

                if instr.op_str not in _effect.SUPPORTED_REGS:
                    return None

                load_s_effect = _effect.make_load_s_effect(instr.op_str)
                add_rsp_effect = _effect.make_add_rsp_effect(8)

                instr_effects.append(load_s_effect)
                instr_effects.append(add_rsp_effect)

            elif mnemonic == "mov":
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in _effect.SUPPORTED_REGS:
                    return None

                # TODO: add mov r, rsp support
                # TODO: add 32b / 16b registers support (at least for some cases)

                if src not in _effect.SUPPORTED_REGS:

                    int_src = _is_int(src)
                    if int_src is None:
                        
                        if src == "qword ptr [rsp]":
                            load_s_effect = _effect.make_load_s_effect(dest)
                            instr_effects.append(load_s_effect)
                        else:
                            return None
                    else:
                        load_ct_effect = _effect.make_load_ct_effect(dest, int_src)
                        instr_effects.append(load_ct_effect)

                else:
                    mov_rr_effect = _effect.make_mov_rr_effect(dest, src)
                    instr_effects.append(mov_rr_effect)

            elif mnemonic == "xchg":

                r1, r2 = _get_2_args(instr.op_str)

                if (r1 not in _effect.SUPPORTED_REGS) or (r2 not in _effect.SUPPORTED_REGS):
                    return None

                if r1 == r2:

                    nop_effect = _effect.instantiate_effect("NO_OP")
                    instr_effects.append(nop_effect)

                else:
                
                    mov_rr_effect1 = _effect.make_mov_rr_effect(r1, r2)
                    mov_rr_effect2 = _effect.make_mov_rr_effect(r2, r1)

                    instr_effects.append(mov_rr_effect1)
                    instr_effects.append(mov_rr_effect2)

            elif mnemonic in ["add", "sub"]:

                dest, src = _get_2_args(instr.op_str)

                if (dest not in _effect.SUPPORTED_REGS) and (dest != "rsp"):
                    return None

                if dest == "rsp":

                    if mnemonic != "add":
                        return None

                    int_src = _is_int(src)

                    if (int_src is None) or (int_src % 8 != 0):
                        return None

                    add_rsp_effect = _effect.make_add_rsp_effect(int_src)
                    instr_effects.append(add_rsp_effect)

                elif src in _effect.SUPPORTED_REGS:
                    
                    arith_add_reg_effect = _effect.make_arith_reg_effect(mnemonic, dest, src)
                    instr_effects.append(arith_add_reg_effect)
                    
                else:
                    
                    int_src = _is_int(src)

                    if int_src is None:
                        return None

                    op_type = "add"
                    if (int_src < 0 and mnemonic == "add") or (int_src >= 0 and mnemonic == "sub"):
                        op_type = "sub"

                    arith_add_ct_effect = _effect.make_arith_ct_effect(op_type, dest, int_src)
                    instr_effects.append(arith_add_ct_effect)

            elif mnemonic in ["dec", "inc"]:
                
                dest = instr.op_str

                if dest not in _effect.SUPPORTED_REGS:
                    return None

                op_type = "sub"
                if mnemonic == "inc":
                    op_type = "add"

                arith_1_effect = _effect.make_arith_ct_effect(op_type, dest, 1)
                instr_effects.append(arith_1_effect)

            elif mnemonic == "neg":
                
                if instr.op_str not in _effect.SUPPORTED_REGS:
                    return None

                arith_neg_effect = _effect.make_neg_effect(instr.op_str)
                instr_effects.append(arith_neg_effect)

            elif mnemonic in ["and", "or", "xor"]:
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in _effect.SUPPORTED_REGS:
                    return None

                if src not in _effect.SUPPORTED_REGS:

                    int_src = _is_int(src)

                    if int_src is None:
                        return None
                    
                    arith_bitwise_ct_effect = _effect.make_arith_ct_effect(mnemonic, dest, int_src)
                    instr_effects.append(arith_bitwise_ct_effect)

                else:
                    # particular case xor r, r <=> mov r, 0
                    if dest == src:

                        load_0_effect = _effect.make_load_ct_effect(dest, 0)
                        instr_effects.append(load_0_effect)

                    else:
                        arith_bitwise_reg_effect = _effect.make_arith_reg_effect(mnemonic, dest, src)
                        instr_effects.append(arith_bitwise_reg_effect)
                    
            elif mnemonic == "nop" or _ignored_instr(instr):
                
                nop_effect = _effect.instantiate_effect("NO_OP")
                instr_effects.append(nop_effect)

            else:
                return None

            return instr_effects          

        except Exception:
            return None

    # method responsible for creating a gadget from separate (but ordered) instruction effects
    # the joining should resemble joining effects when building (yet to be implemented) rop chains from gadgets
    @staticmethod
    def join_instr_effects(ordered_effects: List[List[_effect]]):
        
        # depth-first exploration of <op>-type _structured_element arithmetic tree
        # yielding every _structured_element of type "reg_in"
        def _recursive_arith_exploration(element: _structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem
        
        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: _effect):

            if ef.type in ["NO_OP", "ADD_RSP"]:
                return True

            if ef.type == "ARITH":

                ef.r_independent_check()
                ef.solve_ops(use_r_independent_prop=True, fixed_stack_val_ids=[])

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            return False

        if len(ordered_effects) == 0:
            return None

        # position of rsp in the stack view, considering 64 bit elements (real rsp byte offset = rsp_pos * 8 bytes)
        rsp_pos = 0
        acc_effects: List[_effect] = []
        acc_stack = _64b_stack_view()

        # the joining (currently) has 7 steps
        #
        #   1) initialize the joined effects list with the second effects list
        #   2) update the stack by analysing LOAD_S and ADD_RSP effects
        #   3) for every instruction in the joined effects list, 
        #       replace every "reg_in" with the corresponding "reg_out" from the first effects list
        #   4) copy every effect from the first effects list into the joined effects list, that has the destination reg
        #       different from any other destination reg from the joined effects list,
        #       and also skip NO_OP and ADD_RSP effects
        #   5) (optionally) iterate over all effects from the joined effects list and filter them
        #       so that effects of type move ri, ri are eliminated, or for simplifying arithmetic effects
        #   6) the first effects list is assigned the newly created joined effects list, and the loop continues 
        #       until all effect lists are processed
        #   7) a new gadget is created with the final effects list and the obtained stack, some validity constraints are imposed
        #       and, optionally, other optimizations

        # NOTE: no two effects from a single effect list contain the same destination register
        #       proof by induction: base case assured by the analyse_instr, 
        #                           induction step proven by the rest of the current algorithm's steps

        for i in range(len(ordered_effects)):
            
            # step 1)
            new_acc_effect_list = deepcopy(ordered_effects[i])

            # step 2)
            for ef in new_acc_effect_list:

                if ef.type == "LOAD_S":
                    
                    if rsp_pos == len(acc_stack.elements):

                        acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_val"))
                        _64b_stack_view.stack_values.pop(acc_stack.elements[rsp_pos].info["id"], None)    # remove the unnecessary id
                        acc_stack.elements[rsp_pos].info["id"] = ef.params[0].info["id"]

                    else:
                        _64b_stack_view.stack_values.pop(ef.params[0].info["id"], None)    # remove the unnecessary id
                        ef.params[0].info["id"] = acc_stack.elements[rsp_pos].info["id"]

                elif ef.type == "ADD_RSP":
                    
                    inc_pos_cnt = ef.params[0].info["value"] // 8

                    while inc_pos_cnt > 0:

                        if rsp_pos == len(acc_stack.elements):
                            acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_pad"))

                        rsp_pos += 1
                        inc_pos_cnt -= 1

            # step 3)
            for ef in new_acc_effect_list:

                if ef.type == "MOV_RR":
                    
                    reg_in_name = ef.params[0].info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in acc_effects:

                        if before_ef.destination_element.info["reg_name"] == reg_in_name:
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:
                        
                        if corresp_before_ef.type == "MOV_RR":
                            ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:
                            
                            # example for ARITH, analogous for rest
                            # r1 = t1 <op> t2
                            # r2 = r1
                            # joined (for r2): r2 = t1 <op> t2

                            ef.type = corresp_before_ef.type
                            ef.params = deepcopy(corresp_before_ef.params)

                elif ef.type == "ARITH":
                    
                    expr = ef.params[0]
                    for reg_in_elem in _recursive_arith_exploration(expr):
                        
                        reg_in_name = reg_in_elem.info["reg_name"]

                        corresp_before_ef = None
                        for before_ef in acc_effects:

                            if before_ef.destination_element.info["reg_name"] == reg_in_name:
                                corresp_before_ef = before_ef
                                break

                        if corresp_before_ef is not None:

                            if corresp_before_ef.type == "LOAD_S":

                                reg_in_elem.type = "64b_stack_val"
                                reg_in_elem.info = {"id": corresp_before_ef.params[0].info["id"]}

                            elif corresp_before_ef.type == "LOAD_CT":
                                
                                reg_in_elem.type = "ct_val"
                                reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                            elif corresp_before_ef.type == "MOV_RR":
                                reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                            elif corresp_before_ef.type == "ARITH":
                                
                                reg_in_elem.type = corresp_before_ef.params[0].type
                                reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)
        
            # step 4) and 5)
            for before_ef in acc_effects:
                if before_ef.destination_element is not None:

                    before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                    overridden = False
                    for ef in new_acc_effect_list:

                        if (ef.destination_element is not None) and (ef.destination_element.info["reg_name"] == before_ef_dest_reg_name):
                            overridden = True

                    if overridden is False:
                        new_acc_effect_list.append(before_ef)
                    
            # step 5) and 6)
            acc_effects.clear()
            for ef in new_acc_effect_list:
                
                if _ignored_effect(ef) is False:
                    acc_effects.append(ef)

        # step 7)
        acc_effects_filtered = []
        for ef in acc_effects:
            
            if _ignored_effect(ef) is False:
                acc_effects_filtered.append(ef)
                
        # the rsp must be at the end of the stack view, 
        # so that the return address of the gadget can be added
        if rsp_pos != len(acc_stack.elements):
            return None

        gadget = ROP_gadget()

        acc_stack.push(_structured_element.instantiate_structured_element("64b_stack_val"))
        acc_stack.elements[rsp_pos].info["id"] = _64b_stack_view.get_elem_id()
        rsp_pos += 1

        gadget.stack = acc_stack
        gadget.effects = acc_effects_filtered

        return gadget

    # check whether the effects match or not
    # for LOAD_S, LOAD_CT, MOV_RR, an exact match is needed to return True
    # for ARITH effects, there can be an exact match search
    # or a probabilistic one, if opted for (it calculates the operations)
    #       * the reg_in arguments must be the same
    @staticmethod
    def match_effects(fst_ef: _effect, snd_ef: _effect):
        
        if fst_ef.type != snd_ef.type:
            return False

        if fst_ef.destination_element.info["reg_name"] != snd_ef.destination_element.info["reg_name"]:
            return False

        # TODO

        return True

    # mostly for debugging purposes
    def __str__(self):
        return f"effect type {self.type}, destination element {self.destination_element}, params {[str(el) for el in self.params]}"

# gadget class that has associated a stack view and its effects (currently, operating on registers and/or stack popping)
class ROP_gadget:

    # dictionary to map effect types to gadgets or chains, for ease of access
    _effects_to_gadgets = {}
    for ef in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]:
        _effects_to_gadgets.update({ef: {}})

        for dest_reg in _effect.SUPPORTED_REGS:
            _effects_to_gadgets[ef].update({dest_reg: []})

    # maximum gadget byte length to be searched for
    MAX_GADGET_BYTE_LEN = 30

    def __init__(self, instr_bytes = None):

        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

        self.addr: int = _64b_stack_view.get_elem_id()
        self.b: bytes = instr_bytes

    def get_stack_size(self):
        return len(self.stack.elements)

    def get_next_addr(self):
        return _64b_stack_view.stack_values[self.stack.elements[-1].info["id"]]

    def set_next_addr(self, addr: int):
        _64b_stack_view.stack_values[self.stack.elements[-1].info["id"]] = addr

    # it contains the address without ASLR/PIE offset by default
    def get_current_addr(self):
        return _64b_stack_view.stack_values[self.addr]

    # sould be used only when the default address is changed by address randomization
    def set_current_addr(self, addr: int):
        _64b_stack_view.stack_values[self.addr] = addr

    # pupulate the _effects_to_gadgets dictionary
    def save_in_dict(self):
        for ef in self.effects:
            ROP_gadget._effects_to_gadgets[ef.type][ef.destination_element.info["reg_name"]].append(self)

    # a gadget has fixed stack element ids that are kept globally
    # so to use multiple times the same gadget,
    # a duplicate method is needed, that automatically 
    # makes a deep copy of the stack elements and ids, and also the effects
    # NOTE: if the old id had an associated value, it also copies it, if chosen so
    def duplicate(self, copy_stack_associated_values = True):

        # list instead of dict because of the expected low number of elements
        old_new_id: List[Tuple(int, int)] = []
        def _get_new_id(old_id: int):

            for old, new in old_new_id:
                if old == old_id:
                    return new

            return None

        # recursive search for stack elements that need to be replaced
        def _recursive_replace(op_element: _structured_element):
            
            if op_element.type == "64b_stack_val":
                op_element.info["id"] = _get_new_id(op_element.info["id"])

            elif op_element.is_op():
                
                if op_element.info["term_1"] is not None:
                    _recursive_replace(op_element.info["term_1"])

                if op_element.info["term_2"] is not None:
                    _recursive_replace(op_element.info["term_2"])
        
        cpy = ROP_gadget()

        cpy.addr = self.addr
        cpy.b = self.b

        for stack_elem in self.stack.elements:

            if stack_elem.type == "64b_stack_pad":
                cpy.stack.push(_structured_element.instantiate_structured_element("64b_stack_pad"))

            elif stack_elem.type == "64b_stack_val":

                cpy_stack_elem = _structured_element.instantiate_structured_element("64b_stack_val")

                cpy_stack_elem.info["id"] = _64b_stack_view.get_elem_id()
                old_new_id.append(stack_elem.info["id"], cpy_stack_elem.info["id"])

                if copy_stack_associated_values is True:
                    _64b_stack_view.stack_values[cpy_stack_elem.info["id"]] = _64b_stack_view.stack_values[stack_elem.info["id"]]

                cpy.stack.push(cpy_stack_elem)

        cpy.effects = deepcopy(self.effects)
        for ef in cpy.effects:

            if ef.type == "LOAD_S":
                ef.info["id"] = _get_new_id(ef.info["id"])

            elif ef.type == "ARITH":
                _recursive_replace(ef)

        return cpy
    
    # this method should ONLY be called when you DO NOT NEED THE GADGET ANYMORE
    # it clears the stack and removes the id s that are also present in the corresponding dictionary
    # so that no memory is leaked
    def remove_gadget_object(self):
        
        self.b = None
        self.addr = None
        self.effects = None

        for stack_elem in self.stack.elements:
            if stack_elem.type == "64b_stack_val":
                _64b_stack_view.stack_values.pop(stack_elem.info["id"], None)   # if the key does not exist, None is returned

        self.stack = None

    # FIXME
    # internal method for searching a gadget
    # receives the wanted effect, max stack size, the fixed registers list (optional) and the register start values (optional)
    # it also receives a filter function as argument, to filter all found gadgets, by default it is the identity
    # NOTE: fixed registers may actually be used, as long as at the end of the gadget they contain their initial value
    # NOTE: the arguments are assumed to be valid (checks should be done inside the corresponding public method in ROP_util class)
    # NOTE: max stack size is measured internally as the number of 64bit elements (max stack size in bytes // 8)
    @staticmethod
    def search_gadget(wanted_effect: _effect, max_stack_size: int = 20, fixed_reg_list: List[str] = [], reg_start_values: List[Tuple(str, int)] = [], 
                        filter_fct: function = (lambda l: l)):

        # LOAD_S -> LOAD_S
        # LOAD_CT -> LOAD_CT, LOAD_S (if max stack size > 0), ARITH
        # MOV_RR -> MOV_RR, ARITH
        # ARITH -> ARITH

        found_g: List[ROP_gadget] = []

        if wanted_effect.type == "LOAD_S":
            
            candidate_g: ROP_gadget
            for candidate_g in ROP_gadget._effects_to_gadgets["LOAD_S"][wanted_effect.destination_element.info["reg_name"]]:

                if candidate_g.get_stack_size() > max_stack_size:
                    continue

                candidate_g_cpy = candidate_g.duplicate()
                # TODO

        elif wanted_effect.type == "LOAD_CT":
            pass
        elif wanted_effect.type == "MOV_RR":
            pass
        elif wanted_effect.type == "ARITH":
            pass

        return filter_fct(found_g)

        '''# the most restrictive effect is checked first (in terms of how many gadgets have that effect)
        # then, each candidate gadget is checked for the other effects and for the fixed registers

        min_ef_satisf_g_cnt = 2 ** 63
        min_ef = None
        min_ef_reg = None
        for w_ef in wanted_effects:

            dest_reg = w_ef.destination_element.info["reg_name"]

            if ROP_gadget._effects_to_gadgets[w_ef][dest_reg] is None:
                return None

            if len(ROP_gadget._effects_to_gadgets[w_ef][dest_reg]) < min_ef_satisf_g_cnt:

                min_ef_satisf_g_cnt = len(ROP_gadget._effects_to_gadgets[w_ef][dest_reg])
                min_ef, min_ef_reg = w_ef, dest_reg

        candidate_g_list = ROP_gadget._effects_to_gadgets[min_ef][min_ef_reg]

        # gadget effects set is assumed to have low cardinality,
        # hence no set or advanced lookup method is used, 
        # to avoid the overhead specific with those algorithms

        w_satisf_gadgets = []

        g: ROP_gadget
        for g in candidate_g_list:

            fixed_regs_ok = True
            for g_ef in g.effects:

                if _check_fixed_regs(g_ef) is False:
                    fixed_regs_ok = False
                    break

            if fixed_regs_ok is True:

                all_effects_found = True

                for w_ef in wanted_effects:

                    effect_found = False
                    for g_ef in g.effects:

                        if _effect.match_effects(w_ef, g_ef) is True:
                            effect_found = True
                            break

                    if effect_found is False:
                        all_effects_found = False
                        break

                if all_effects_found is True:
                    w_satisf_gadgets.append(g)
        
        if len(w_satisf_gadgets) == 0:
            return None

        return filter_fct(w_satisf_gadgets)'''

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # this method also calls the save_in_dict
    # NOTE: addr parameter contains the default address, when ASLR/PIE is NOT enabled
    @staticmethod
    def create_gadget(instr_generator: Generator[CsInsn, None, None], b_instr: bytes, addr: int = None):
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag(instr: CsInsn, b_instr: bytes):
            return len(b_instr) > ROP_gadget.MAX_GADGET_BYTE_LEN

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[_effect]] = []

        is_ret = False
        for instr in instr_generator:

            if instr.mnemonic == "ret":
                is_ret = True       # check whether the gedget ends with "ret" or not
                break

            instr_effects = _effect.analyse_instr(instr)
            if instr_effects is None:
                return None, _send_stop_flag(instr, b_instr)

            effects_per_instruction.append(instr_effects)
        
        if is_ret is False:
            return None, _send_stop_flag(None, b_instr)

        candidate_gadget = _effect.join_instr_effects(effects_per_instruction)
        if candidate_gadget is None:
            return None, _send_stop_flag(None, b_instr)

        candidate_gadget.set_current_addr(addr)
        candidate_gadget.b = b_instr

        candidate_gadget.save_in_dict()
        
        return candidate_gadget, _send_stop_flag(None, b_instr)

    # mostly for debugging purposes
    def __str__(self):
        return f"ROP gadget with stack {self.stack}, address id {self.addr}, effects {[str(ef) for ef in self.effects]}"

# class to store more conveniently an (ordered) list of gadgets
# it also (redundantly) stores the whole stack view and the cummulated effects
# to be easier / faster to query for its properties
class ROP_chain:

    def __init__(self):

        self.gadgets: List[ROP_gadget] = []
        self.stack = _64b_stack_view()
        self.effects: List[_effect] = []

# main class, the "entry point" in using the functionalities implemented in this file
# it only implements a tiny fraction of the functionality the ROP concept can provide
# but it should be easy to extend at any time
class ROP_util:

    # all possible endpoints for a gadget
    # that transfer control to another gadget
    ENDPOINTS = { b'\xc3': "ret", b'\xff\xe0': "jmp rax", b'\xff\xe3': "jmp rbx", b'\xff\xe1': "jmp rcx", 
                    b'\xff\xe2': "jmp rdx", b'\xff\xe5': "jmp rbp", b'\xff\xe6': "jmp rsi", b'\xff\xe7': "jmp rdi", 
                    b'\x41\xff\xe0': "jmp r8", b'\x41\xff\xe1': "jmp r9", b'\x41\xff\xe2': "jmp r10", b'\x41\xff\xe3': "jmp r11", 
                    b'\x41\xff\xe4': "jmp r12", b'\x41\xff\xe5': "jmp r13", b'\x41\xff\xe6': "jmp r14", b'\x41\xff\xe7': "jmp r15" }

    def __init__(self, filepath: str):

        self.bin_handle = Elf_util(filepath)
        self.exec_bytes = self.bin_handle.load_x_bytes()

        self.capstone = Cs(CS_ARCH_X86, CS_MODE_64)

        self.bin_handle = None

        self.ret_gadgets = None
        self.ret_offsets = None
        self.endpoints_offsets = None

    def find_endpoints_offsets(self) -> List[Tuple[int, int]]:

        if self.endpoints_offsets is None:

            self.endpoints_offsets = []
            
            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] in ROP_util.ENDPOINTS.keys():
                        self.endpoints_offsets.append((i, xc_offset + ib))
                        

        return self.endpoints_offsets

    def find_ret_offsets(self) -> List[Tuple[int, int]]:

        if self.ret_offsets is None:

            self.ret_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(len(xc)):

                    if xc[ib: ib + 1] == b'\xc3':
                        self.ret_offsets.append((i, xc_offset + ib))

        return self.ret_offsets

    def find_ret_gadgets(self) -> List[ROP_gadget]:

        if self.ret_gadgets is None:
            
            self.ret_gadgets = []

            ret_offsets = self.find_ret_offsets()

            # to check in constant time if the basse address
            # of a current gadget candidate actually steps over another ret
            ret_onlyoffsets = set(r[1] for r in ret_offsets)

            for xc_index, ret_offset in ret_offsets:
                
                neg_offset = 1
                while (ret_offset - neg_offset > 0) and ((ret_offset - neg_offset) not in ret_onlyoffsets):
                    
                    b_vaddr = self.exec_bytes[xc_index][0]
                    b_instr = self.exec_bytes[xc_index][1][ret_offset - neg_offset - b_vaddr: ret_offset - b_vaddr + 1]
                    
                    stop = False

                    disas_instr_generator = self.capstone.disasm(b_instr, ret_offset - neg_offset)
                    g, stop = ROP_gadget.create_gadget(disas_instr_generator, b_instr, ret_offset - neg_offset)

                    if g is not None and len(g.effects) > 0:
                        self.ret_gadgets.append(g)
                        
                        # DEBUG ONLY
                        '''disas_instr_generator = self.capstone.disasm(b_instr, ret_offset - neg_offset)
                        for ins in disas_instr_generator:
                            print(ins.mnemonic, ins.op_str)

                        print(f"{hex(g.get_current_addr())} - {g}", end='\n\n')'''
                    
                    if stop is True:
                        break
                        
                    neg_offset += 1

            for ef in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]:
                for reg in _effect.SUPPORTED_REGS:
                    ROP_gadget._effects_to_gadgets[ef][reg].sort(key = lambda g: len(g.stack.elements))
                
            return self.ret_gadgets

    # search a gadget, specifying the effects in a statement
    # statement is parsed and converted in an internal format
    def search_gadget(self, statement: str):
        pass

# DEBUG ONLY
if __name__ == "__main__":

    #r = ROP_util("app")    
    r = ROP_util("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
    r.find_ret_gadgets()

    for ef in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH"]:
        for reg in _effect.SUPPORTED_REGS:
            print(f"{ef}, {reg}: {len(ROP_gadget._effects_to_gadgets[ef][reg])}")

    '''g: ROP_gadget
    for g in ROP_gadget._effects_to_gadgets["MOV_RR"]["r9"]:
        
        for ins in r.capstone.disasm(g.b, g.addr):
            print(hex(ins.address), ins.mnemonic, ins.op_str)
        print()'''



