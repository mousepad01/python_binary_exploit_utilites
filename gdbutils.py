import gdb

class Utils:

    @staticmethod
    def is_int(to_check: str):

        if type(to_check) == int:
            return to_check
                
        failed_conversion = 0
        int_conversion = 0

        try:
            int_conversion = int(to_check, 10)
        except Exception:
            failed_conversion += 1

        if failed_conversion == 1:
            try:
                int_conversion = int(to_check, 16)
            except Exception:
                failed_conversion += 1

        if failed_conversion == 2:
            return None

        return int_conversion

    @staticmethod
    def get_val(raw: str):

        if raw == '' or raw is None:
            return 0

        val = Utils.is_int(raw)
        if val is not None:
            return val

        if raw[0] == "~":
            return ~Utils.get_val(raw[1:])           

        # binary operations and paranthesis     

        bin_ops = {"+": lambda x, y: x + y, 
                    "-": lambda x, y: x - y,
                    "*": lambda x, y: x * y,
                    "/": lambda x, y: x / y,
                    "&": lambda x, y: x & y,
                    "|": lambda x, y: x | y,
                    "^": lambda x, y: x ^ y,
                    ">>": lambda x, y: x >> y,
                    "<<": lambda x, y: x << y}

        open_paranthesis = 0

        op = None
        left_operand_raw = None
        right_operand_raw = None

        for i in range(len(raw)):
            c = raw[i]

            if c == "(":
                open_paranthesis += 1

            elif c == ")":
                open_paranthesis -= 1

            elif (open_paranthesis == 0) and (c in bin_ops.keys()):
                
                op = bin_ops[c]
                left_operand_raw, right_operand_raw = raw[:i].strip(), raw[i + 1:].strip()
                break
        
        if op is not None:
            return op(Utils.get_val(left_operand_raw), Utils.get_val(right_operand_raw))

        elif open_paranthesis == 0 and raw[0] == "(" and raw[-1] == ")":
            return Utils.get_val(raw[1:-1].strip())

        raise RuntimeError(f"cannot parse expression {raw}")

class testc (gdb.Command):
  """Test command for gdbutils.py script"""

  def __init__ (self):
    super (testc, self).__init__ ("testc", gdb.COMMAND_USER)

  def invoke (self, arg, from_tty):
    print ("test command from gdbutils.py is working")

testc()

class DumpBytes(gdb.Command):
    """Dump raw memory bytes in specified file\n
        Usage:\n
        dx [dump byte length] [file path] [start address as a value or arithmetic expression]"""

    def __init__(self):
        super(DumpBytes, self).__init__("dx", gdb.COMMAND_DATA)

    def invoke(self, arg, from_tty):

        args = arg.split()

        bytecount = Utils.get_val(args[0])
        filepath = args[1]
        start_addr = Utils.get_val(args[2])

        proc = gdb.inferiors()
        print(proc)
        proc = proc[0]

        b = proc.read_memory(start_addr, bytecount)
        with open(filepath, "wb+") as fout:
            fout.write(b.tobytes())

DumpBytes()

class logfcalls(gdb.Command):
    """ Log all function calls\n
        Usage:\n
        logfcalls <max calls count> <path to file in which to save calls>
    """

    def __init__(self):
        super(logfcalls, self).__init__("logfcalls", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        
        args = arg.split()
        if len(args) != 2:
            print("Usage:\nlogfcalls <max calls count> <path to file in which to save calls>")
            return

        total_call_cnt = Utils.get_val(args[0])
        filepath = args[1]

        sched_locking_mode = gdb.execute("show scheduler-locking", False, True)
        sched_locking_mode = sched_locking_mode[sched_locking_mode.find("\"") + 1:-3]

        gdb.execute("set scheduler-locking on", False, True)

        threads = gdb.inferiors()[0].threads()
        threads = [thr.global_num for thr in threads]

        current_thread = gdb.execute("info thr", False, True)
        current_thread = current_thread[current_thread.find("*") + 2:].strip()
        current_thread = current_thread[:current_thread.find("Thread")].strip()

        with open(filepath, "w+") as logfile:

            call_cnt = 0
            while call_cnt < total_call_cnt:
                
                for thr in threads:

                    gdb.execute(f"thread {thr}", False, True)
                    gdb.execute("si", False, True)
                    
                    frame = gdb.selected_frame()
                    arch = frame.architecture()
                    pc = frame.pc()

                    if arch.disassemble(pc)[0]['asm'][:len("call")] == "call":
                        
                        call_arg = arch.disassemble(pc)[0]['asm'][len("call") + 3:]
                        logfile.write(f"{call_arg}\n")
                        
                        call_cnt += 1

logfcalls()
