from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from copy import deepcopy
from random import randint
from sys import stdout
from time import time

from parsebin import *
from utils import to_bytes, _is_int
from logger import Logger

from rop_platform import Platform
from stackview import Stack_view
from structured_element import Structured_element
from effect import Effect_ARM64

from capstone import *
import z3

# NOTE: everything here currently is WIP
#       for a stable implementation (x86 64) use roputils.py from main branch

# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# gadget class that has associated a stack view and its effects (currently, operating on registers and/or stack popping)
# a gadget object can store two identical gadgets, but at different addresses
class ROP_gadget_ARM64:

    # maximum gadget byte length to be searched for
    MAX_GADGET_BYTE_LEN = 32

    def __init__(self):

        self.stack = Stack_view()
        self.effects: List[Effect_ARM64] = []

        self.b: bytes = None

        # self.addrs - addresses of identical gadgets
        # used only at payload generation
        self.addrs: List[int] = []
    
        # self.eq_g - gadgets that differ by stack padding or nop instructions
        # used only at payload generation
        self.eq_g: List[ROP_chain_ARM64] = []

        # self.sp_location - location of stack pointer
        # after exiting from the gadget
        # NOTE: not present on x86 64
        self.sp_location: int = 0

    def get_bytes(self):
        return self.b

    def get_stack_size(self):
        return len(self.stack.elements)

    # by default, it contains the addresses without ASLR/PIE offsets
    def get_current_addrs(self):
        return [Stack_view.stack_values[addr] for addr in self.addrs]

    def show(self, capstone_handle: Cs = None, show_addr = True, show_stack = True, output_handle = stdout):
        
        if len(self.addrs) == 0:
            print("(empty gadget)", file = output_handle)
            return

        if capstone_handle is None:
            capstone_handle = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        disas_instr_generator = capstone_handle.disasm(self.b, self.get_current_addrs()[0])
        for ins in disas_instr_generator:

            if show_addr is True:
                print(f"{hex(ins.address)}: {ins.mnemonic} {ins.op_str}", file = output_handle)
            else:
                print(f"{ins.mnemonic} {ins.op_str}", file = output_handle)

        if show_stack is True:

            _s = f"----- STACK ({self.get_stack_size()} ELEMENTS) -----"
            print(_s, file = output_handle)

            self._show_stack_values(output_handle)

            print("-" * len(_s), file = output_handle)

    def _show_stack_values(self, output_handle):

        for el in self.stack.elements:

            if el.type == "64b_stack_val":

                val = Stack_view.stack_values[el.info['id']]
                if val is not None:
                    print(f"id {el.info['id']}: {hex(val)}", file = output_handle)
                else:
                    print(f"id {el.info['id']}: EMPTY", file = output_handle)
            else:
                print("====PAD====", file = output_handle)

    def add_current_addr(self, addr: int):

        new_addr_id = Stack_view.get_elem_id()
        self.addrs.append(new_addr_id)
        Stack_view.stack_values[new_addr_id] = addr

    # auxiliary internal method for duplication
    def _duplicate_stack(self, cpy: ROP_chain_ARM64 | ROP_chain_ARM64, copy_stack_associated_values):
        
        old_new_id: Dict[int, int] = {}
        def _get_new_id(old_id: int):
            
            if old_id in old_new_id.keys():
                return old_new_id[old_id]

            return None

        # recursive search for stack elements that need to be replaced
        def _recursive_replace(op_element: Structured_element):
            
            if op_element.type == "64b_stack_val":
                op_element.info["id"] = _get_new_id(op_element.info["id"])

            elif op_element.is_op():
                
                if op_element.info["term_1"] is not None:
                    _recursive_replace(op_element.info["term_1"])

                if op_element.info["term_2"] is not None:
                    _recursive_replace(op_element.info["term_2"])

        for stack_elem in self.stack.elements:

            if stack_elem.type == "64b_stack_pad":
                cpy.stack.push(Structured_element.instantiatestructured_element("64b_stack_pad"))

            elif stack_elem.type == "64b_stack_val":

                cpy_stack_elem = Structured_element.instantiatestructured_element("64b_stack_val")

                # check whether the current id has already been replaced in a previous stack element instance
                cpy_id = _get_new_id(stack_elem.info["id"])
                if cpy_id is None:
                    
                    cpy_stack_elem.info["id"] = Stack_view.get_elem_id()
                    old_new_id.update({stack_elem.info["id"]: cpy_stack_elem.info["id"]})

                    if copy_stack_associated_values is True:
                        Stack_view.stack_values[cpy_stack_elem.info["id"]] = Stack_view.stack_values[stack_elem.info["id"]]

                else:
                    cpy_stack_elem.info["id"] = cpy_id                    

                cpy.stack.push(cpy_stack_elem)

        cpy.effects = deepcopy(self.effects)
        for ef in cpy.effects:

            if ef.type == "LOAD_S":
                ef.params[0].info["id"] = _get_new_id(ef.params[0].info["id"])

            elif ef.type == "ARITH":
                _recursive_replace(ef.params[0])

        return cpy, old_new_id

    # a gadget has fixed stack element ids that are kept globally
    # so to use multiple times the same gadget,
    # a duplicate method is needed, that automatically 
    # makes a deep copy of the stack elements and ids, and also the effects
    # it returns the new copy and the old_new_id list
    # NOTE: if the old id had an associated value, it also copies it, if chosen so
    # NOTE: does NOT duplicate the elements from eq_g
    def duplicate(self, copy_stack_associated_values = True):

        cpy = ROP_chain_ARM64()

        cpy.b = self.b

        cpy.eq_g = self.eq_g.copy()
  
        cpy.addrs = self.addrs.copy()
        for i in range(len(cpy.addrs)):
            
            addr_val = Stack_view.stack_values[cpy.addrs[i]]
            addr_id_cpy = Stack_view.get_elem_id()
            Stack_view.stack_values[addr_id_cpy] = addr_val            
            cpy.addrs[i] = addr_id_cpy

        return self._duplicate_stack(cpy, copy_stack_associated_values)
    
    # this method should ONLY be called when you DO NOT NEED THE GADGET ANYMORE
    # it clears the stack and removes the id s that are also present in the corresponding dictionary
    # so that no memory is leaked
    # NOTE: does not remove anything from eq_g
    def remove_stack_ids(self):
        
        self.b = None
        self.effects = None

        for addr_id in self.addrs:
            Stack_view.stack_values.pop(addr_id, None)

        for stack_elem in self.stack.elements:
            if stack_elem.type == "64b_stack_val":
                Stack_view.stack_values.pop(stack_elem.info["id"], None)   # if the key does not exist, None is returned

        self.stack = None

    # function to check whether the given registers remain unchanged or not
    def check_fixed_regs(self, fixed_reg_list: List[str]):

        for fixed_r in fixed_reg_list:
            for ef in self.effects:

                if ef.destination_element.info["reg_name"] == fixed_r: 

                    if ef.type in ["LOAD_CT", "MOV_RR", "LOAD_S"]:
                        return False

                    elif ef.type == "ARITH":
                        
                        nop_mov = Effect_ARM64.make_mov_rr_effect(fixed_r, fixed_r)
                        if Effect_ARM64._match_arith(nop_mov, ef) is False:
                            return False

        return True

    # auxiliary internal method for joining gadgets / chains
    @staticmethod
    def _join_ef_stk(fst: ROP_chain_ARM64 | ROP_chain_ARM64, snd: ROP_chain_ARM64 | ROP_chain_ARM64):

        fst_cpy, _ = fst.duplicate(copy_stack_associated_values=True)
        snd_cpy, _ = snd.duplicate(copy_stack_associated_values=True)

        joined_effects = Effect_ARM64.join_effects(fst_cpy.effects, snd_cpy.effects)
        joined_stack = Stack_view.join_stacks(fst_cpy.stack, snd_cpy.stack)

        res_chain = ROP_chain_ARM64()

        res_chain.stack = joined_stack
        res_chain.effects = joined_effects

        return res_chain, fst_cpy, snd_cpy

    def join(self, snd: ROP_chain_ARM64 | ROP_chain_ARM64) -> ROP_chain_ARM64:

        fst_cpy: ROP_chain_ARM64
        res_chain, fst_cpy, snd_cpy = ROP_chain_ARM64._join_ef_stk(self, snd)

        if type(snd) == ROP_chain_ARM64:

            res_chain.b = [fst_cpy.b] + snd_cpy.b
            res_chain.gadgets_stackview_offset = [0] + [off + fst_cpy.get_stack_size() for off in snd_cpy.gadgets_stackview_offset]
            res_chain.addrs = [fst_cpy.addrs] + snd_cpy.addrs
            res_chain.eq_g = [fst_cpy.eq_g] + snd_cpy.eq_g

        else:

            res_chain.b = [fst_cpy.b, snd_cpy.b]
            res_chain.gadgets_stackview_offset = [0, fst_cpy.get_stack_size()]
            res_chain.addrs = [fst_cpy.addrs, snd_cpy.addrs]
            res_chain.eq_g = [fst_cpy.eq_g, snd_cpy.eq_g]

        return res_chain

    # mostly for debugging purposes
    def __str__(self):
        return f"ROP gadget with stack {self.stack}, addresses are {self.get_current_addrs()}, effects {[str(ef) for ef in self.effects]}"

# class to store rop chains, 
# in almost the same way as rop gadgets
class ROP_chain_ARM64(ROP_gadget_ARM64):

    def __init__(self):

        self.stack: Stack_view = Stack_view()
        self.effects: List[Effect_ARM64] = []

        self.b: List[bytes] = []

        self.addrs: List[List[int]] = []
        self.eq_g: List[List[ROP_chain_ARM64]] = []

        # self.gadgets_stackview_offset - stack offset for each gadget
        self.gadgets_stackview_offset: List[int] = []

    # converts a gadget to a chain with only one gadget
    # does NOT copy
    @staticmethod
    def convert(gadget: ROP_chain_ARM64) -> ROP_chain_ARM64:

        chain = ROP_chain_ARM64()

        chain.effects = gadget.effects
        chain.stack = gadget.stack

        chain.b = [gadget.b]
        chain.gadgets_stackview_offset = [0]
        chain.addrs = [gadget.addrs]
        chain.eq_g = [gadget.eq_g]

        return chain

    def get_bytes(self):
        
        acc_b = b''
        for b_ in self.b:
            acc_b += b_

        return acc_b

    def get_gadget_cnt(self):
        return len(self.gadgets_stackview_offset)

    # generator instead of function as in ROP_chain_ARM64 class
    def get_current_addrs(self): 
        for i in range(self.get_gadget_cnt()):
            yield self.gadgets_stackview_offset[i], [Stack_view.stack_values[addr_id] for addr_id in self.addrs[i]]

    def show(self, capstone_handle: Cs = None, show_addr = True, show_stack = True, output_handle = stdout):
        
        if len(self.addrs) == 0:
            print("(empty chain)", file = output_handle)
            return

        if capstone_handle is None:
            capstone_handle = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        _i = 0
        for _, addrs in self.get_current_addrs():

            disas_instr_generator = capstone_handle.disasm(self.b[_i], addrs[0])
            for ins in disas_instr_generator:

                if show_addr is True:
                    print(f"{hex(ins.address)}: {ins.mnemonic} {ins.op_str}")
                else:
                    print(f"{ins.mnemonic} {ins.op_str}")

            _i += 1

        if show_stack is True:

            _s = f"----- STACK ({self.get_stack_size()} ELEMENTS) -----"
            print(_s, file = output_handle)

            self._show_stack_values(output_handle)
            
            print("-" * len(_s), file = output_handle)

    def add_current_addr(self, addr: int, idx: int):
        
        new_addr_id = Stack_view.get_elem_id()
        self.addrs[idx].append(new_addr_id)
        Stack_view.stack_values[new_addr_id] = addr

    def duplicate(self, copy_stack_associated_values = True):

        cpy = ROP_chain_ARM64()

        cpy.b = self.b.copy()
        cpy.gadgets_stackview_offset = self.gadgets_stackview_offset.copy()
        cpy.eq_g = [l.copy() for l in self.eq_g]

        cpy.addrs = deepcopy(self.addrs)
        for i in range(self.get_gadget_cnt()):
            for j in range(len(cpy.addrs[i])):
            
                addr_val = Stack_view.stack_values[cpy.addrs[i][j]]
                addr_id_cpy = Stack_view.get_elem_id()
                Stack_view.stack_values[addr_id_cpy] = addr_val            
                cpy.addrs[i][j] = addr_id_cpy

        return self._duplicate_stack(cpy, copy_stack_associated_values)
    
    def remove_stack_ids(self):
        
        for i in range(self.get_gadget_cnt()):
            for addr in self.addrs[i]:
                Stack_view.stack_values.pop(addr, None)

        for stack_elem in self.stack.elements:
            if stack_elem.type == "64b_stack_val":
                Stack_view.stack_values.pop(stack_elem.info["id"], None)   # if the key does not exist, None is returned

        self.b = None
        self.effects = None
        self.gadgets_stackview_offset = None
        self.stack = None

    def join(self, snd: ROP_chain_ARM64 | ROP_chain_ARM64) -> ROP_chain_ARM64:

        fst_cpy: ROP_chain_ARM64
        res_chain, fst_cpy, snd_cpy = ROP_chain_ARM64._join_ef_stk(self, snd)
        
        if type(snd) == ROP_chain_ARM64:

            res_chain.b = fst_cpy.b + snd_cpy.b
            res_chain.gadgets_stackview_offset = fst_cpy.gadgets_stackview_offset
            res_chain.gadgets_stackview_offset += [off + fst_cpy.get_stack_size() for off in snd_cpy.gadgets_stackview_offset]
            res_chain.addrs = fst_cpy.addrs + snd_cpy.addrs
            res_chain.eq_g = fst_cpy.eq_g + snd_cpy.eq_g

        else:

            res_chain.b = fst_cpy.b
            res_chain.b.append(snd_cpy.b)
            res_chain.gadgets_stackview_offset = fst_cpy.gadgets_stackview_offset
            res_chain.gadgets_stackview_offset.append(fst_cpy.get_stack_size())
            res_chain.addrs = fst_cpy.addrs
            res_chain.addrs.append(snd_cpy.addrs)
            res_chain.eq_g = fst_cpy.eq_g
            res_chain.eq_g.append(snd_cpy.eq_g)

        return res_chain
    
    # method responsible for building payload for a single chain
    # addr_offset - to be added to (all) original addresses from this chain (eg. because of ASLR)
    # forbidden_bytes - list of forbidden bytes, that can force replacing current gadgets with alternatives
    # NOTE: payload can only be built from a chain, and not a gadget (for implementation simplicity)
    #       if a gadget is needed, it can be converted to a chain and then the payload can be built
    # NOTE: gadgets from eq_g are expected to be sorted by stack size
    def _make_payload(self, max_stack_size: int, forbidden_bytes: List[bytes] = [], 
                        addr_offset: int = 0, pad_byte = b'A') -> bytes:
        
        # check if bytes contain any forbidden byte
        def _check_bytes(to_check: bytes):

            for b in to_check:
                if b in forbidden_bytes:
                    return False

            return True

        payload = b''

        for i in range(self.get_gadget_cnt()):

            found = False

            stack_offset = self.gadgets_stackview_offset[i]

            stack_end = 0
            if i == self.get_gadget_cnt() - 1:
                stack_end = len(self.stack.elements)
            else:
                stack_end = self.gadgets_stackview_offset[i + 1]

            stacks = [self.stack.elements[stack_offset: stack_end]] + [g.stack.elements for g in self.eq_g[i]]
            addrs = [self.addrs[i]] + [g.addrs for g in self.eq_g[i]]

            for j in range(len(stacks)):
                if len(stacks[j]) <= max_stack_size:

                    for k in range(len(addrs[j])):
                        
                        b_addr = to_bytes(Stack_view.stack_values[addrs[j][k]] + addr_offset)

                        if _check_bytes(b_addr) is True:

                            payload += b_addr
                            
                            found = True
                            for el in stacks[j][:-1]:

                                if el.type == "64b_stack_pad":
                                    payload += pad_byte * 8

                                elif el.type == "64b_stack_val":
                                    
                                    val = Stack_view.stack_values[el.info["id"]]

                                    if val is None:
                                        payload += pad_byte * 8
                                        continue
                                
                                    b = to_bytes(val)
                                    if _check_bytes(b) is True:
                                        payload += b
                                    else:
                                        return None     # stacks differ only by padding, so if a forbidden byte is found, 
                                                        # it is clear that there is no way of constructing the payload

                            max_stack_size -= len(stacks[j])
                            
                            if found is True:
                                break

                if found is True:
                    break

            if found is False:
                return None

        if len(payload) % 8 != 0:
            raise RuntimeError(f"Payload is not 8-byte aligned (length: {len(payload)})")
                        
        return payload

    # mostly for debugging purposes
    def __str__(self):
        return f"ROP chain with stack {self.stack}, addresses are {'TODO'}, effects {[str(ef) for ef in self.effects]}"

class ROP_searcher_ARM64:

    def __init__(self, filepath: str):

        def _find_endpoint_offsets():

            ret_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]
                for ib in range(0, len(xc), 4):

                    # NOTE that it actually searches for preffix 0xd6
                    #       that marks all of the supported endpoints (BR, BLR, RET, RET reg)

                    if xc[ib: ib + 1] == Platform.ARM64.ENDPOINT_OPCODE:
                        ret_offsets.append((i, xc_offset + ib))

            return ret_offsets

        self.exec_bytes = Elf_util(filepath).load_x_bytes()
        self.capstone = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        # constant, can be changed, but 3 is the maximum recommended value
        self.BRUTEFORCE_DEPTH = 2

        self.endpoint_offsets: List[Tuple[int, int]] = _find_endpoint_offsets()

        self.gadgets: Set[ROP_chain_ARM64] = set()
        self.jumponly_gadget = [] # TODO for "costly" padding, use jump-only gadgets
        self.effects_to_gadgets: Dict[str, Dict[str, List[ROP_chain_ARM64]]] = {ef_t: {reg: [] for reg in Platform.ARM64.SUPPORTED_REGS} for ef_t in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH", "JUMP"]}

    def find_gadgets(self):

        # dict to help identify gadget duplicates
        # helps identify gadgets that differ only by stack padding or ignored instructions
        opstr_to_gadgets: Dict[str, Tuple[ROP_gadget_ARM64, bool]] = {}
        # helps identify gadgets that are identical
        bytes_to_gadgets: Dict[str, Tuple[ROP_gadget_ARM64, bool]] = {}

        def _get_opstr(b_instr: bytes):

            opstr = ''
            
            for instr in self.capstone.disasm(b_instr, 0):

                if (instr.mnemonic in Platform.ARM64.IGNORED_INSTR_MNEMONICS) or (instr.mnemonic == "nop"): 
                    continue

                opstr += instr.mnemonic
                opstr += instr.op_str

            return opstr

        # auxiliary method to synchronize stack ids
        def _stack_id_sync(g: ROP_gadget_ARM64, eg: ROP_gadget_ARM64):
            
            s_g = g.stack.elements
            s_eg = eg.stack.elements

            i = 0
            j = 0
            while (i < len(s_g)) and (j < len(s_eg)):

                while (i < len(s_g)) and (s_g[i].type == "64b_stack_pad"):
                    i += 1

                while (j < len(s_eg)) and (s_eg[j].type == "64b_stack_pad"):
                    j += 1

                if i == len(s_g):
                    assert(j == len(s_eg))

                if (i < len(s_g)) and (j < len(s_eg)):

                    Stack_view.stack_values.pop(s_eg[j], None)
                    s_eg[j] = s_g[i]

                    i += 1
                    j += 1

                if i == len(s_g):
                    assert(j == len(s_eg))
        
        # TODO initialize jumponly gadget
        
        # to check in constant time if the basse address
        # of a current gadget candidate actually steps over another gadget
        endpoint_onlyoffsets = set(r[1] for r in self.endpoint_offsets)

        for xc_index, endg_offset in self.endpoint_offsets:
            
            # TODO jumponly gadget 

            # -4k                        0           +4
            # |........|........|...  ...|    jump    |
            # g                     endpoint off

            neg_offset = 4
            while (endg_offset - neg_offset >= 0) and ((endg_offset - neg_offset) not in endpoint_onlyoffsets):

                b_vaddr = self.exec_bytes[xc_index][0]
                b_instr = self.exec_bytes[xc_index][1][endg_offset - neg_offset - b_vaddr: endg_offset - b_vaddr + 4]

                stop = False

                if b_instr in bytes_to_gadgets.keys():
                    
                    # if prev gadget is also valid
                    if bytes_to_gadgets[b_instr][1] is True:
                        bytes_to_gadgets[b_instr][0].add_current_addr(endg_offset - neg_offset)

                else:
                    
                    opstr = _get_opstr(b_instr)
                    if (opstr not in opstr_to_gadgets.keys()) or (opstr_to_gadgets[opstr][1] is True):

                        disas_instr_generator = self.capstone.disasm(b_instr, endg_offset - neg_offset)
                        g, stop = self.create_gadget(disas_instr_generator, b_instr, endg_offset - neg_offset)

                    if (g is not None) and (len(g.effects) > 0):
                            
                        bytes_to_gadgets.update({b_instr: (g, True)})

                        if opstr in opstr_to_gadgets.keys():
                            opstr_to_gadgets[opstr][0].eq_g.append(g)

                        else:
                            opstr_to_gadgets.update({opstr: (g, True)})

                            for ef in g.effects:

                                if ef.type == "JUMP":
                                    self.effects_to_gadgets[ef.type][ef.params[0].info["reg_name"]].append(g)
                                else:
                                    self.effects_to_gadgets[ef.type][ef.destination_element.info["reg_name"]].append(g)

                            self.gadgets.add(g)

                    else:
                        bytes_to_gadgets.update({b_instr: (None, False)})
                        opstr_to_gadgets.update({opstr: (None, False)})

                if stop is True:
                    break
                    
                neg_offset += 4

        # for each g, synchronize stack ids between g and gadgets from g.eq_g
        # so that stacks can be interchanged, having (at most) the padding size different
        for g in self.gadgets:
            for eg in g.eq_g:
                _stack_id_sync(g, eg)
  
        # from all eq_g per gadget, select the gadget with the smallest stack size
        # by swapping everything except the effects, which are identical
        # and then sort the eq_g gadgets
        # FIXME form arm64 it should be easier here, stack stays the same ????
        for g in self.gadgets:
            for eg in g.eq_g:
                
                # assert(len(g.effects) == len(eg.effects))
                
                if eg.get_stack_size() < g.get_stack_size():

                    swap_aux = g.b
                    g.b = eg.b
                    eg.b = swap_aux

                    swap_aux = g.stack
                    g.stack = eg.stack
                    eg.stack = swap_aux

                    swap_aux = g.addrs
                    g.addrs = eg.addrs
                    eg.addrs = swap_aux

            g.eq_g.sort(key = lambda gadget: len(gadget.stack.elements))

        # sorting by used stack size
        # FIXME for arm64, unnecessary?
        for ef in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH", "JUMP"]:
            for reg in Platform.ARM64.SUPPORTED_REGS:
                self.effects_to_gadgets[ef][reg].sort(key = lambda g: len(g.stack.elements))

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # NOTE: addr parameter contains the default address, when ASLR/PIE is NOT enabled
    def create_gadget(self, instr_generator: Generator[CsInsn, None, None], b_instr: bytes, addr: int = None) -> Tuple[ROP_gadget_ARM64, bool]:
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag():
            return len(b_instr) > ROP_gadget_ARM64.MAX_GADGET_BYTE_LEN

        def _gadget_end(instr: CsInsn):
            return instr.mnemonic in ["blr, br, ret"]

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[Effect_ARM64]] = []

        ends_correctly = False
        for instr in instr_generator:
            
            # DEBUG ONLY
            print(f"{instr.mnemonic} | {instr.op_str}")
            continue

            if _gadget_end(instr) is True:
                ends_correctly = True
                break

            instr_effects = Effect_ARM64.analyse_instr(instr)
            if instr_effects is None:
                return None, _send_stop_flag()

            effects_per_instruction.append(instr_effects)
        
        if ends_correctly is False:
            return None, _send_stop_flag()

        new_stack, new_effects = Effect_ARM64.join_instr_effects(effects_per_instruction)

        candidate_gadget = ROP_gadget_ARM64()
        candidate_gadget.stack = new_stack
        candidate_gadget.effects = new_effects
        
        if candidate_gadget is None:
            return None, _send_stop_flag()

        candidate_gadget.add_current_addr(addr)
        candidate_gadget.b = b_instr

        return candidate_gadget, _send_stop_flag()

# auxiliary class that helps in building the payload
# FIXME
class ROP_payload:

    class _alignment:

        # default alignment at the beginning of a payload
        DEFAULT_ALIGNMENT = 8

        SUPPORTED_ALIGNMENTS = [8, 16, 32, 64]
        
        def __init__(self, bound: int, is_aligned = False):

            self.bound = bound
            self.is_aligned = is_aligned

    class _addr:

        def __init__(self, addr: int):
            self.addr = addr

    def __init__(self, rop_searcher, output_handle = stdout):

        self.logger = Logger(session_name = "PAYLOAD BUILDER", output_handle = output_handle)
        self.rop_searcher: ROP_searcher_ARM64 = rop_searcher
        
        self.pad_byte = b'A'
        self.max_b_size = 160
        self.forbidden_bytes: List[bytes] = []

        self._raw_payload: List[ROP_payload._addr | bytes | ROP_payload._alignment | ROP_chain_ARM64] = []

    def set_max_size(self, max_byte_size: int) -> None:
        self.max_b_size = max_byte_size

    def add_chain(self, ch: ROP_chain_ARM64) -> None:
        self._raw_payload.append(ch)

    def add_bytes(self, b: bytes) -> None:
        self._raw_payload.append(b)

    def add_padding(self, pad_len: int)-> None:
        self._raw_payload.append(self.pad_byte * pad_len)

    def add_addr(self, addr: int) -> None:
        self._raw_payload.append(ROP_payload._addr(addr))

    # it marks that the stack is aligned to the specified boundary
    # thus ignoring the (deduced) alignment up to this point
    def is_aligned_as(self, bound: int = 8) -> None:

        if bound not in ROP_payload._alignment.SUPPORTED_ALIGNMENTS:
            raise RuntimeError(f"Requested stack alignment of {bound} bytes is not supported")

        self._raw_payload.append(ROP_payload._alignment(bound, is_aligned = True))

    # when building payload
    # this statement is equivalent to adding return-only gadgets
    def align_as(self, bound: int = 8) -> None:

        if bound not in ROP_payload._alignment.SUPPORTED_ALIGNMENTS:
            raise RuntimeError(f"Requested stack alignment of {bound} bytes is not supported")

        self._raw_payload.append(ROP_payload._alignment(bound, is_aligned = False))

    # remove the last added element
    def remove_last_added(self) -> None:

        if len(self._raw_payload) > 0:
            self._raw_payload.pop()

    # method responsible for building final payload, in bytes
    # NOTE: addr offset does NOT apply to given "naked" addresses,
    #       only to chain(gadget) addresses (and ret-only alignment gadgets)
    def build(self, chain_addr_offset: int = 0) -> bytes:

        _t = self.logger.log_info("Building payload...", start_timer = True)
        
        payload = b''

        # check if bytes contain any forbidden byte
        def _check_bytes(to_check: bytes):

            for b in to_check:
                if b in self.forbidden_bytes:
                    return False

            return True

        # returns the (biggest) alignment
        def _check_alignment(to_check_len: int):
            
            for al in ROP_payload._alignment.SUPPORTED_ALIGNMENTS[::-1]:
                if to_check_len % al == 0:
                    return al

            return 0

        # searches for return address 
        # that does not contain forbidden bytes
        _cached_ret_addr = None
        def _get_ret_addr():

            nonlocal _cached_ret_addr
            
            if _cached_ret_addr is None:
                for ret_addr in self.rop_searcher.retonly_gadget.get_current_addrs():

                    b_ret_addr = to_bytes(ret_addr + chain_addr_offset)
                    if _check_bytes(b_ret_addr) is True:

                        _cached_ret_addr = b_ret_addr
                        break

            return _cached_ret_addr

        # preprocess the payload:
        #   * join adjacent chains
        def _preprocess():

            preproc_payload = [self._raw_payload[0]]

            for i in range(1, len(self._raw_payload)):

                if (type(preproc_payload[-1]) != ROP_chain_ARM64) or (type(self._raw_payload[i]) != ROP_chain_ARM64):
                    preproc_payload.append(self._raw_payload[i])

                elif (type(preproc_payload[-1]) == ROP_chain_ARM64) and (type(self._raw_payload[i]) == ROP_chain_ARM64):

                    aux_ch = preproc_payload[-1].join(self._raw_payload[i])
                    preproc_payload[-1].remove_stack_ids()
                    preproc_payload[-1] = aux_ch

                else:
                    raise RuntimeError(f"Encountered element of unknown type {type(self._raw_payload[i])} while trying to make payload")

            return preproc_payload

        preproc_payload = _preprocess()

        b_mss = self.max_b_size
        alignment_aux = ROP_payload._alignment.DEFAULT_ALIGNMENT
        
        for item in preproc_payload:

            if type(item) == bytes:

                if _check_bytes(item) is True:

                    payload += item
                    b_mss -= len(item)

                    if b_mss < 0:
                        self.logger.log_warning(f"Maximum payload byte size surpassed by (at least) {-b_mss} bytes", end_timer = _t)
                        return None

                    alignment_aux += len(item)
                    alignment_aux %= ROP_payload._alignment.SUPPORTED_ALIGNMENTS[-1]

                else:
                    self.logger.log_warning("Some given bytes for building payload contains forbidden bytes", end_timer = _t)
                    return None

            elif type(item) == ROP_payload._addr:

                b_item = to_bytes(item.addr)

                if _check_bytes(b_item) is True:

                    payload += b_item
                    b_mss -= 8

                    if b_mss < 0:
                        self.logger.log_warning(f"Maximum payload byte size surpassed by (at least) {-b_mss} bytes", end_timer = _t)
                        return None

                    alignment_aux += 8
                    alignment_aux %= ROP_payload._alignment.SUPPORTED_ALIGNMENTS[-1]

                else:
                    self.logger.log_warning("A given address for building payload contains forbidden bytes", end_timer = _t)
                    return None

            elif type(item) == ROP_payload._alignment:

                if item.is_aligned is False:
                    
                    current_alignment = _check_alignment(alignment_aux)
                    while current_alignment < item.bound:

                        b_ret_addr = _get_ret_addr()
                        if b_ret_addr is None:

                            self.logger.log_warning("Could not find return address for alignment that does not contain forbidden bytes", end_timer = _t)
                            return None

                        payload += b_ret_addr
                        b_mss -= 8

                        if b_mss < 0:
                            self.logger.log_warning(f"Maximum payload byte size surpassed by (at least) {-b_mss} bytes", end_timer = _t)
                            return None

                        alignment_aux += 8
                        alignment_aux %= ROP_payload._alignment.SUPPORTED_ALIGNMENTS[-1]
                        current_alignment = _check_alignment(alignment_aux)

                else:
                    alignment_aux = item.bound

            elif type(item) == ROP_chain_ARM64:

                if b_mss < 8:
                    self.logger.log_warning(f"Not enough payload length for constructing payload for a given chain: only {b_mss} bytes left", end_timer = _t)
                
                payload_ = item._make_payload(max_stack_size = b_mss // 8, forbidden_bytes = self.forbidden_bytes, 
                                                addr_offset = chain_addr_offset, pad_byte = self.pad_byte)
                if payload_ is not None:

                    payload += payload_
                    b_mss -= len(payload_)

                    if b_mss < 0:
                        self.logger.log_warning(f"Maximum payload byte size surpassed by (at least) {-b_mss} bytes", end_timer = _t)
                        return None

                    alignment_aux += len(payload_)
                    alignment_aux %= ROP_payload._alignment.SUPPORTED_ALIGNMENTS[-1]

                else:
                    self.logger.log_warning("Creating payload for a given rop chain failed", end_timer = _t)
                    return None

        self.logger.log_success("Successfully built the payload", end_timer = _t)

        return payload

