from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from copy import deepcopy
from rand import random
from sys import stdout
from time import time

import scipy as sp

from parsebin import *
from utils import to_bytes
from logger import Logger

from rop_platform import Platform
from stackview import Stack_view
from structured_element import Structured_element, Structured_element_ARM64
from effect import Effect_ARM64

from capstone import *
import z3

# NOTE: everything here currently is WIP
#       for a stable implementation (x86 64) use roputils.py from main branch

# NOTE: any "address"-related keyword used does NOT take into accound ASLR / PIE

# gadget class that has associated a stack view and its effects
# a gadget object can store two identical gadgets, but at different addresses
class ROP_gadget_ARM64:

    # maximum gadget byte length to be searched for
    MAX_GADGET_BYTE_LEN = 60

    def __init__(self):

        self.stack = Stack_view()
        self.effects: List[Effect_ARM64] = []

        # self.b - bytes of the gadget
        # useful for identification (hashing) of a gadget / chain
        self.b: bytes = None 

        # self.addrs - addresses of identical gadgets
        # used only at payload generation
        self.addrs: List[int] = []
    
        # self.eq_g - gadgets that differ by stack padding or nop instructions
        # used only at payload generation
        self.eq_g: List[ROP_chain_ARM64] = []

        # self.end_sp_pos - location of stack pointer
        # after exiting from the gadget
        # (always: start sp pos == 0)
        self.end_sp_pos: int = 0

        # redundant, to be used for fast checks
        # whether all stack references are fully defined
        # and whether this gadget / chain can jump
        self.valid_stack_access: bool = False
        self.valid_jump: bool = False

        # store every unresolved deref,
        # even when it is not found (anymore) in the self.effects list
        # (the access still takes place, even if the extracted value
        #   is no longer relevant when exiting the gadget / chain)
        # when calculating valid stack access, all items inside
        # self.uinresolved_derefs should be taken into account
        self.unresolved_derefs: List[Effect_ARM64] = []

    def get_bytes(self):
        return self.b

    def get_stack_size(self):
        return len(self.stack.elements)

    # by default, it contains the addresses without ASLR/PIE offsets
    def get_current_addrs(self):
        return [Stack_view.stack_values[addr] for addr in self.addrs]

    def show(self, capstone_handle: Cs = None, show_addr = True, show_stack = True, output_handle = stdout):
        
        if len(self.addrs) == 0:
            print("(empty gadget)", file = output_handle)
            return

        print(f"valid_stack_access = {self.valid_stack_access}", file = output_handle)
        print(f"valid_jump = {self.valid_jump}\n", file = output_handle)

        if capstone_handle is None:
            capstone_handle = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        disas_instr_generator = capstone_handle.disasm(self.b, self.get_current_addrs()[0])
        for ins in disas_instr_generator:

            if show_addr is True:
                print(f"{hex(ins.address)}: {ins.mnemonic} {ins.op_str}", file = output_handle)
            else:
                print(f"{ins.mnemonic} {ins.op_str}", file = output_handle)

        if show_stack is True:

            _s = f"----- STACK ({self.get_stack_size()} ELEMENTS) -----"
            print(_s, file = output_handle)

            self._show_stack_values(output_handle)

            print("-" * len(_s), file = output_handle)

    def _show_stack_values(self, output_handle):

        for idx, el in enumerate(self.stack.elements):

            if idx == self.end_sp_pos:
                suffix = "<---- end SP"
            else:
                suffix = ""

            if el.type == "64b_stack_val":

                val = Stack_view.stack_values[el.info['id']]
                jmp = Stack_view.related_jump[el.info['id']]

                if jmp is not None:
                    suffix = f"(jump {jmp}) {suffix}"

                if val is not None:
                    print(f"(+{hex(idx * 8)}) id {el.info['id']}: {hex(val)} {suffix}", file = output_handle)
                else:
                    print(f"(+{hex(idx * 8)}) id {el.info['id']}: EMPTY {suffix}", file = output_handle)
            else:
                print(f"(+{hex(idx * 8)}) ====PAD==== {suffix}", file = output_handle)

        print(f"\nend SP offset: +{hex(8 * self.end_sp_pos)}")

    def add_current_addr(self, addr: int):

        new_addr_id = Stack_view.get_elem_id()
        self.addrs.append(new_addr_id)
        Stack_view.stack_values[new_addr_id] = addr

    # auxiliary internal method for duplication
    def _duplicate_stack(self, cpy: ROP_chain_ARM64 | ROP_chain_ARM64, copy_stack_associated_values):
        
        old_new_id: Dict[int, int] = {}
        def _get_new_id(old_id: int):
            
            if old_id in old_new_id.keys():
                return old_new_id[old_id]

            return None

        # recursive search for stack elements that need to be replaced
        def _recursive_replace(op_element: Structured_element_ARM64):
            
            if op_element.type == "64b_stack_val":
                op_element.info["id"] = _get_new_id(op_element.info["id"])

            elif op_element.is_op():
                
                if op_element.info["term_1"] is not None:
                    _recursive_replace(op_element.info["term_1"])

                if op_element.info["term_2"] is not None:
                    _recursive_replace(op_element.info["term_2"])

        for stack_elem in self.stack.elements:

            if stack_elem.type == "64b_stack_pad":
                cpy.stack.push(Structured_element_ARM64.instantiate_structured_element("64b_stack_pad"))

            elif stack_elem.type == "64b_stack_val":

                cpy_stack_elem = Structured_element_ARM64.instantiate_structured_element("64b_stack_val")

                cpy_id = _get_new_id(stack_elem.info["id"])
                if cpy_id is not None:
                    raise Exception(f"double stack id found when duplicating stack {cpy_id}")
                    
                cpy_stack_elem.info["id"] = Stack_view.get_elem_id()
                old_new_id.update({stack_elem.info["id"]: cpy_stack_elem.info["id"]})

                if copy_stack_associated_values is True:

                    Stack_view.stack_values[cpy_stack_elem.info["id"]] = Stack_view.stack_values[stack_elem.info["id"]] 
                    Stack_view.related_jump[cpy_stack_elem.info["id"]] = Stack_view.related_jump[stack_elem.info["id"]] 

                cpy.stack.push(cpy_stack_elem)

        cpy.effects = deepcopy(self.effects)
        for ef in cpy.effects:

            if ef.type in ["ARITH", "LOAD_S", "JUMP"]:
                _recursive_replace(ef.params[0])

        # unresolved derefs might directly access stack, too
        cpy.unresolved_derefs = deepcopy(self.unresolved_derefs)
        for el in cpy.unresolved_derefs:
            _recursive_replace(el)

        return cpy, old_new_id

    # a gadget has fixed stack element ids that are kept globally
    # so to use multiple times the same gadget,
    # a duplicate method is needed, that automatically 
    # makes a deep copy of the stack elements and ids, and also the effects
    # it returns the new copy and the old_new_id list
    # NOTE: if the old id had an associated value, it also copies it, if chosen so
    # NOTE: does NOT duplicate the elements from eq_g
    def duplicate(self, copy_stack_associated_values = True):

        cpy = ROP_gadget_ARM64()

        cpy.b = self.b

        cpy.eq_g = self.eq_g.copy()

        cpy.valid_stack_access = self.valid_stack_access
        cpy.valid_jump = self.valid_jump

        cpy.end_sp_pos = self.end_sp_pos
  
        cpy.addrs = self.addrs.copy()
        for i in range(len(cpy.addrs)):

            # no related jump for self.addrs IDs
            
            addr_val = Stack_view.stack_values[cpy.addrs[i]]
            addr_id_cpy = Stack_view.get_elem_id()
            Stack_view.stack_values[addr_id_cpy] = addr_val            
            cpy.addrs[i] = addr_id_cpy

        return self._duplicate_stack(cpy, copy_stack_associated_values)
    
    # this method should ONLY be called when you DO NOT NEED THE GADGET ANYMORE
    # it clears the stack and removes the id s that are also present in the corresponding dictionary
    # so that no memory is leaked
    # NOTE: does not remove anything from eq_g
    def remove_stack_ids(self):
        
        self.b = None
        self.effects = None

        for addr_id in self.addrs:
            Stack_view.del_id(addr_id)

        for stack_elem in self.stack.elements:
            if stack_elem.type == "64b_stack_val":
                Stack_view.del_id(stack_elem.info["id"])

        self.stack = None
        self.end_sp_pos = None

        self.valid_jump = None
        self.valid_stack_access = None

    # function to check whether the given registers remain unchanged or not
    def check_fixed_regs(self, fixed_reg_list: List[str]):

        for fixed_r in fixed_reg_list:
            for ef in self.effects:

                if ef.destination_element.info["reg_name"] == fixed_r: 

                    if ef.type in ["LOAD_CT", "MOV_RR", "LOAD_S"]:
                        return False

                    elif ef.type == "ARITH":
                        
                        nop_mov = Effect_ARM64.make_mov_rr_effect(fixed_r, fixed_r)
                        if Effect_ARM64._match_arith(nop_mov, ef) is False:
                            return False

        return True

    # auxiliary internal method for joining gadgets / chains 
    # also handles validation checks / updates
    @staticmethod
    def _join_ef_stk(fst: ROP_chain_ARM64 | ROP_chain_ARM64, snd: ROP_chain_ARM64 | ROP_chain_ARM64):
        
        # NOTE: returns old_id if not replaced
        def _get_new_id(old_id: int):
            
            if old_id in old_new_id.keys():
                return old_new_id[old_id]
            else:
                return old_id

        # recursive search for stack elements that need to be replaced
        def _recursive_replace(op_element: Structured_element_ARM64):
            
            if op_element.type == "64b_stack_val":
                op_element.info["id"] = _get_new_id(op_element.info["id"])

            elif op_element.is_op():
                
                if op_element.info["term_1"] is not None:
                    _recursive_replace(op_element.info["term_1"])

                if op_element.info["term_2"] is not None:
                    _recursive_replace(op_element.info["term_2"])

            elif op_element.type == "deref":

                if op_element.info["expr"] is None:
                    raise Exception("dereferencing None found")

                _recursive_replace(op_element.info["expr"])

        fst_cpy, _ = fst.duplicate(copy_stack_associated_values=True)
        snd_cpy, _ = snd.duplicate(copy_stack_associated_values=True)

        joined_effects = Effect_ARM64.join_effects(fst_cpy.effects, snd_cpy.effects)
        joined_unres_derefs = Effect_ARM64.join_unresolved_derefs(fst_cpy.effects, fst_cpy.unresolved_derefs,
                                                                    snd_cpy.unresolved_derefs)
        joined_stack, old_new_id, new_end_sp_pos = Stack_view.join_stacks_overlap(fst_cpy.stack, snd_cpy.stack, 
                                                                                    fst.end_sp_pos, snd.end_sp_pos)

        # invalidate them to be sure
        # they are not used anymore, after stack joining
        fst_cpy.stack = None
        snd_cpy.stack = None

        if joined_stack is None:

            fst_cpy.remove_stack_ids()
            snd_cpy.remove_stack_ids()
            
            return None, None, None

        for ef in joined_effects:
            _recursive_replace(ef.params[0])

        for el in joined_unres_derefs:
            _recursive_replace(el)

        valid_stack_access = True
        if fst.valid_stack_access is False or snd.valid_stack_access is False:

            for ef in joined_effects:

                resolved = Effect_ARM64.resolve_stack_access(ef.params[0], joined_stack)
                if resolved is None:

                    for el in joined_stack.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.del_id(el.info["id"])
                    
                    return None, None, None

                valid_stack_access = valid_stack_access and resolved

            old_joined_derefs = joined_unres_derefs
            joined_unres_derefs = []

            for el in old_joined_derefs:

                resolved = Effect_ARM64.resolve_stack_access(el, joined_stack)
                if resolved is None:

                    for el_ in joined_stack.elements:
                        if el_.type == "64b_stack_val":
                            Stack_view.del_id(el_.info["id"])
                    
                    return None, None, None

                if resolved is False:
                    joined_unres_derefs.append(el)

                valid_stack_access = valid_stack_access and resolved

        valid_jump = True
        if fst.valid_jump is False or snd.valid_jump is False:

            for ef in joined_effects:
                
                if ef.type == "JUMP":

                    valid = Effect_ARM64.resolve_jump(ef.params[0], ef.destination_element.info["value"])
                    if valid is None:

                        for el in joined_stack.elements:
                            if el.type == "64b_stack_val":
                                Stack_view.del_id(el.info["id"])
                        
                        return None, None, None

                    valid_jump = valid_jump and valid

        res_chain = ROP_chain_ARM64()

        res_chain.stack = joined_stack
        res_chain.effects = joined_effects

        res_chain.valid_stack_access = valid_stack_access
        res_chain.valid_jump = valid_jump

        res_chain.end_sp_pos = new_end_sp_pos

        res_chain.unresolved_derefs = joined_unres_derefs

        return res_chain, fst_cpy, snd_cpy

    def join(self, snd: ROP_chain_ARM64 | ROP_chain_ARM64) -> ROP_chain_ARM64:

        fst_cpy: ROP_chain_ARM64
        res_chain, fst_cpy, snd_cpy = ROP_chain_ARM64._join_ef_stk(self, snd)

        if res_chain is None:
            return None

        if type(snd) == ROP_chain_ARM64:

            res_chain.b = [fst_cpy.b] + snd_cpy.b
            res_chain.addrs = [fst_cpy.addrs] + snd_cpy.addrs
            res_chain.eq_g = [fst_cpy.eq_g] + snd_cpy.eq_g

        else:

            res_chain.b = [fst_cpy.b, snd_cpy.b]
            res_chain.addrs = [fst_cpy.addrs, snd_cpy.addrs]
            res_chain.eq_g = [fst_cpy.eq_g, snd_cpy.eq_g]

        return res_chain

    # mostly for debugging purposes
    def __str__(self):
        return f"ROP gadget with stack {self.stack}, addresses are {self.get_current_addrs()}, effects {[str(ef) for ef in self.effects]}"

# class to store rop chains, 
# in almost the same way as rop gadgets
class ROP_chain_ARM64(ROP_gadget_ARM64):

    def __init__(self):

        # NOTE: gadgets_stackview_offset absent from ARM64

        self.stack: Stack_view = Stack_view()
        self.effects: List[Effect_ARM64] = []

        self.b: List[bytes] = []

        self.addrs: List[List[int]] = []
        self.eq_g: List[List[ROP_chain_ARM64]] = []

        self.end_sp_pos: int = 0

        self.valid_stack_access: bool = False
        self.valid_jump: bool = False

        self.unresolved_derefs: List[Effect_ARM64] = []

    # converts a gadget to a chain with only one gadget
    # does NOT copy
    @staticmethod
    def convert(gadget: ROP_gadget_ARM64) -> ROP_chain_ARM64:

        # no conversion needed
        if type(gadget) == ROP_chain_ARM64:
            return gadget

        chain = ROP_chain_ARM64()

        chain.effects = gadget.effects
        chain.stack = gadget.stack

        chain.b = [gadget.b]
        chain.addrs = [gadget.addrs]
        chain.eq_g = [gadget.eq_g]

        chain.end_sp_pos = gadget.end_sp_pos

        chain.valid_jump = gadget.valid_jump
        chain.valid_stack_access = gadget.valid_stack_access

        return chain

    def get_bytes(self):
        
        acc_b = b''
        for b_ in self.b:
            acc_b += b_

        return acc_b

    def get_gadget_cnt(self):
        return len(self.b)

    # generator instead of function as in ROP_gadget_ARM64 class
    def get_current_addrs(self): 
        for i in range(self.get_gadget_cnt()):
            yield [Stack_view.stack_values[addr_id] for addr_id in self.addrs[i]]

    def show(self, capstone_handle: Cs = None, show_addr = True, show_stack = True, output_handle = stdout):
        
        if len(self.addrs) == 0:
            print("(empty chain)", file = output_handle)
            return

        if capstone_handle is None:
            capstone_handle = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        print(f"valid_stack_access = {self.valid_stack_access}", file = output_handle)
        print(f"valid_jump = {self.valid_jump}\n", file = output_handle)

        _i = 0
        for addrs in self.get_current_addrs():

            disas_instr_generator = capstone_handle.disasm(self.b[_i], addrs[0])
            for ins in disas_instr_generator:

                if show_addr is True:
                    print(f"{hex(ins.address)}: {ins.mnemonic} {ins.op_str}")
                else:
                    print(f"{ins.mnemonic} {ins.op_str}")

            _i += 1

        if show_stack is True:

            _s = f"----- STACK ({self.get_stack_size()} ELEMENTS) -----"
            print(_s, file = output_handle)

            self._show_stack_values(output_handle)
            
            print("-" * len(_s), file = output_handle)

    def add_current_addr(self, addr: int, idx: int):
        
        new_addr_id = Stack_view.get_elem_id()
        self.addrs[idx].append(new_addr_id)
        Stack_view.stack_values[new_addr_id] = addr

    def duplicate(self, copy_stack_associated_values = True):

        cpy = ROP_chain_ARM64()

        cpy.b = self.b.copy()
        cpy.eq_g = [l.copy() for l in self.eq_g]

        cpy.valid_stack_access = self.valid_stack_access
        cpy.valid_jump = self.valid_jump

        cpy.end_sp_pos = self.end_sp_pos

        cpy.addrs = deepcopy(self.addrs)
        for i in range(self.get_gadget_cnt()):
            for j in range(len(cpy.addrs[i])):
            
                addr_val = Stack_view.stack_values[cpy.addrs[i][j]]
                addr_id_cpy = Stack_view.get_elem_id()
                Stack_view.stack_values[addr_id_cpy] = addr_val            
                cpy.addrs[i][j] = addr_id_cpy

        return self._duplicate_stack(cpy, copy_stack_associated_values)
    
    def remove_stack_ids(self):
        
        for i in range(self.get_gadget_cnt()):
            for addr in self.addrs[i]:
                Stack_view.del_id(addr)

        for stack_elem in self.stack.elements:
            if stack_elem.type == "64b_stack_val":
                Stack_view.del_id(stack_elem.info["id"])

        self.b = None
        self.effects = None
        self.stack = None

        self.end_sp_pos = None

        self.valid_jump = None
        self.valid_stack_access = None

    def join(self, snd: ROP_chain_ARM64 | ROP_chain_ARM64) -> ROP_chain_ARM64:

        fst_cpy: ROP_chain_ARM64
        res_chain, fst_cpy, snd_cpy = ROP_chain_ARM64._join_ef_stk(self, snd)

        if res_chain is None:
            return None
        
        if type(snd) == ROP_chain_ARM64:

            res_chain.b = fst_cpy.b + snd_cpy.b

            res_chain.addrs = fst_cpy.addrs + snd_cpy.addrs
            res_chain.eq_g = fst_cpy.eq_g + snd_cpy.eq_g

        else:

            res_chain.b = fst_cpy.b
            res_chain.b.append(snd_cpy.b)
            res_chain.addrs = fst_cpy.addrs
            res_chain.addrs.append(snd_cpy.addrs)
            res_chain.eq_g = fst_cpy.eq_g
            res_chain.eq_g.append(snd_cpy.eq_g)

        return res_chain
    
    # FIXME
    def _make_payload(self, max_stack_size: int, forbidden_bytes: List[bytes] = [], 
                        addr_offset: int = 0, pad_byte = b'A') -> bytes:
        
        print("to be implmeneted for ARM64")
        return None

        # check if bytes contain any forbidden byte
        def _check_bytes(to_check: bytes):

            for b in to_check:
                if b in forbidden_bytes:
                    return False

            return True

        payload = b''

        for i in range(self.get_gadget_cnt()):

            found = False

            stack_offset = self.gadgets_stackview_offset[i]

            stack_end = 0
            if i == self.get_gadget_cnt() - 1:
                stack_end = len(self.stack.elements)
            else:
                stack_end = self.gadgets_stackview_offset[i + 1]

            stacks = [self.stack.elements[stack_offset: stack_end]] + [g.stack.elements for g in self.eq_g[i]]
            addrs = [self.addrs[i]] + [g.addrs for g in self.eq_g[i]]

            for j in range(len(stacks)):
                if len(stacks[j]) <= max_stack_size:

                    for k in range(len(addrs[j])):
                        
                        b_addr = to_bytes(Stack_view.stack_values[addrs[j][k]] + addr_offset)

                        if _check_bytes(b_addr) is True:

                            payload += b_addr
                            
                            found = True
                            for el in stacks[j][:-1]:

                                if el.type == "64b_stack_pad":
                                    payload += pad_byte * 8

                                elif el.type == "64b_stack_val":
                                    
                                    val = Stack_view.stack_values[el.info["id"]]

                                    if val is None:
                                        payload += pad_byte * 8
                                        continue
                                
                                    b = to_bytes(val)
                                    if _check_bytes(b) is True:
                                        payload += b
                                    else:
                                        return None     # stacks differ only by padding, so if a forbidden byte is found, 
                                                        # it is clear that there is no way of constructing the payload

                            max_stack_size -= len(stacks[j])
                            
                            if found is True:
                                break

                if found is True:
                    break

            if found is False:
                return None

        if len(payload) % 8 != 0:
            raise RuntimeError(f"Payload is not 8-byte aligned (length: {len(payload)})")
                        
        return payload

    # mostly for debugging purposes
    def __str__(self):
        return f"ROP chain with stack {self.stack}, addresses are {'TODO'}, effects {[str(ef) for ef in self.effects]}"

class ROP_searcher_ARM64:

    def __init__(self, filepath: str):

        def _find_endpoint_offsets():

            end_offsets = []

            for i in range(len(self.exec_bytes)):
                
                xc_offset, xc = self.exec_bytes[i]

                idx_ = 0

                self.capstone.skipdata = True
                disas = self.capstone.disasm(xc, 0)
                for instr in disas:
                    
                    if instr.mnemonic in Platform.ARM64.ENDPOINTS:
                        end_offsets.append((i, xc_offset + idx_))

                    idx_ += 4

            self.capstone.skipdata = False
            return end_offsets

        self.exec_bytes = Elf_util(filepath).load_x_bytes()
        self.capstone = Cs(CS_ARCH_ARM64, CS_MODE_ARM)

        # constant, can be changed, but 3 is the maximum recommended value
        self.BRUTEFORCE_DEPTH = 2

        self.endpoint_offsets: List[Tuple[int, int]] = _find_endpoint_offsets()

        # NOTE: self.gadgets, self.effects_to_gadgets 
        #       cand be both VALID AND INVALID

        self.gadgets: Set[ROP_gadget_ARM64] = set()
        self.jumponly_gadget = [] # TODO for "costly" padding, use jump-only gadgets
        self.effects_to_gadgets: Dict[str, Dict[str, List[ROP_chain_ARM64]]] = {ef_t: {reg: [] for reg in Platform.ARM64.SUPPORTED_REGS} for ef_t in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH", "JUMP"]}

        self.valid_gadgets: Set[ROP_chain_ARM64] = set()
        # TODO maybe a list of "almost-jumponly" g/chs that are valid, for padding???
        self.valid_effects_to_gadgets: Dict[str, Dict[str, List[ROP_chain_ARM64]]] = {ef_t: {reg: [] for reg in Platform.ARM64.SUPPORTED_REGS} for ef_t in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH", "JUMP"]}

    def find_gadgets(self):

        # dict to help identify gadget duplicates
        # helps identify gadgets that differ only by stack padding or ignored instructions
        opstr_to_gadgets: Dict[str, Tuple[ROP_gadget_ARM64, bool]] = {}
        # helps identify gadgets that are identical
        bytes_to_gadgets: Dict[str, Tuple[ROP_gadget_ARM64, bool]] = {}

        def _get_opstr(b_instr: bytes):

            opstr = ''
            
            for instr in self.capstone.disasm(b_instr, 0):

                if (instr.mnemonic in Platform.ARM64.IGNORED_INSTR_MNEMONICS) or (instr.mnemonic == "nop"): 
                    continue

                opstr += instr.mnemonic
                opstr += instr.op_str

            return opstr

        # auxiliary method to synchronize stack ids
        def _stack_id_sync(g: ROP_gadget_ARM64, eg: ROP_gadget_ARM64):
            
            s_g = g.stack.elements
            s_eg = eg.stack.elements

            i = 0
            j = 0
            while (i < len(s_g)) and (j < len(s_eg)):

                while (i < len(s_g)) and (s_g[i].type == "64b_stack_pad"):
                    i += 1

                while (j < len(s_eg)) and (s_eg[j].type == "64b_stack_pad"):
                    j += 1

                if i == len(s_g):
                    assert(j == len(s_eg))

                if (i < len(s_g)) and (j < len(s_eg)):

                    Stack_view.del_id(s_eg[j].info["id"])
                    s_eg[j] = s_g[i]

                    i += 1
                    j += 1

                if i == len(s_g):
                    assert(j == len(s_eg))
        
        # TODO initialize jumponly gadget
        
        # to check in constant time if the basse address
        # of a current gadget candidate actually steps over another gadget
        endpoint_onlyoffsets = set(r[1] for r in self.endpoint_offsets)

        for xc_index, endg_offset in self.endpoint_offsets:
            
            # TODO jumponly gadget 

            # -4k                        0           +4
            # |........|........|...  ...|    jump    |
            # g                     endpoint off

            neg_offset = 4
            while (endg_offset - neg_offset >= 0) and ((endg_offset - neg_offset) not in endpoint_onlyoffsets):

                b_vaddr = self.exec_bytes[xc_index][0]
                b_instr = self.exec_bytes[xc_index][1][endg_offset - neg_offset - b_vaddr: endg_offset - b_vaddr + 4]

                stop = False

                if b_instr in bytes_to_gadgets.keys():
                    
                    # if prev gadget is also valid
                    if bytes_to_gadgets[b_instr][1] is True:
                        bytes_to_gadgets[b_instr][0].add_current_addr(endg_offset - neg_offset)

                else:
                    
                    opstr = _get_opstr(b_instr)
                    if (opstr not in opstr_to_gadgets.keys()) or (opstr_to_gadgets[opstr][1] is True):

                        disas_instr_generator = self.capstone.disasm(b_instr, endg_offset - neg_offset)
                        g, stop = self.create_gadget(disas_instr_generator, b_instr, endg_offset - neg_offset)

                    if (g is not None) and (len(g.effects) > 0):
                            
                        bytes_to_gadgets.update({b_instr: (g, True)})

                        if opstr in opstr_to_gadgets.keys():
                            opstr_to_gadgets[opstr][0].eq_g.append(g)

                        else:
                            opstr_to_gadgets.update({opstr: (g, True)})

                            for ef in g.effects:
                                
                                # still not sure whether keeping info about "jump reg" effects
                                # will be useful or not

                                if ef.type == "JUMP":
                                    if ef.params[0].type == "reg_in":
                                        self.effects_to_gadgets[ef.type][ef.params[0].info["reg_name"]].append(g)
                                
                                elif ef.destination_element.info["reg_name"] != "sp":
                                    self.effects_to_gadgets[ef.type][ef.destination_element.info["reg_name"]].append(g)

                            self.gadgets.add(g)

                    else:
                        bytes_to_gadgets.update({b_instr: (None, False)})
                        opstr_to_gadgets.update({opstr: (None, False)})

                if stop is True:
                    break
                    
                neg_offset += 4

        # for each g, synchronize stack ids between g and gadgets from g.eq_g
        # FIXME unnecessary on ARM64??
        for g in self.gadgets:
            for eg in g.eq_g:
                _stack_id_sync(g, eg)
  
        # sorting by used stack size
        for ef in ["LOAD_S", "LOAD_CT", "MOV_RR", "ARITH", "JUMP"]:
            for reg in Platform.ARM64.SUPPORTED_REGS:
                self.effects_to_gadgets[ef][reg].sort(key = lambda g: len(g.stack.elements))

    # main method of parsing instruction chunks and creating gadgets
    # here it is decided whether the gadget is valid / accepted / supported, what effects is has and so on
    # NOTE: addr parameter contains the default address, when ASLR/PIE is NOT enabled
    def create_gadget(self, instr_generator: Generator[CsInsn, None, None], b_instr: bytes, addr: int = None) -> Tuple[ROP_gadget_ARM64, bool]:
        
        # decide here whether to send signal to the caller procedure
        # so that it stops appending preffixes to the same "gadget"
        def _send_stop_flag():
            return len(b_instr) > ROP_gadget_ARM64.MAX_GADGET_BYTE_LEN

        def _gadget_end(instr: CsInsn):
            return instr.mnemonic in ["blr", "br", "ret"]

        # first, each instruction is analysed semantically and translated in some effects
        # then, the effects will be cumulated from first to last instruction, to obtain the gadget
        effects_per_instruction: List[List[Effect_ARM64]] = []

        # NOTE: om ARM64, stop flag can be set when
        #       an illegal / unknown instr is found, because 
        #       the instructions are always 4 bytes
        #       and an unsupported 4 byte sequence
        #       cannot turn into something useful 
        #       even if we add prefix bytes to it

        ends_correctly = False
        for instr in instr_generator:

            instr_effects = Effect_ARM64.analyse_instr(instr)
            if instr_effects is None:
                return None, True

            effects_per_instruction.append(instr_effects)

            if _gadget_end(instr) is True:
                ends_correctly = True
                break

        if ends_correctly is False:
            return None, True

        new_stack, new_effects, valid_stack_access, valid_jump, end_sp_pos, unres_derefs = \
            Effect_ARM64.join_instr_effects(effects_per_instruction)

        if new_stack is None:
            return None, _send_stop_flag()

        candidate_gadget = ROP_gadget_ARM64()
        candidate_gadget.stack = new_stack
        candidate_gadget.effects = new_effects

        candidate_gadget.valid_stack_access = valid_stack_access
        candidate_gadget.valid_jump = valid_jump

        candidate_gadget.end_sp_pos = end_sp_pos

        candidate_gadget.unresolved_derefs = unres_derefs

        candidate_gadget.add_current_addr(addr)
        candidate_gadget.b = b_instr

        return candidate_gadget, _send_stop_flag()

    # only for valid-related statistics
    def valid_stats(self):

        valid_jmp_cnt = 0
        valid_acc_cnt = 0
        valid_cnt = 0
        valid_only_jmp_cnt = 0
        valid_only_acc_cnt = 0
        full_invalid_cnt = 0

        for g in self.gadgets:

            if g.valid_jump is True:
                valid_jmp_cnt += 1
            if g.valid_stack_access is True:
                valid_acc_cnt += 1
            if g.valid_jump is True and g.valid_stack_access is True:
                valid_cnt += 1
            if g.valid_jump is True and g.valid_stack_access is False:
                valid_only_jmp_cnt += 1
            if g.valid_jump is False and g.valid_stack_access is True:
                valid_only_acc_cnt += 1
            if g.valid_jump is False and g.valid_stack_access is False:
                full_invalid_cnt += 1

        assert(valid_only_acc_cnt + valid_only_jmp_cnt + \
                valid_cnt + full_invalid_cnt == len(self.gadgets))

        print(f"\ntotal gadgets {len(self.gadgets)}, full valid {valid_cnt}, " + \
                f"valid jump {valid_jmp_cnt}, " + \
                f"valid stack access {valid_acc_cnt}, " + \
                f"valid jump only {valid_only_jmp_cnt}, " + \
                f"valid stack access only {valid_only_acc_cnt}, " + \
                f"full invalid {valid_only_jmp_cnt}\n")

    # method that filters the valid gadgets
    # and also tries to build valid chains from 
    # invalid and valid gadgets
    def filter_for_valid(self, mode):
        
        if mode not in ["fast", "exhaust"]:
            raise Exception(f"filter mode unknown: {mode}")

        # fast mode only tries a limited number of ways 
        # of joining gadgets on validation attemps
        # exhaust tries a lot more options
        # but it is (expected to be) significantly slower

        # utilitary functions

        def _get_new_id(old_new_id: Dict[int, int], old_id: int):

            if old_id in old_new_id.keys():
                return old_new_id[old_id]

            return None

        # returns ok_to_advertise, contains_sp (both bool)
        # used for both stack access validation, and jump validation
        def _advertisement_check(elem: Structured_element_ARM64):

            if elem is None:
                return True, False

            if elem.type == "reg_in":

                if elem.info["reg_name"] == "sp":
                    return True, True

                return False, False

            if elem.type == "ct_val":
                return True, False

            if elem.type == "64b_stack_val":
                return True, False

            if elem.type == "deref":
                raise Exception("deref found in a supposedly valid gadget / chain")

            if elem.is_op():
                
                l1, l2 = _advertisement_check(elem.info["term_1"])
                r1, r2 = _advertisement_check(elem.info["term_2"])

                return l1 and r1, l2 or r2

            raise Exception(f"unexpected element {elem}")

        def _extract_stk_requests(elem: Structured_element_ARM64, regs: list, inside_deref: bool):

            if elem is None:
                return
        
            if elem.type == "reg_in" and elem.info["reg_name"] != "sp":
                
                if inside_deref is True and elem.info["reg_name"] not in regs:
                    regs.append(elem.info["reg_name"])

            elif elem.is_op():
                _extract_stk_requests(elem.info["term_1"], regs, inside_deref)
                _extract_stk_requests(elem.info["term_2"], regs, inside_deref)

            elif elem.type == "deref":
                
                # even if gadget is invalid, nested derefs are not expected
                # because the gadget has already been checked at join instr
                if inside_deref is True:
                    raise Exception("nested deref")

                _extract_stk_requests(elem.info["expr"], regs, True)

        def _extract_jmp_requests(elem: Structured_element_ARM64, regs: list):

            if elem is None:
                return
        
            if elem.type == "reg_in" and elem.info["reg_name"] not in regs:
                regs.append(elem.info["reg_name"])

            elif elem.is_op():
                _extract_jmp_requests(elem.info["term_1"], regs)
                _extract_jmp_requests(elem.info["term_2"], regs)

            elif elem.type == "deref":
                raise Exception("unexpected deref inside JUMP expression")

        # step 1)
        # filter out valid from invalid

        valid = []
        invalid = []
        for g in self.gadgets:

            if g.valid_jump is True and g.valid_stack_access is True:
                valid.append(g)
            elif g.valid_stack_access is False:
                invalid.append(g)
        
        # step 2) 
        # try to validate stack access

        valid_stack_acc_only = []
        # stack acc valid, jump invalid

        replace_reg_dict = {reg: [[], [], set(), set()] for reg in (Platform.ARM64.SUPPORTED_REGS + ["sp"])}
        # {reg: [
        #        [list of gadgets whose effect with dest elem == reg does not contain other reg_in arguments),
        #        [list of gadgets whose effect with dest elem == reg does not contain other reg_in arguments, 
        #           but contain SP),
        #        (set of elements from the first list),
        #        (set of elements from the second list)
        #       ]
        # }
        # list is used to be able to execute random.choice()
        # set is used to be able to check for existence in constant time

        # NOTE that some gadgets / chains might actually require less registers to be replaced
        #       for example, Xt <- [SP + 8 + (reg & 0)] does not require reg to be replaced
        #       to have a valid stack access 
        #       still, taking into account these kind of cases require greatly increasing the complexity
        #       of the code, for very little gain
        #       so this kind of "optimizations" are not implemented

        iv_to_requests = {iv: [] for iv in invalid}
        # {invalid gadget: [regs to replace]}

        iv_to_tested = {iv: set() for iv in invalid}
        # {invalid gadget: set((g0, g1, ...), ...)}
        # contains ordered join combinations for the current invalid gadget
        # that were previously tried

        # loop through invalid gadgets 
        # and populate iv_to_requests
        for iv in invalid:

            for ef in iv.effects:
                if ef.type in ["ARITH", "JUMP", "LOAD_S"]:
                    _extract_stk_requests(ef.params[0], iv_to_requests[iv], False)

            for deref_el in iv.unresolved_derefs:
                _extract_stk_requests(deref_el.info["expr"], iv_to_requests[iv], True)

        # generator that tries to yield unbiased sequences 
        # of valid gadgets (or chains) that (hopefully, will) satisfy requests
        # for a specific invalid gadget
        # (round robin + random and fisher-yates)
        # NOTE: currently, only one "sp" replacement is preferred
        #       this is done to avoid unnecessary checks for validity in situations
        #       like Xt <- [SP + SP << 8] or Xt <- [SP * SP] and so on
        def _serve_stk_request(iv: ROP_gadget_ARM64):

            reqs = iv_to_requests[iv]

            if len(reqs) == 0:
                while True:
                    yield []

            MAX_CONSECUTIVE_FAILS = 3
            consecutive_fails = 0

            while True:

                # select which reg is to be replaced with an expression containing sp

                sp_choice_idx = 0
                while len(replace_reg_dict[reqs[sp_choice_idx]][1]) == 0:
                    
                    sp_choice_idx += 1
                    sp_choice_idx %= len(reqs)

                sp_choice_reg = reqs[sp_choice_idx]

                # select the rest of the replacements

                seq: List[ROP_chain_ARM64 | ROP_gadget_ARM64] = []
                seq.append(random.choice(replace_reg_dict[sp_choice_reg][1]))

                for req in reqs:

                    if req == sp_choice_reg:
                        continue 

                    # len(seq) <= len(reqs) which is (very) small, 
                    # so a for in a for is not a problem
                    
                    already_chosen = False
                    for chosen in seq:

                        if chosen in replace_reg_dict[req][3] or \
                            chosen in replace_reg_dict[req][2]:

                            already_chosen = True
                            break

                    if already_chosen is True:
                        continue

                    if len(replace_reg_dict[req][0]) == 0:
                        seq.append(random.choice(replace_reg_dict[req][1]))
                    else:
                        seq.append(random.choice(replace_reg_dict[req][0]))

                # check stack size limits

                stack_size = 0
                for v in seq:
                    stack_size += v.get_stack_size()

                if stack_size > Effect_ARM64.VALIDATION_SEARCH_MAX_STACK_SIZE:

                    consecutive_fails += 1
                    if consecutive_fails > MAX_CONSECUTIVE_FAILS:
                        return None

                    continue

                # randomize joining order

                for i in range(len(seq) - 1):
                    j = random.randint(i, len(seq) - 1)
                    
                    aux = seq[i]
                    seq[i] = seq[j]
                    seq[j] = aux

                # check if it has been tried before

                tseq = tuple(seq)
                if tseq in iv_to_tested[iv]:

                    consecutive_fails += 1
                    if consecutive_fails > MAX_CONSECUTIVE_FAILS:
                        return None

                    continue
                
                consecutive_fails = 0

                iv_to_tested[iv].add(tseq)
                yield seq

        serve_request = {iv: _serve_stk_request(iv) for iv in invalid}
        # dictionary that contains _serve_request() generators

        # in fast mode, only one element is yielded
        # in exhaust mode, all possibilities are yielded
        def serve_request_bymode(iv: ROP_gadget_ARM64, mode):
            
            try:
            
                if mode == "fast":
                    yield next(serve_request[iv])

                elif mode == "exhaust":
                    yield from serve_request[iv]

            except StopIteration:
                return None

        # the gs / chs in this set were already tested for advertisement
        # (only for optimization purposes)
        already_advertised = set()

        # TODO rem after debug
        cntnew = 0

        new_validated = True
        while new_validated:

            # print("another loop")

            new_validated = False

            # loop through valid gadgets / chains, to "advertise" their effects
            for v in valid:
                if v not in already_advertised:

                    for ef in v.effects:
                        if ef.type in ["LOAD_CT", "LOAD_S", "MOV_RR", "ARITH"]:

                            ok_to_advertise, contains_sp = _advertisement_check(ef.params[0])
                            if ok_to_advertise is True:
                                
                                if contains_sp is False:
                                    replace_reg_dict[ef.destination_element.info["reg_name"]][0].append(v)
                                    replace_reg_dict[ef.destination_element.info["reg_name"]][2].add(v)
                                else:
                                    replace_reg_dict[ef.destination_element.info["reg_name"]][1].append(v)
                                    replace_reg_dict[ef.destination_element.info["reg_name"]][3].add(v)

                    already_advertised.add(v)

            # loop through invalid gadgets, try to join with valid gadgets / chains
            iv: ROP_gadget_ARM64
            validated_idx = set()
            for iv_idx, iv in enumerate(invalid):

                # check if registers can be replaced
                
                replaceable = True
                replaceable_w_sp = False
                
                reqs = iv_to_requests[iv]   
                for req in reqs:

                    if len(replace_reg_dict[req][0]) == 0 and \
                        len(replace_reg_dict[req][1]) == 0:

                        replaceable = False
                        break

                    if len(replace_reg_dict[req][1]) > 0:
                        replaceable_w_sp = True

                if replaceable is False or \
                    replaceable_w_sp is False:

                    continue

                # try to replace regs
                
                seq: List[ROP_gadget_ARM64 | ROP_chain_ARM64]
                for seq in serve_request_bymode(iv, mode):
                    
                    if seq is None:
                        break

                    if len(seq) == 0:
                        raise Exception("unexpected len(seq) == 0")

                    candidate_ch = ROP_chain_ARM64.convert(seq[0].duplicate()[0])
                    for v in seq[1:]:

                        candidate_ch_aux = candidate_ch.join(ROP_chain_ARM64.convert(v))

                        if candidate_ch_aux is None:
                            candidate_ch = None
                            break

                        candidate_ch.remove_stack_ids()
                        candidate_ch = candidate_ch_aux

                    iv_aux = ROP_chain_ARM64.convert(iv.duplicate()[0])
                    candidate_ch_aux = candidate_ch.join(iv_aux)

                    if candidate_ch_aux is not None:
                        candidate_ch.remove_stack_ids()

                    candidate_ch = candidate_ch_aux

                    if candidate_ch is None:
                        continue

                    # validity of stack access and jumps have already been recalculated
                    # inside joins
                    
                    # outcome of validity results

                    if candidate_ch.valid_stack_access is True:
                        
                        # TODO rem after debug
                        cntnew += 1

                        # assert(len(candidate_ch.unresolved_derefs) == 0)

                        if candidate_ch.valid_jump is True:

                            new_validated = True
                            valid.append(candidate_ch)

                        elif candidate_ch.valid_jump is False:
                            valid_stack_acc_only.append(candidate_ch)

                        # we are satisfied with at least one validation
                        # per invalid gadget
                        # (to avoid an explosion in the number of new chains)
                        validated_idx.add(iv_idx)

                    else:
                        candidate_ch.remove_stack_ids()

            # eliminate invalid gadgets that participate in at least
            # one newly built valid chain
            old_invalid = invalid
            invalid = []

            for iv_idx in range(len(old_invalid)):

                if iv_idx not in validated_idx:
                    invalid.append(old_invalid[iv_idx])

        # TODO rem after debug
        print(f"done validating stack {cntnew} {len(valid_stack_acc_only)}")

        # step 3) 
        # try to validate jumps
        # (analogous with step 2, but without treating sp separately)
        
        # actualize invalid (stack acc valid, jump invalid)
        invalid = valid_stack_acc_only
        for g in self.gadgets:

            if g.valid_stack_access is True and g.valid_jump is False:
                invalid.append(g)

        print(f"trying to validate jump for {len(invalid)} gadgets")

        replace_reg_dict = {reg: [[], set()] for reg in Platform.ARM64.SUPPORTED_REGS}
        # {reg: [
        #        [list of gadgets whose effect with dest elem == reg does not contain other reg_in arguments),
        #        (set of elements from the previous list)
        #       ]
        # }

        iv_to_requests = {iv: [] for iv in invalid}
        # {invalid gadget: [regs to replace]}

        iv_to_tested = {iv: set() for iv in invalid}
        # {invalid gadget: set((g0, g1, ...), ...)}
        # contains ordered join combinations for the current invalid gadget
        # that were previously tried

        # loop through invalid gadgets 
        # and populate iv_to_requests
        for iv in invalid:

            for ef in iv.effects:
                if ef.type == "JUMP":
                    _extract_jmp_requests(ef.params[0], iv_to_requests[iv])

        # almost the same as the "validate stack access" version
        def _serve_jmp_request(iv: ROP_gadget_ARM64):

            reqs = iv_to_requests[iv]

            if len(reqs) == 0:
                while True:
                    yield []

            MAX_CONSECUTIVE_FAILS = 3
            consecutive_fails = 0

            while True:

                # select the replacements

                seq: List[ROP_chain_ARM64 | ROP_gadget_ARM64] = []
                for req in reqs:
                    
                    already_chosen = False
                    for chosen in seq:

                        if chosen in replace_reg_dict[req][1]:

                            already_chosen = True
                            break

                    if already_chosen is True:
                        continue

                    seq.append(random.choice(replace_reg_dict[req][0]))

                # check stack size limits

                stack_size = 0
                for v in seq:
                    stack_size += v.get_stack_size()

                if stack_size > Effect_ARM64.VALIDATION_SEARCH_MAX_STACK_SIZE:

                    consecutive_fails += 1
                    if consecutive_fails > MAX_CONSECUTIVE_FAILS:
                        return None

                    continue

                # randomize joining order

                for i in range(len(seq) - 1):
                    j = random.randint(i, len(seq) - 1)
                    
                    aux = seq[i]
                    seq[i] = seq[j]
                    seq[j] = aux

                # check if it has been tried before

                tseq = tuple(seq)
                if tseq in iv_to_tested[iv]:

                    consecutive_fails += 1
                    if consecutive_fails > MAX_CONSECUTIVE_FAILS:
                        return None

                    continue
                
                consecutive_fails = 0

                iv_to_tested[iv].add(tseq)
                yield seq

        serve_request = {iv: _serve_jmp_request(iv) for iv in invalid}

        already_advertised = set()

        # FIXME rem after debug
        cntnew = 0

        print(f"invalid before validating jump {len(invalid)}")

        new_validated = True
        while new_validated:

            print("another loop")

            new_validated = False

            # loop through valid gadgets / chains, to "advertise" their effects
            for v in valid:
                if v not in already_advertised:

                    for ef in v.effects:
                        if ef.type in ["LOAD_CT", "LOAD_S", "MOV_RR", "ARITH"]:

                            ok_to_advertise, contains_sp = _advertisement_check(ef.params[0])
                            if ok_to_advertise is True and contains_sp is False:
                                
                                replace_reg_dict[ef.destination_element.info["reg_name"]][0].append(v)
                                replace_reg_dict[ef.destination_element.info["reg_name"]][1].add(v)

                    already_advertised.add(v)

            # loop through invalid gadgets, try to join with valid gadgets / chains
            iv: ROP_gadget_ARM64
            validated_idx = set()
            for iv_idx, iv in enumerate(invalid):

                # check if registers can be replaced
                
                replaceable = True
                
                reqs = iv_to_requests[iv]   

                if len(reqs) == 0:
                    raise Exception("unexpected len(reqs) == 0")

                # sp cannot be replaced by anothing else other than sp + offset
                if "sp" in reqs:
                    continue

                for req in reqs:

                    if len(replace_reg_dict[req][0]) == 0:

                        replaceable = False
                        break

                if replaceable is False:
                    continue

                # try to replace regs
                
                seq: List[ROP_gadget_ARM64 | ROP_chain_ARM64]
                for seq in serve_request_bymode(iv, mode):
                    
                    if seq is None:
                        break

                    if len(seq) == 0:
                        raise Exception("unexpected len(seq) == 0")

                    candidate_ch = ROP_chain_ARM64.convert(seq[0].duplicate()[0])
                    for v in seq[1:]:

                        candidate_ch_aux = candidate_ch.join(ROP_chain_ARM64.convert(v))

                        if candidate_ch_aux is None:
                            candidate_ch = None
                            break

                        candidate_ch.remove_stack_ids()
                        candidate_ch = candidate_ch_aux

                    iv_aux = ROP_chain_ARM64.convert(iv.duplicate()[0])
                    candidate_ch_aux = candidate_ch.join(iv_aux)

                    if candidate_ch_aux is not None:
                        candidate_ch.remove_stack_ids()

                    candidate_ch = candidate_ch_aux

                    if candidate_ch is None:
                        continue
                    
                    # outcome of validity results

                    if candidate_ch.valid_jump is True:

                        if candidate_ch.valid_stack_access is False:
                            raise Exception("unexpected only jump valid gadget")
                        
                        # TODO rem after debug
                        cntnew += 1

                        print("another")
                        # candidate_ch.show()

                        new_validated = True
                        valid.append(candidate_ch)

                        # we are satisfied with at least one validation
                        # per invalid gadget
                        # (to avoid an explosion in the number of new chains)
                        validated_idx.add(iv_idx)

                    else:
                        candidate_ch.remove_stack_ids()

            # eliminate invalid gadgets that participate in at least
            # one newly built valid chain
            old_invalid = invalid
            invalid = []

            for iv_idx in range(len(old_invalid)):

                if iv_idx not in validated_idx:
                    invalid.append(old_invalid[iv_idx])

        print(f"done validating jump {cntnew}")