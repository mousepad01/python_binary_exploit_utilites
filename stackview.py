from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from structured_element import Structured_element

# class to simulate the real stack on which a gadget or chain is executed
class Stack_view:

    # retain all the stack elements id's and their value
    # INCLUDING THE RETURN ADDRESSES
    stack_values = {}

    # stack id to uniquely identify the (same) stack values
    # INCLUDING THE RETURN ADDRESSES
    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[Structured_element] = []

    def push(self, element: Structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = Stack_view.stack_id_cnt

        Stack_view.stack_id_cnt += 1
        Stack_view.stack_values.update({to_deliver: None})
        
        return to_deliver

    # returns a joined stack
    # does NOT deepcopy
    @staticmethod
    def join_stacks(fst: Stack_view, snd: Stack_view):

        res = Stack_view()
        res.elements = fst.elements + snd.elements
        return res

    # returns a joined stack
    # does NOT deepcopy
    # keeps track of first stack's sp position
    @staticmethod
    def join_stacks_overlap(fst: Stack_view, snd: Stack_view, fst_sp: int):

        res = Stack_view()
        res.elements = fst.elements

        for idx_, el in enumerate(snd.elements):
            idx = idx_ + fst_sp

            pass 
            
    # mostly for debugging purposes
    def __str__(self):
        return f"stack view with elements {[str(el) for el in self.elements]}"
