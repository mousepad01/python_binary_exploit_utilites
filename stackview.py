from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from structured_element import Structured_element, Structured_element_ARM64

# class to simulate the real stack on which a gadget or chain is executed
class Stack_view:

    # retain all the stack elements id's and their value
    # including the jump / return addresses
    stack_values = {}

    # used only on ARM64
    # for each stack id, store the associated jump id 
    # (i.e. jump.destination element value, 
    # relative to the gadget / chain in which the jump is found)
    related_jump = {}

    # stack id to uniquely identify the (same) stack values
    # including the jump / return addresses
    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[Structured_element] = []

    def push(self, element: Structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = Stack_view.stack_id_cnt

        Stack_view.stack_id_cnt += 1

        Stack_view.stack_values.update({to_deliver: None})
        Stack_view.related_jump.update({to_deliver: None})
        
        return to_deliver

    # returns a joined stack
    # does NOT deepcopy
    @staticmethod
    def join_stacks(fst: Stack_view, snd: Stack_view):

        res = Stack_view()
        res.elements = fst.elements + snd.elements
        return res

    # returns a joined stack
    # does NOT deepcopy 
    # (fst and snd stacks should NOT BE USED AFTER CALLING THIS METHOD)
    # keeps track of first stack's sp position
    @staticmethod
    def join_stacks_overlap(fst: Stack_view, snd: Stack_view, fst_sp: int, snd_sp: int, jump_idx_offset: int):

        res = Stack_view()
        res.elements = fst.elements

        # {old id: new id}
        old_new_id = {}

        # first, update all second stack elements with jump_idx_offset
        for el in snd.elements:
            
            if el.type == "64b_stack_val" and Stack_view.related_jump[el.info["id"]] is not None:
                Stack_view.related_jump[el.info["id"]] += jump_idx_offset

        # if first stack is behind its sp
        for _ in range(len(res.elements), fst_sp):
            res.elements.append(Structured_element_ARM64.instantiate_structured_element("64b_stack_pad"))

        # overlap region
        for idx_ in range(min(len(res.elements) - fst_sp, len(snd.elements))):
            idx = idx_ + fst_sp

            if res.elements[idx].type == "64b_stack_pad" and \
                snd.elements[idx_].type == "64b_stack_val":

                res.elements[idx] = snd.elements[idx_]

            elif res.elements[idx].type == "64b_stack_val" and \
                snd.elements[idx_].type == "64b_stack_val":

                id_res = res.elements[idx].info["id"]
                id_snd = snd.elements[idx_].info["id"]

                if id_snd is None:

                    Stack_view.stack_values.pop(id_snd, None)
                    old_new_id.update({id_snd: id_res})

                elif id_res is None or \
                    Stack_view.stack_values[id_res] == Stack_view.stack_values[id_snd]:

                    Stack_view.stack_values.pop(id_res, None)
                    old_new_id.update({id_res: id_snd})
                    res.elements[idx].info["id"] = id_snd

                else:

                    for el in res.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.stack_values.pop(el.info["id"], None)

                    for el in snd.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.stack_values.pop(el.info["id"], None)

                    return None, None, None

        # non-overlapping region from snd stack
        res.elements += snd.elements[len(res.elements) - fst_sp:]
        
        return res, old_new_id, fst_sp + snd_sp

    # mostly for debugging purposes
    def __str__(self):
        return f"stack view with elements {[str(el) for el in self.elements]}"
