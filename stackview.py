from __future__ import annotations
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from structured_element import Structured_element, Structured_element_ARM64

# class to simulate the real stack on which a gadget or chain is executed
class Stack_view:

    # retain all the stack elements id's and their value
    # including the jump / return addresses
    stack_values = {}

    # used only on ARM64
    # for each stack id, store the associated jump id 
    # (i.e. jump.destination element value, 
    # relative to the gadget / chain in which the jump is found)
    related_jump = {}

    # stack id to uniquely identify the (same) stack values
    # including the jump / return addresses
    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[Structured_element] = []

    def push(self, element: Structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = Stack_view.stack_id_cnt

        Stack_view.stack_id_cnt += 1

        Stack_view.stack_values.update({to_deliver: None})
        Stack_view.related_jump.update({to_deliver: None})
        
        return to_deliver

    # returns a joined stack
    # does NOT deepcopy
    @staticmethod
    def join_stacks(fst: Stack_view, snd: Stack_view):

        res = Stack_view()
        res.elements = fst.elements + snd.elements
        return res

    # returns a joined stack
    # does NOT deepcopy 
    # (fst and snd stacks should NOT BE USED AFTER CALLING THIS METHOD)
    # keeps track of first stack's sp position
    @staticmethod
    def join_stacks_overlap(fst: Stack_view, snd: Stack_view, fst_sp: int, snd_sp: int):

        res = Stack_view()
        res.elements = fst.elements

        # {old id: new id}
        old_new_id = {}

        # if first stack is behind its sp
        for _ in range(len(res.elements), fst_sp):
            res.elements.append(Structured_element_ARM64.instantiate_structured_element("64b_stack_pad"))

        # overlap region
        for idx_ in range(min(len(res.elements) - fst_sp, len(snd.elements))):
            idx = idx_ + fst_sp

            if res.elements[idx].type == "64b_stack_pad" and \
                snd.elements[idx_].type == "64b_stack_val":

                res.elements[idx] = snd.elements[idx_]

            elif res.elements[idx].type == "64b_stack_val" and \
                snd.elements[idx_].type == "64b_stack_val":

                id_res = res.elements[idx].info["id"]
                id_snd = snd.elements[idx_].info["id"]

                v_res = Stack_view.stack_values[id_res]
                v_snd = Stack_view.stack_values[id_snd]

                j_res = Stack_view.related_jump[id_res]
                j_snd = Stack_view.related_jump[id_snd]

                # NOTE: when joining two different stacks, 
                #       there should be no case in which
                #       stack elements' jumps coincide 
                if j_res is not None and j_res == j_snd:
                    raise Exception(f"jump ids from different gs / chs to be joined coincide: {Stack_view.related_jump[id_res]} and {Stack_view.related_jump[id_snd]}")

                constrain0 = not (j_res is not None and j_snd is not None)
                constrain1 = True if (v_res is None or v_snd is None) else v_res == v_snd
                constrain2 = not ((v_res is None and v_snd is not None and j_res is not None and j_snd is None) or \
                                    (v_res is not None and v_snd is None and j_res is None and j_snd is not None))

                if (constrain0 and constrain1 and constrain2) is False:

                    for el in res.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.del_id(el.info["id"])

                    for el in snd.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.del_id(el.info["id"])

                    return None, None, None

                Stack_view.del_id(id_snd)
                old_new_id.update({id_snd: id_res})

                Stack_view.stack_values[id_res] = v_res if v_res is not None else v_snd
                Stack_view.related_jump[id_res] = j_res if j_res is not None else j_snd

        # non-overlapping region from snd stack
        res.elements += snd.elements[len(res.elements) - fst_sp:]

        # eliminate suffix

        idx_pad = -1
        while res.elements[idx_pad].type == "64b_stack_pad":
            idx_pad -= 1

        idx_pad += 1
        
        if idx_pad < 0:
            res.elements = res.elements[:idx_pad]
        
        return res, old_new_id, fst_sp + snd_sp

    @staticmethod
    def del_id(id_: int):

        Stack_view.stack_values.pop(id_, None)
        Stack_view.related_jump.pop(id_, None)

    # mostly for debugging purposes
    def __str__(self):
        return f"stack view with elements {[str(el) for el in self.elements]}"
