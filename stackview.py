from __future__ import annotations
from typing import List
# both above imports only for type hints

from structured_element import Structured_element

class Stack_view:
    '''
        Class that simulates the real stack on which a gadget or chain is executed
    '''

    stack_values = {}
    '''
        stack id -> value (integer)
    '''

    related_jump = {}
    '''
        stack id -> associated jump id
    '''

    stack_id_cnt = 0

    def __init__(self):
        self.elements: List[Structured_element] = []

    def push(self, element: Structured_element):
        self.elements.append(element)

    @staticmethod
    def get_elem_id():

        to_deliver = Stack_view.stack_id_cnt

        Stack_view.stack_id_cnt += 1

        Stack_view.stack_values.update({to_deliver: None})
        Stack_view.related_jump.update({to_deliver: None})
        
        return to_deliver

    @staticmethod
    def join_stacks(fst: Stack_view, snd: Stack_view, fst_sp: int, snd_sp: int):
        '''
            Join two stacks\n
            Returns None if failed\n
            NOTE: fst and snd stacks should not be used after calling this method
        '''

        res = Stack_view()
        res.elements = fst.elements

        # {old id: new id}
        old_new_id = {}

        # if first stack is behind its sp
        for _ in range(len(res.elements), fst_sp):
            res.elements.append(Structured_element.instantiate_structured_element("64b_stack_pad"))

        # overlap region
        for idx_ in range(min(len(res.elements) - fst_sp, len(snd.elements))):
            idx = idx_ + fst_sp

            if res.elements[idx].type == "64b_stack_pad" and \
                snd.elements[idx_].type == "64b_stack_val":

                res.elements[idx] = snd.elements[idx_]

            elif res.elements[idx].type == "64b_stack_val" and \
                snd.elements[idx_].type == "64b_stack_val":

                id_res = res.elements[idx].info["id"]
                id_snd = snd.elements[idx_].info["id"]

                v_res = Stack_view.stack_values[id_res]
                v_snd = Stack_view.stack_values[id_snd]

                j_res = Stack_view.related_jump[id_res]
                j_snd = Stack_view.related_jump[id_snd]

                # NOTE: when joining two different stacks, 
                #       there should be no case in which
                #       stack elements' jumps coincide 
                if j_res is not None and j_res == j_snd:
                    raise Exception(f"jump ids from different gs / chs to be joined coincide: {Stack_view.related_jump[id_res]} and {Stack_view.related_jump[id_snd]}")

                constrain0 = not (j_res is not None and j_snd is not None)
                constrain1 = True if (v_res is None or v_snd is None) else v_res == v_snd
                constrain2 = not ((v_res is None and v_snd is not None and j_res is not None and j_snd is None) or \
                                    (v_res is not None and v_snd is None and j_res is None and j_snd is not None))

                if (constrain0 and constrain1 and constrain2) is False:

                    for el in res.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.del_id(el.info["id"])

                    for el in snd.elements:
                        if el.type == "64b_stack_val":
                            Stack_view.del_id(el.info["id"])

                    return None, None, None

                Stack_view.del_id(id_snd)
                old_new_id.update({id_snd: id_res})

                Stack_view.stack_values[id_res] = v_res if v_res is not None else v_snd
                Stack_view.related_jump[id_res] = j_res if j_res is not None else j_snd

        # non-overlapping region from snd stack
        res.elements += snd.elements[len(res.elements) - fst_sp:]

        # eliminate padding suffix (optional???)

        idx_pad = -1
        while res.elements[idx_pad].type == "64b_stack_pad":
            idx_pad -= 1

        idx_pad += 1
        
        if idx_pad < 0:
            res.elements = res.elements[:idx_pad]
        
        return res, old_new_id, fst_sp + snd_sp

    @staticmethod
    def del_id(id_: int):

        Stack_view.stack_values.pop(id_, None)
        Stack_view.related_jump.pop(id_, None)

    # mostly for debugging purposes
    def __str__(self):
        return f"stack view with elements {[str(el) for el in self.elements]}"
