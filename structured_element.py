from copy import deepcopy

# TODO add support for mul and shift left / right operations

# class that stores any kind of entity that can have a value
# eg. stack bytes, registers, register value "snapshot" at some point of execution, and so on
# the design choice of using such an ambiguous class 
# is based on the fact that the implementation is way easier to understand, to extend, or to modify
# compared to the situation in which every use case of this class would get its own class
class Structured_element:

    # dictionary of currently used structured elements types
    # {"ELEMENT_TYPE": [info param 1 type / info param 1 name, ...]}
    # NOTE: the fields described here only represent the keys of the self.info dict
    #       populating it with the corresponding (valid) values is the programmer's responsability
    ELEMENT_TYPES = {"64b_stack_val": ["id"],               # integer value from the stack, pointed by an id
                        "ct_val": ["value"],                # integer constant (non-stack / non-register) value

                        "reg_in": ["reg_name"],             # register value at the beginning of a gadget / chain
                        "reg_out": ["reg_name"],            # register value after executing a gadget / chain
                        
                        "add": ["term_1", "term_2"],        # arithmetic operations (can be recursive)
                        "sub": ["term_1", "term_2"],                    
                        "and": ["term_1", "term_2"], 
                        "or": ["term_1", "term_2"],
                        "xor": ["term_1", "term_2"],
                        "neg": ["term_1", "term_2"],        # LOGICAL NOT; also, term2 will always be None

                        "64b_stack_pad": []                 # marks padding (random value) for the stack view
                                                            # in some situations, it is seen as a free stack slot
                                                            # that can be "claimed" and transformed into a 64b_stack_val
                    }
    
    NON_OP = {"64b_stack_val", "ct_val", "reg_in", "reg_out"}

    def __deepcopy__(self, memo):

        copy = Structured_element(self.type)
        memo[id(self)] = copy

        if self.is_op():
            
            copy.info["term_1"] = deepcopy(self.info["term_1"], memo)
            copy.info["term_2"] = deepcopy(self.info["term_2"], memo)

        elif self.type in self.NON_OP:

            attr_name = self.ELEMENT_TYPES[self.type][0]
            copy.info[attr_name] = self.info[attr_name]

        return copy
    
    @classmethod
    def instantiate_structured_element(cls, element_type: str):

        if element_type not in cls.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate Structured_element with type {element_type}")
        
        element = cls(element_type)
        for info_field in cls.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

    def is_op(self):
        return self.type in ["add", "sub", "and", "or", "xor", "neg"]

    # mostly for debugging purposes
    def __str__(self):
        info_s = {str(k): str(v) for k, v in self.info.items()}
        return f"element type {self.type}, info {info_s}"

class Structured_element_ARM64(Structured_element):

    # NOTE: deref means the value that will reside in that expression
    #       will be dereferenced, before extracting the actual value
    ELEMENT_TYPES = {"64b_stack_val": ["id"],               
                        "ct_val": ["value"],                

                        "reg_in": ["reg_name"],            
                        "reg_out": ["reg_name"], 

                        "deref": ["expr"],           
                        
                        "add": ["term_1", "term_2"],        
                        "sub": ["term_1", "term_2"],                    
                        "and": ["term_1", "term_2"], 
                        "or":  ["term_1", "term_2"],
                        "xor": ["term_1", "term_2"],
                        "neg": ["term_1", "term_2"],
                        "mul": ["term_1", "term_2"],       
                        "lsh": ["term_1", "term_2"],                    
                        "rsh": ["term_1", "term_2"],     

                        "64b_stack_pad": []                 
                    }

    OPS = {"add": lambda x, y: x + y,
            "sub": lambda x, y: x - y,
            "and": lambda x, y: x & y,
            "or": lambda x, y: x | y,
            "xor": lambda x, y: x ^ y,
            "neg": lambda x, _: ~x,
            "mul": lambda x, y: x * y,
            "lsh": lambda x, y: x << y,
            "rsh": lambda x, y: x >> y
        }

    NON_OP = {"64b_stack_val", "ct_val", "reg_in", "reg_out"}

    def __deepcopy__(self, memo):

        copy = Structured_element_ARM64(self.type)
        memo[id(self)] = copy

        if self.is_op():
            
            copy.info["term_1"] = deepcopy(self.info["term_1"], memo)
            copy.info["term_2"] = deepcopy(self.info["term_2"], memo)

        elif self.type == "deref":
            copy.info["expr"] = deepcopy(self.info["expr"], memo)

        elif self.type in self.NON_OP:

            attr_name = self.ELEMENT_TYPES[self.type][0]
            copy.info[attr_name] = self.info[attr_name]

        return copy

    def is_op(self):
        return self.type in ["add", "sub", "and", "or", "xor", "neg",
                                "lsh", "rsh", "mul"]
