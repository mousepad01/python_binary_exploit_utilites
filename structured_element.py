from copy import deepcopy

class Structured_element:
    '''
        Class that stores atomic components for the internal representation of gadgets and chains\n
        Check the documentation for more info
    '''

    ELEMENT_TYPES = {"64b_stack_val": ["id"],               
                        "ct_val": ["value"],                

                        "reg_in": ["reg_name"],            
                        "reg_out": ["reg_name"], 

                        "deref": ["expr"],           
                        
                        "add": ["term_1", "term_2"],        
                        "sub": ["term_1", "term_2"],                    
                        "and": ["term_1", "term_2"], 
                        "or":  ["term_1", "term_2"],
                        "xor": ["term_1", "term_2"],
                        "neg": ["term_1", "term_2"],
                        "mul": ["term_1", "term_2"],       
                        "lsh": ["term_1", "term_2"],                    
                        "rsh": ["term_1", "term_2"],     

                        "64b_stack_pad": []                 
                    }

    OPS = {"add": lambda x, y: x + y,
            "sub": lambda x, y: x - y,
            "and": lambda x, y: x & y,
            "or": lambda x, y: x | y,
            "xor": lambda x, y: x ^ y,
            "neg": lambda x, _: ~x,
            "mul": lambda x, y: x * y,
            "lsh": lambda x, y: x << y,
            "rsh": lambda x, y: x >> y
        }

    NON_OP = {"64b_stack_val", "ct_val", "reg_in", "reg_out"}

    def __deepcopy__(self, memo):

        copy = Structured_element(self.type)
        memo[id(self)] = copy

        if self.is_op():
            
            copy.info["term_1"] = deepcopy(self.info["term_1"], memo)
            copy.info["term_2"] = deepcopy(self.info["term_2"], memo)

        elif self.type == "deref":
            copy.info["expr"] = deepcopy(self.info["expr"], memo)

        elif self.type in self.NON_OP:

            attr_name = self.ELEMENT_TYPES[self.type][0]
            copy.info[attr_name] = self.info[attr_name]

        return copy

    @classmethod
    def instantiate_structured_element(cls, element_type: str):

        if element_type not in cls.ELEMENT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate Structured_element with type {element_type}")
        
        element = cls(element_type)
        for info_field in cls.ELEMENT_TYPES[element_type]:
            element.info.update({info_field: None})

        return element
    
    def __init__(self, element_type: str):
        self.type = element_type
        self.info = {}

    def is_op(self):
        return self.type in ["add", "sub", "and", "or", "xor", "neg",
                                "lsh", "rsh", "mul"]

    # mostly for debugging purposes
    def __str__(self):
        info_s = {str(k): str(v) for k, v in self.info.items()}
        return f"element type {self.type}, info {info_s}"