from __future__ import annotations
from ast import Str
from typing import Dict, Generator, List, Tuple, Set
# both above imports only for type hints

from copy import deepcopy
from rand import random

import rop_platform
from stackview import Stack_view
from structured_element import Structured_element, Structured_element_ARM64
from utils import _is_int

from capstone import *
import z3

MASK_32b = 0xffffffff

# class to store the semantics of all the gadgets
# again, some ambiguity is intentionally provided, for same reasoning as the above mentioned classes
# but it has some constrains:
#   * everyeffecthas an id that should be part of an implementation convention
#   * the Effect, if seen as an operation, stores the result value in a single destination element (currently, by convention, only registers)
class Effect:

    # if true, arith match is done by thecking operation trees, method invariant only to commutativity
    #           no false positives, lots of false negatives, 
    # if false, arith match is done by giving random inputs to registers,
    #           and eventually tring to adjust the checked effect stack values to match
    #           some false positives, no false negatives
    ARITH_EXACT_MATCH = False

    # indicates the number of (random) tests to be done
    # ignored if ARITH_EXACT_MATCH is True
    ARITH_P_TEST_CNT = 30

    # dictionary of currently used effect types
    # {"EFFECT_TYPE": (destination_element type, [param1 type, ...]), ...}
    # NOTE: ARITH type has parameter type configurable: "<op>"
    EFFECT_TYPES = {"LOAD_S": ("reg_out", ["64b_stack_val"]),       # load value in register from the stack (sp value increase NOT included)
                    "LOAD_CT": ("reg_out", ["ct_val"]),             # load value that is constant (that does not originate from registers or stack)
                    "MOV_RR": ("reg_out", ["reg_in"]),              # copying value from one register to another
                    "ARITH": ("reg_out", []),                       # operations (add, sub, bitewise operations, etc) - the PARAMS are not included
                    "ADD_SP": (None, ["ct_val"]),                   # separate effect indicating incrementing sp (with a constant value only)
                    "NO_OP": (None, []),                            # no operation
                    }

    Elem = Structured_element
    Platform = rop_platform.Platform.X86_64

    def __deepcopy__(self, memo):

        copy = Effect(self.type, None, [])
        memo[id(self)] = copy

        copy.destination_element = deepcopy(self.destination_element, memo)

        if self.params != []:
            copy.params = [deepcopy(self.params[0], memo)]

        return copy

    @classmethod
    def instantiate_effect(cls, effect_type: str):
     
        if effect_type not in cls.EFFECT_TYPES.keys():
            raise RuntimeError(f"Cannot automatically instantiate Effect with type {effect_type}")

        effect = cls(effect_type, None, [])

        dest_type, param_type_list = cls.EFFECT_TYPES[effect_type]

        if dest_type is not None:
            effect.destination_element = cls.Elem.instantiate_structured_element(dest_type)
        
        for param_type in param_type_list:
            effect.params.append(cls.Elem.instantiate_structured_element(param_type))

        return effect

    # NOTE the following methods were created with a bias towards x86
    #       the arm64-specific code will also use them, but with additional changes
    #       after the make_...() call, so pay attention to that

    # common code lines between any location (at least when interpreting instructions)
    # for creating an effect that marks an arithmetic operation with a constant
    # NOTE: no checks are done
    @classmethod
    def make_arith_ct_effect(cls, op_type: str, dest_reg_name: str, constant: int):

        arith_op_ct_effect = cls.instantiate_effect("ARITH")
        arith_op_ct_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_ct_effect.params.append(cls.Elem.instantiate_structured_element(op_type))

        arith_op_ct_effect.params[0].info["term_1"] =  cls.Elem.instantiate_structured_element("reg_in")
        arith_op_ct_effect.params[0].info["term_2"] =  cls.Elem.instantiate_structured_element("ct_val")
        arith_op_ct_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_ct_effect.params[0].info["term_2"].info["value"] = constant

        #_existent_constants.add(constant)

        return arith_op_ct_effect

    # same as make_arith_ct_effect but for operations with (only) registers
    # NOTE: no checks are done
    @classmethod
    def make_arith_reg_effect(cls, op_type: str, dest_reg_name: str, src_reg_name: str):

        arith_op_reg_effect = cls.instantiate_effect("ARITH")
        arith_op_reg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_op_reg_effect.params.append(cls.Elem.instantiate_structured_element(op_type))

        arith_op_reg_effect.params[0].info["term_1"] =  cls.Elem.instantiate_structured_element("reg_in")
        arith_op_reg_effect.params[0].info["term_2"] =  cls.Elem.instantiate_structured_element("reg_in")
        arith_op_reg_effect.params[0].info["term_1"].info["reg_name"] = dest_reg_name
        arith_op_reg_effect.params[0].info["term_2"].info["reg_name"] = src_reg_name

        return arith_op_reg_effect

    @classmethod
    def make_arith_custom_effect(cls, dest_reg_name: str, custom_element: Structured_element):

        arith_effect = cls.instantiate_effect("ARITH")
        arith_effect.destination_element.info["reg_name"] = dest_reg_name
        arith_effect.params.append(custom_element)

        return arith_effect

    @classmethod
    def make_load_ct_effect(cls, dest_reg_name: str, constant: int):

        load_ct_effect = cls.instantiate_effect("LOAD_CT")
        load_ct_effect.destination_element.info["reg_name"] = dest_reg_name
        load_ct_effect.params[0].info["value"] = constant

        #_existent_constants.add(constant)

        return load_ct_effect

    @classmethod
    def make_load_s_effect(cls, dest_reg_name: str):

        load_s_effect = cls.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name
        load_s_effect.params[0].info["id"] = Stack_view.get_elem_id()

        return load_s_effect

    @classmethod
    def make_mov_rr_effect(cls, dest_reg_name: str, src_reg_name: str):

        mov_rr_effect = cls.instantiate_effect("MOV_RR")
        mov_rr_effect.destination_element.info["reg_name"] = dest_reg_name
        mov_rr_effect.params[0].info["reg_name"] = src_reg_name

        return mov_rr_effect

    @classmethod
    def make_neg_effect(cls, dest_reg_name: str, src_reg_name: str = None):

        arith_neg_effect = cls.instantiate_effect("ARITH")
        arith_neg_effect.destination_element.info["reg_name"] = dest_reg_name

        arith_neg_effect.params.append(cls.Elem.instantiate_structured_element("neg"))

        if src_reg_name is None:
            to_negate = dest_reg_name
        else:
            to_negate = src_reg_name

        arith_neg_effect.params[0].info["term_1"] =  cls.Elem.instantiate_structured_element("reg_in")
        arith_neg_effect.params[0].info["term_1"].info["reg_name"] = to_negate

        return arith_neg_effect

    @classmethod
    def make_add_sp_effect(cls, constant: int):

        add_sp_effect = cls.instantiate_effect("ADD_SP")
        add_sp_effect.params[0].info["value"] = constant

        # this constant is NOT added into known constants cache
        # because is limited in interacting only with SP

        return add_sp_effect

    def __init__(self, effect_type: str, destination_element: Structured_element, params: List[Structured_element]):

        self.type: str = effect_type
        self.destination_element: Structured_element = destination_element
        self.params: List[Structured_element] = params

    # currently uses Z3: https://github.com/Z3Prover/z3
    def _match_arith(self, checked_ef: Effect):

        if self.destination_element.info["reg_name"] != checked_ef.destination_element.info["reg_name"]:
            return False

        # possible type pairs (wanted_ef, checked_ef):
        # ARITH, ARITH
        # MOV_RR, ARITH
        # LOAD_CT, ARITH
        # NOTE: if the WANTED EFFECT is of type ARITH, it is assumed it does NOT contain stack elements

        # match the operation trees, taking into account only commutativity of some operations
        def _tree_match(wanted_ef: Structured_element, checked_ef: Structured_element):

            if (wanted_ef is None) and (checked_ef is None):
                return True

            if wanted_ef.type != checked_ef.type:
                return False
            
            if wanted_ef.type == "64b_stack_val":

                if (Stack_view.stack_values[checked_ef.info["id"]] == Stack_view.stack_values[wanted_ef.info["id"]]) \
                    or (Stack_view.stack_values[checked_ef.info["id"]] is None):

                    if checked_ef.info["id"] != wanted_ef.info["id"]:

                        val = Stack_view.stack_values[wanted_ef.info["id"]]
                        Stack_view.del_id(wanted_ef.info["id"])
                        
                        wanted_ef.info["id"] = checked_ef.info["id"]
                        Stack_view.stack_values[checked_ef.info["id"]] = val

                    return True

                else:
                    return False

            if wanted_ef.type == "reg_in":
                return wanted_ef.info["reg_name"] == checked_ef.info["reg_name"]

            if wanted_ef.type == "ct_val":
                return wanted_ef.info["value"] == checked_ef.info["value"]

            if wanted_ef.type in ["sub", "neg"]:
                return _tree_match(wanted_ef.info["term_1"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_2"], checked_ef.info["term_2"])

            if wanted_ef.is_op():
                return (_tree_match(wanted_ef.info["term_1"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_2"], checked_ef.info["term_2"])) or\
                        (_tree_match(wanted_ef.info["term_2"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_1"], checked_ef.info["term_2"]))

            raise RuntimeError(f"trying to match trees with unknown types: {wanted_ef.type}")

        # probabilistic match
        def _probabilistic_match(wanted_ef: Effect, checked_ef: Effect):

            stack_ids = set()
            reg_in_elements = {}

            # in case of stack assignments, z3 solver is used
            z3_solver = z3.Solver()
            
            # simulates the execution of the arith Effect
            def _simulate(op_element: Structured_element, local_stack_values: Dict[int, int], reg_start_values: Dict[str, int]):
        
                if op_element.type == "64b_stack_val":
                    return local_stack_values[op_element.info["id"]]

                if op_element.type == "ct_val":
                    return op_element.info["value"]

                if op_element.type == "reg_in":
                    return reg_start_values[op_element.info["reg_name"]]

                if op_element.type == "add":
                    return _simulate(op_element.info["term_1"], local_stack_values, reg_start_values) +\
                            _simulate(op_element.info["term_2"], local_stack_values, reg_start_values)
                
                if op_element.type == "sub":
                    return _simulate(op_element.info["term_1"], local_stack_values, reg_start_values) -\
                            _simulate(op_element.info["term_2"], local_stack_values, reg_start_values)

                if op_element.type == "and":
                    return _simulate(op_element.info["term_1"], local_stack_values, reg_start_values) &\
                            _simulate(op_element.info["term_2"], local_stack_values, reg_start_values)

                if op_element.type == "or":
                    return _simulate(op_element.info["term_1"], local_stack_values, reg_start_values) |\
                            _simulate(op_element.info["term_2"], local_stack_values, reg_start_values)

                if op_element.type == "xor":
                    return _simulate(op_element.info["term_1"], local_stack_values, reg_start_values) ^\
                            _simulate(op_element.info["term_2"], local_stack_values, reg_start_values)

                if op_element.type == "neg":
                    return ~(_simulate(op_element.info["term_1"], local_stack_values, reg_start_values))

            # function that folds over the ARITH expression tree 
            # and updates the z3 solver
            _aux_id = 0
            def _convert_to_z3_expr(el: Structured_element):
                
                nonlocal _aux_id

                if el.type == "64b_stack_val":

                    val = Stack_view.stack_values[el.info["id"]]
                    if val is not None:

                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        _aux_id += 1
                        z3_solver.add(conv_el == val)

                        return conv_el
                    
                    else:
                        return z3.BitVec(f"stack{el.info['id']}", 64)

                else:

                    conv_el = z3.BitVec(f"c{_aux_id}", 64)
                    _aux_id += 1
                    
                    if el.type == "ct_val":
                        z3_solver.add(conv_el == el.info["value"])

                    elif el.type == "reg_in":
                        z3_solver.add(conv_el == reg_in_elements[el.info["reg_name"]])

                    elif el.type == "neg":
                        
                        t = _convert_to_z3_expr(el.info["term_1"])
                        z3_solver.add(conv_el == ~t)

                    elif el.is_op():

                        t1 = _convert_to_z3_expr(el.info["term_1"])
                        t2 = _convert_to_z3_expr(el.info["term_2"])

                        if el.type == "add":
                            z3_solver.add(conv_el == t1 + t2)

                        elif el.type == "sub":
                            z3_solver.add(conv_el == t1 - t2)

                        elif el.type == "and":
                            z3_solver.add(conv_el == t1 & t2)

                        elif el.type == "or":
                            z3_solver.add(conv_el == t1 | t2)

                        elif el.type == "xor":
                            z3_solver.add(conv_el == t1 ^ t2)

                    return conv_el

            # method that determines whether the checked expression has unassigned stack elements or not
            # and if it has, initialize them as keys in the stack_elements_assignments dictionary
            # also, it retains the reg_in elements used
            def _check_stack_elements(el: Structured_element):

                if el is None:
                    return False

                if el.type == "64b_stack_val":
                    
                    if Stack_view.stack_values[el.info["id"]] is None:

                        stack_ids.add(el.info["id"])
                        return True

                    return False

                elif el.type == "reg_in":

                    reg_in_elements.update({el.info["reg_name"]: None})
                    return False

                elif el.type == "ct_val":
                    return False

                elif el.is_op():

                    checked_1 = _check_stack_elements(el.info["term_1"])
                    checked_2 = _check_stack_elements(el.info["term_2"])

                    return checked_1 or checked_2

                raise RuntimeError(f"unknown element type {el.type} when trying to match arith")

            stack_elements_found_inwanted = _check_stack_elements(wanted_ef.params[0])
            if stack_elements_found_inwanted is True:
                raise RuntimeError("stack element found in wanted Effect")

            stack_elements_found = _check_stack_elements(checked_ef.params[0])

            for _ in range(Effect.ARITH_P_TEST_CNT):

                for reg_in in reg_in_elements.keys():
                    reg_in_elements[reg_in] = random.randint(0, 2 ** 64)

                wanted_ef_val = 0

                if wanted_ef.type == "MOV_RR":
                    wanted_ef_val = reg_in_elements[wanted_ef.params[0].info["reg_name"]]

                elif wanted_ef.type == "LOAD_CT":
                    wanted_ef_val = wanted_ef.params[0].info["value"]

                elif wanted_ef.type == "ARITH":
                    wanted_ef_val = _simulate(wanted_ef.params[0], Stack_view.stack_values, reg_in_elements)

                # the checked_ef has no stack id to be assigned a value, only to compute the result based on reg_in values
                if stack_elements_found is False:

                    checked_ef_val = _simulate(checked_ef.params[0], Stack_view.stack_values, reg_in_elements)
                    if checked_ef_val != wanted_ef_val:
                        return False

                else:

                    if self.Platform.use_z3 is True:

                        # there are unknown stack values that need to be assigned a value
                        # before proceeding in checking the matching

                        z3_expr = _convert_to_z3_expr(checked_ef.params[0])
                        z3_solver.add(z3_expr == wanted_ef_val)

                    else:
                        return False

            # checking for stack element possible assignments 
            # so that checked_ef matches wanted_ef
            if stack_elements_found is True:

                if z3_solver.check() == z3.sat:

                    sm = z3_solver.model()
                    for stack_elem_id in stack_ids:

                        z3_stack_elem = z3.BitVec(f"stack{stack_elem_id}", 64)
                        val = sm[z3_stack_elem]

                        if val is not None:
                            Stack_view.stack_values[stack_elem_id] = val.as_long()
                        #else:
                            # irrelevant element, add some padding
                         #   Stack_view.stack_values[stack_elem_id] = int.from_bytes(b'A' * 8, 'little')

                else:
                    return False

            return True
        
        if Effect.ARITH_EXACT_MATCH is True:
            return _tree_match(self, checked_ef)
        else:
            return _probabilistic_match(self, checked_ef)

    # function that matches two effects
    # NOTE: when matching with LOAD_S effects, self stack element ID is changed
    def match(self, g_effect: Effect):

        if self.destination_element.info["reg_name"] != g_effect.destination_element.info["reg_name"]:
            return False

        if self.type == "ARITH" or g_effect.type == "ARITH":
            return self._match_arith(g_effect)
        
        # LOAD_S is intentionally restricted to only other LOAD_S effects, for an efficient/ fast search
        # if one wants to have all the possible ways of loading a value in a register, LOAD_CT matching should be chosen instead
        # NOTE: unused???
        if self.type == "LOAD_S":
            
            if g_effect.type != "LOAD_S":
                return False
            
            # either the wanted effect has the same value as the stack element (none or int value)
            # or the wanted effect has a concrete value and the stack element is none, case in which stack value is assigned the wanted one
            # or both the stack and the wanted elements have non-none values, but are different, case in which it fails
            # in any case it succeeds, the wanted value id <- the stack id
            if (Stack_view.stack_values[g_effect.params[0].info["id"]] == Stack_view.stack_values[self.params[0].info["id"]]) \
                or (Stack_view.stack_values[g_effect.params[0].info["id"]] is None):

                if g_effect.params[0].info["id"] != self.params[0].info["id"]:

                    val = Stack_view.stack_values[self.params[0].info["id"]]
                    Stack_view.del_id(self.params[0].info["id"])

                    self.params[0].info["id"] = g_effect.params[0].info["id"]
                    Stack_view.stack_values[g_effect.params[0].info["id"]] = val

                return True

            else:
                return False

        elif self.type == "LOAD_CT":
            
            if g_effect.type == "LOAD_CT":

                if g_effect.params[0].info["value"] != self.params[0].info["value"]:
                    return False
                return True

            elif g_effect.type == "LOAD_S":

                if (Stack_view.stack_values[g_effect.params[0].info["id"]] == self.params[0].info["value"]) \
                    or (Stack_view.stack_values[g_effect.params[0].info["id"]] is None):

                    Stack_view.stack_values[g_effect.params[0].info["id"]] = self.params[0].info["value"]
                    return True
            
                return False

            return False

        elif self.type == "MOV_RR":
            
            if g_effect.type == "MOV_RR":

                if self.params[0].info["reg_name"] != g_effect.params[0].info["reg_name"]:
                    return False
                return True

            return False

        raise RuntimeError(f"trying to match types {self.type}, {g_effect.type}")
    
    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    @classmethod
    def analyse_instr(cls, instr: CsInsn):

        # checks whether the instruction effects 
        # are ignored (from the point of view of this algorithm)
        # and are treated as NOP
        def _ignored_instr(instr: CsInsn):

            if instr.mnemonic in cls.Platform.IGNORED_INSTR_MNEMONICS:
                return True

            return False

        # separate the arguments from instr.op_str
        def _get_2_args(op_str: str):

            mov_args = op_str.split(",")
                
            if len(mov_args) != 2:
                return None, None

            dest = mov_args[0].strip()
            src = mov_args[1].strip()

            return dest, src

        try:

            instr_effects = []

            mnemonic = instr.mnemonic

            if mnemonic == "pop":

                if instr.op_str not in cls.Platform.SUPPORTED_REGS:
                    return None

                load_s_effect = cls.make_load_s_effect(instr.op_str)
                add_sp_effect = cls.make_add_sp_effect(8)

                instr_effects.append(load_s_effect)
                instr_effects.append(add_sp_effect)

            elif mnemonic == "mov":
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in cls.Platform.SUPPORTED_REGS:
                    return None

                # TODO: add 32b / 16b registers support (at least for some cases)

                if src not in cls.Platform.SUPPORTED_REGS:

                    int_src = _is_int(src)
                    if int_src is None:
                        
                        if src == "qword ptr [rsp]":
                            load_s_effect = cls.make_load_s_effect(dest)
                            instr_effects.append(load_s_effect)
                        else:
                            return None
                    else:
                        load_ct_effect = cls.make_load_ct_effect(dest, int_src)
                        instr_effects.append(load_ct_effect)

                else:
                    mov_rr_effect = cls.make_mov_rr_effect(dest, src)
                    instr_effects.append(mov_rr_effect)

            elif mnemonic == "xchg":

                r1, r2 = _get_2_args(instr.op_str)

                if (r1 not in cls.Platform.SUPPORTED_REGS) or (r2 not in cls.Platform.SUPPORTED_REGS):
                    return None

                if r1 == r2:

                    nop_effect = Effect.instantiate_effect("NO_OP")
                    instr_effects.append(nop_effect)

                else:
                
                    mov_rr_effect1 = cls.make_mov_rr_effect(r1, r2)
                    mov_rr_effect2 = cls.make_mov_rr_effect(r2, r1)

                    instr_effects.append(mov_rr_effect1)
                    instr_effects.append(mov_rr_effect2)

            elif mnemonic in ["add", "sub"]:

                dest, src = _get_2_args(instr.op_str)

                if (dest not in cls.Platform.SUPPORTED_REGS) and (dest != "rsp"):
                    return None

                if dest == "rsp":

                    if mnemonic != "add":
                        return None

                    int_src = _is_int(src)

                    if (int_src is None) or (int_src % 8 != 0):
                        return None

                    add_sp_effect = cls.make_add_sp_effect(int_src)
                    instr_effects.append(add_sp_effect)

                elif src in cls.Platform.SUPPORTED_REGS:
                    
                    arith_add_reg_effect = cls.make_arith_reg_effect(mnemonic, dest, src)
                    instr_effects.append(arith_add_reg_effect)
                    
                else:
                    
                    int_src = _is_int(src)

                    if int_src is None:
                        return None

                    '''
                    DOES SOMETHING DEPEND ON IT?
                    WRONG?
                    op_type = "add"
                    if (int_src < 0 and mnemonic == "add") or (int_src >= 0 and mnemonic == "sub"):
                        op_type = "sub"'''

                    op_type = mnemonic

                    arith_add_ct_effect = cls.make_arith_ct_effect(op_type, dest, int_src)
                    instr_effects.append(arith_add_ct_effect)

            elif mnemonic in ["dec", "inc"]:
                
                dest = instr.op_str

                if dest not in cls.Platform.SUPPORTED_REGS:
                    return None

                op_type = "sub"
                if mnemonic == "inc":
                    op_type = "add"

                arith_1_effect = cls.make_arith_ct_effect(op_type, dest, 1)
                instr_effects.append(arith_1_effect)

            elif mnemonic == "not":
                
                if instr.op_str not in cls.Platform.SUPPORTED_REGS:
                    return None

                logical_not_effect = cls.make_neg_effect(instr.op_str)
                instr_effects.append(logical_not_effect)

            elif mnemonic == "neg":

                if instr.op_str not in cls.Platform.SUPPORTED_REGS:
                    return None

                logical_not_effect = cls.make_neg_effect(instr.op_str)
                arith_neg_effect = cls.make_arith_ct_effect("add", instr.op_str, 1)
                arith_neg_effect.params[0].info["term_1"] = logical_not_effect.params[0]

                instr_effects.append(arith_neg_effect)

            elif mnemonic in ["and", "or", "xor"]:
                
                dest, src = _get_2_args(instr.op_str)

                if dest not in cls.Platform.SUPPORTED_REGS:
                    return None

                if src not in cls.Platform.SUPPORTED_REGS:

                    int_src = _is_int(src)

                    if int_src is None:
                        return None
                    
                    arith_bitwise_ct_effect = cls.make_arith_ct_effect(mnemonic, dest, int_src)
                    instr_effects.append(arith_bitwise_ct_effect)

                else:
                    # particular case xor r, r <=> mov r, 0
                    if dest == src:

                        load_0_effect = cls.make_load_ct_effect(dest, 0)
                        instr_effects.append(load_0_effect)

                    else:
                        arith_bitwise_reg_effect = cls.make_arith_reg_effect(mnemonic, dest, src)
                        instr_effects.append(arith_bitwise_reg_effect)
                    
            elif mnemonic == "nop" or _ignored_instr(instr):
                
                nop_effect = Effect.instantiate_effect("NO_OP")
                instr_effects.append(nop_effect)

            else:
                return None

            return instr_effects          

        except Exception:
            return None

    # method responsible for creating a gadget from separate (but ordered) instruction effects
    # the joining should resemble joining effects when building rop chains from gadgets
    @classmethod
    def join_instr_effects(cls, ordered_effects: List[List[Effect]]):
    
        # depth-first exploration of <op>-type Structured_element arithmetic tree
        # yielding every Structured_element of type "reg_in"
        def _recursive_arith_exploration(element: Structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem
        
        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: Effect):

            if ef.type in ["NO_OP", "ADD_SP"]:
                return True

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            return False

        if len(ordered_effects) == 0:
            return None, None

        # position of sp in the stack view, considering 64 bit elements (real sp byte offset = sp_pos * 8 bytes)
        sp_pos = 0
        acc_effects: List[Effect] = []
        acc_stack = Stack_view()

        # the joining (currently) has 7 steps
        #
        #   1) initialize the joined effects list with the second effects list
        #   2) update the stack by analysing LOAD_S and ADD_SP effects
        #   3) for every instruction in the joined effects list, 
        #       replace every "reg_in" with the corresponding "reg_out" from the first effects list
        #   4) copy every effect from the first effects list into the joined effects list, that has the destination reg
        #       different from any other destination reg from the joined effects list,
        #       and also skip NO_OP and ADD_SP effects
        #   5) (optionally) iterate over all effects from the joined effects list and filter them
        #       so that effects of type move ri, ri are eliminated, or for simplifying arithmetic effects
        #   6) the first effects list is assigned the newly created joined effects list, and the loop continues 
        #       until all effect lists are processed
        #   7) a new gadget is created with the final effects list and the obtained stack, some validity constraints are imposed
        #       and, optionally, other optimizations

        # NOTE: no two effects from a single effect list contain the same destination register
        #       proof by induction: base case assured by the analyse_instr, 
        #                           induction step proven by the rest of the current algorithm's steps

        for i in range(len(ordered_effects)):
            
            # step 1)
            new_acc_effect_list = deepcopy(ordered_effects[i])

            # step 2)
            for ef in new_acc_effect_list:

                if ef.type == "LOAD_S":
                    
                    if sp_pos == len(acc_stack.elements):

                        acc_stack.push(cls.Elem.instantiate_structured_element("64b_stack_val"))
                        acc_stack.elements[sp_pos].info["id"] = ef.params[0].info["id"]

                    else:
                        ef.params[0].info["id"] = acc_stack.elements[sp_pos].info["id"]

                elif ef.type == "ADD_SP":
                    
                    inc_pos_cnt = ef.params[0].info["value"] // 8

                    while inc_pos_cnt > 0:

                        if sp_pos == len(acc_stack.elements):
                            acc_stack.push(cls.Elem.instantiate_structured_element("64b_stack_pad"))

                        sp_pos += 1
                        inc_pos_cnt -= 1

            # step 3)
            for ef in new_acc_effect_list:

                if ef.type == "MOV_RR":
                    
                    reg_in_name = ef.params[0].info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in acc_effects:

                        if before_ef.destination_element.info["reg_name"] == reg_in_name:
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:
                        
                        if corresp_before_ef.type == "MOV_RR":
                            ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:
                            
                            # example for ARITH, analogous for rest
                            # r1 = t1 <op> t2
                            # r2 = r1
                            # joined (for r2): r2 = t1 <op> t2

                            ef.type = corresp_before_ef.type
                            ef.params = deepcopy(corresp_before_ef.params)

                elif ef.type == "ARITH":
                    
                    expr = ef.params[0]
                    for reg_in_elem in _recursive_arith_exploration(expr):
                        
                        reg_in_name = reg_in_elem.info["reg_name"]

                        corresp_before_ef = None
                        for before_ef in acc_effects:

                            if before_ef.destination_element.info["reg_name"] == reg_in_name:
                                corresp_before_ef = before_ef
                                break

                        if corresp_before_ef is not None:

                            if corresp_before_ef.type == "LOAD_S":

                                reg_in_elem.type = "64b_stack_val"
                                reg_in_elem.info = {"id": corresp_before_ef.params[0].info["id"]}

                            elif corresp_before_ef.type == "LOAD_CT":
                                
                                reg_in_elem.type = "ct_val"
                                reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                            elif corresp_before_ef.type == "MOV_RR":
                                reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                            elif corresp_before_ef.type == "ARITH":
                                
                                reg_in_elem.type = corresp_before_ef.params[0].type
                                reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)
        
            # step 4) and 5)
            for before_ef in acc_effects:
                if before_ef.destination_element is not None:

                    before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                    overridden = False
                    for ef in new_acc_effect_list:

                        if (ef.destination_element is not None) and (ef.destination_element.info["reg_name"] == before_ef_dest_reg_name):
                            overridden = True

                    if overridden is False:
                        new_acc_effect_list.append(before_ef)
                    
            # step 5) and 6)
            acc_effects.clear()
            for ef in new_acc_effect_list:
                
                if _ignored_effect(ef) is False:
                    acc_effects.append(ef)

        # step 7)
        acc_effects_filtered = []
        for ef in acc_effects:
            
            if _ignored_effect(ef) is False:
                acc_effects_filtered.append(ef)
                
        # the sp must be at the end of the stack view, 
        # so that the return address of the gadget can be added
        if sp_pos != len(acc_stack.elements):
            return None, None

        # return address for the next gadget / function
        acc_stack.push(cls.Elem.instantiate_structured_element("64b_stack_val"))
        acc_stack.elements[sp_pos].info["id"] = Stack_view.get_elem_id()
        sp_pos += 1

        return acc_stack, acc_effects_filtered

    # method responsible for joining two effects list
    # does NOT make any deep copy - fst and snd should be created copies
    # resembles join_instr_effects, but:
    #   * does not take any stack into consideration
    #   * only two effects list can be joined at a time
    @staticmethod
    def join_effects(fst: List[Effect], snd: List[Effect]):

        if len(fst) == 0 or len(snd) == 0:
            return fst + snd

        # depth-first exploration of <op>-type Structured_element arithmetic tree
        # yielding every Structured_element of type "reg_in"
        def _recursive_arith_exploration(element: Structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem
        
        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: Effect):

            if ef.type in ["NO_OP", "ADD_SP"]:
                return True

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            return False
            
        res = snd

        # replacing every reg_in from res(=snd) with corresponding reg_out from fst
        for ef in res:

            if ef.type == "MOV_RR":
                
                reg_in_name = ef.params[0].info["reg_name"]

                corresp_before_ef = None
                for before_ef in fst:

                    if before_ef.destination_element.info["reg_name"] == reg_in_name:
                        corresp_before_ef = before_ef
                        break

                if corresp_before_ef is not None:
                    
                    if corresp_before_ef.type == "MOV_RR":
                        ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                    elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:

                        ef.type = corresp_before_ef.type
                        ef.params = deepcopy(corresp_before_ef.params)

            elif ef.type == "ARITH":
                
                expr = ef.params[0]
                for reg_in_elem in _recursive_arith_exploration(expr):
                    
                    reg_in_name = reg_in_elem.info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in fst:

                        if before_ef.destination_element.info["reg_name"] == reg_in_name:
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:

                        if corresp_before_ef.type == "LOAD_S":

                            reg_in_elem.type = "64b_stack_val"
                            reg_in_elem.info = {"id": corresp_before_ef.params[0].info["id"]}

                        elif corresp_before_ef.type == "LOAD_CT":
                            
                            reg_in_elem.type = "ct_val"
                            reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                        elif corresp_before_ef.type == "MOV_RR":
                            reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type == "ARITH":
                            
                            reg_in_elem.type = corresp_before_ef.params[0].type
                            reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)
    
        # copying every effect from fst that has reg_out which is not in any reg_out from res
        for before_ef in fst:
            if before_ef.destination_element is not None:

                before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                overridden = False
                for ef in res:

                    if (ef.destination_element is not None) and (ef.destination_element.info["reg_name"] == before_ef_dest_reg_name):
                        overridden = True

                if overridden is False:
                    res.append(before_ef)
                
        # filtering
        res_filtered = []
        for ef in res:
            
            if _ignored_effect(ef) is False:
                res_filtered.append(ef)

        return res_filtered

    # mostly for debugging purposes
    def __str__(self):
        return f"Effect type {self.type}, destination element {self.destination_element}, params {[str(el) for el in self.params]}"

class Effect_ARM64(Effect):

    # NOTE: the alignment is required only when accessing memory
    #       (and even then, it can be deactivated)
    #       for simplicity, this implementation enforces alignment everytime
    # FIXME
    SP_ALIGNMENT = 16

    VALIDATION_SEARCH_MAX_STACK_SIZE = 100 # in longs

    EFFECT_TYPES = {"LOAD_S": ("reg_out", []),                      # ops (add, sub, ...) OR deref OR 64_stack_val 
                                                                    # load value in register from the stack (sp value increase NOT included)
                                                                    # NOTE: generalized version, it can have an arith expression
                                                                    #           that indicates the SP position on the stack
                    "LOAD_CT": ("reg_out", ["ct_val"]),             # load value that is constant (that does not originate from registers or stack)
                    "MOV_RR": ("reg_out", ["reg_in"]),              # copying value from one register to another
                    "ARITH": ("reg_out", []),                       # operations (add, sub, bitewise operations, etc) - the PARAMS are not included, OR deref
                    "NO_OP": (None, []),                            # no operation
                    "JUMP": ("ct_val", [])                          # JUMP instead of (implicit) RET
                                                                    # anything on params (except only ct_val)
                                                                    # destination contains the INDEX of the nth gadget in the chain
                                                                    # (if it is a gadget and NOT a chain, it is always 1)
                    }     

    Elem = Structured_element_ARM64
    Platform = rop_platform.Platform.ARM64

    def __deepcopy__(self, memo):

        copy = Effect_ARM64(self.type, None, [])
        memo[id(self)] = copy

        copy.destination_element = deepcopy(self.destination_element, memo)

        if self.params != []:
            copy.params = [deepcopy(self.params[0], memo)]

        return copy

    @classmethod
    def _mask_element(cls, elem: Structured_element):
        
        mask_op = cls.Elem.instantiate_structured_element("and")
        mask_op.info["term_1"] = elem
        mask_op.info["term_2"] = cls.Elem.instantiate_structured_element("ct_val")
        mask_op.info["term_2"].info["value"] = MASK_32b

        return mask_op

    @classmethod
    def make_jump_reg_effect(cls, reg: str):

        jump_effect = cls.instantiate_effect("JUMP")
        jump_effect.params.append(cls.Elem.instantiate_structured_element("reg_in"))
        jump_effect.params[0].info["reg_name"] = reg
        jump_effect.destination_element.info["value"] = 1 # always 1 for a newly created gadget

        return jump_effect

    # unused?
    @classmethod
    def make_load_s_effect(cls, dest_reg_name: str, m32: bool = False):

        load_s_effect = cls.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name
        
        stack_elem = cls.Elem.instantiate_structured_element("64b_stack_val")
        stack_elem.info["id"] = Stack_view.get_elem_id()

        if m32 is False:
            load_s_effect.params.append(stack_elem)
        else:
            load_s_effect.params.append(cls._mask_element(stack_elem))
        
        return load_s_effect

    @classmethod
    def make_add_sp_effect(cls, *args, **kwargs):
        raise Exception("ADD_SP not used on ARM64")

    @classmethod
    def make_load_s_offset_effect(cls, dest_reg_name: str, src_reg_name: str, 
                                    offset: int = 0, m32: bool = False):

        # logic related to incrementing the src register before / after load with offset
        # is NOT implemented here (check analyse_instr() method)

        load_s_effect = cls.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name

        deref_effect = cls.Elem.instantiate_structured_element("deref")

        if offset == 0:

            src_reg = cls.Elem.instantiate_structured_element("reg_in")
            deref_effect.info["expr"] = src_reg

            src_reg.info["reg_name"] = src_reg_name

            if m32 is False:
                load_s_effect.params.append(deref_effect)
            else:
                load_s_effect.params.append(cls._mask_element(deref_effect))

        else:
            
            arith_effect = cls.Elem.instantiate_structured_element("add")
            deref_effect.info["expr"] = arith_effect

            arith_effect.info["term_1"] =  cls.Elem.instantiate_structured_element("reg_in")
            arith_effect.info["term_2"] =  cls.Elem.instantiate_structured_element("ct_val")
            arith_effect.info["term_1"].info["reg_name"] = src_reg_name
            arith_effect.info["term_2"].info["value"] = offset

            if m32 is False:
                load_s_effect.params.append(deref_effect)
            else:
                load_s_effect.params.append(cls._mask_element(deref_effect))

        return load_s_effect

    @classmethod
    def make_load_s_lshift_effect(cls, dest_reg_name: str, base_src_reg_name: str,
                                    shifted_src_reg_name: str, shift_val: int, m32: bool = False):

        add_op = cls.Elem.instantiate_structured_element("add")
        add_op.info["term_1"] = cls.Elem.instantiate_structured_element("reg_in")
        add_op.info["term_1"].info["reg_name"] = base_src_reg_name

        deref_add_op = cls.Elem.instantiate_structured_element("deref")
        deref_add_op.info["expr"] = add_op
        
        load_s_effect = cls.instantiate_effect("LOAD_S")
        load_s_effect.destination_element.info["reg_name"] = dest_reg_name

        if shift_val == 0:

            add_op.info["term_2"] = cls.Elem.instantiate_structured_element("reg_in")
            add_op.info["term_2"].info["reg_name"] = shifted_src_reg_name

        else:

            shift_op = cls.Elem.instantiate_structured_element("lsh")
            shift_op.info["term_1"] = cls.Elem.instantiate_structured_element("reg_in")
            shift_op.info["term_2"] = cls.Elem.instantiate_structured_element("ct_val")
            shift_op.info["term_1"].info["reg_name"] = shifted_src_reg_name
            shift_op.info["term_1"].info["value"] = shift_val

            add_op.info["term_2"] = shift_op

        if m32 is False:
            load_s_effect.params.append(deref_add_op)
        else:
            load_s_effect.params.append(cls._mask_element(deref_add_op))

        return load_s_effect

    # FIXME jump related etc
    # internal method, receives only deref elements as arg
    # if the access is valid, the deref is replaced by a 64b_stack_val (existent or newly created)
    # try to resolve stack access
    # returns:  True -> successful, 
    #           False -> failed,
    #           None -> access is resolved but not allowed - gadget / chain should be killed
    @classmethod
    def _resolve_stack_access(cls, elem: Structured_element, stack: Stack_view):

        if elem.type != "deref":
            raise Exception(f"unexpected element {elem} with type != deref")

        # returns whether there is a nested deref or not
        def _gather_variables(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):

            if elem is None:
                return False

            if elem.type == "64b_stack_val" and Stack_view.stack_values[elem.info["id"]] is None:

                if Stack_view.related_jump[elem.info["id"]] is None and \
                    elem.info["id"] not in l_stack:

                    l_stack.append(elem.info["id"])

                elif Stack_view.related_jump[elem.info["id"]] is not None and \
                    elem.info["id"] not in l_stack_jmp:

                    l_stack_jmp.append(elem.info["id"])

            elif elem.type == "reg_in" and elem.info["reg_name"] not in l_regs:

                l_regs.append(elem.info["reg_name"])

            elif elem.is_op():

                r1 = _gather_variables(elem.info["term_1"], l_stack, l_stack_jmp, l_regs) 
                r2 = _gather_variables(elem.info["term_2"], l_stack, l_stack_jmp, l_regs)

                return r1 or r2

            elif elem.type == "deref":
                return True

            return False

        # two probabilistic tests
        # the "_z3" uses z3, the "_vanilla" does not
        # (i.e. if an unassigned stack element is found,
        #       without z3 the stack value is treated like a register,
        #       with z3 it tries to assign a value to it,
        #       so that the final sp-offset will point to an empty stack location)
        #
        # it tests whether the expression is equivalent to
        # an effect of type SP + constant positive offset
        #
        # NOTE: no "deref" is allowed (nested derefs are forbidded)
        # return < 0 => effect is forbidden (negative offset / nested deref)
        # return None => invalid access, awaiting to be resolved lated
        # return > 0 => access is valid, the returned value is the offset

        def _test_valid_access_vanilla(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):

            # should not happen???
            if elem is None:
                raise Exception("unexpected None argument")

            snapshots = {r: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for r in l_regs}
            snapshots.update({s_id: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for s_id in l_stack})
            snapshots.update({s_id: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for s_id in l_stack_jmp})

            def _execute(elem: Structured_element, idx):
                
                if elem.type == "reg_in":

                    regname = elem.info["reg_name"]
                    return snapshots[regname][idx]

                elif elem.type == "64b_stack_val":
                    
                    elem_id = elem.info["id"]

                    if Stack_view.stack_values[elem_id] is not None:
                        return Stack_view.stack_values[elem_id]
                    
                    return snapshots[elem_id][idx]

                elif elem.type == "ct_val":
                    return elem.info["value"]

                elif elem.type == "deref":
                    return None

                elif elem.is_op():

                    if elem.type == "neg":
                        return ~(_execute(elem.info["term_1"], idx))

                    r1 = _execute(elem.info["term_1"], idx)
                    r2 = _execute(elem.info["term_2"], idx)

                    if r1 is not None and r2 is not None:
                        return cls.Elem.OPS[elem.type](r1, r2)

                    else:
                        return None

                raise Exception(f"unexpected elem {elem}")

            # first, determine an offset
            # since we want it to be constant, 
            # any future test should yield the same offset
            # if not, the access is not valid

            # offset = Expr(SP, ...) - SP

            r = _execute(elem, 0)
            if r is None:
                return -1

            offset = r - snapshots["sp"][0]

            for t in range(1, cls.ARITH_P_TEST_CNT):

                r = _execute(elem, t)
                if r is None:
                    return -1

                if r - snapshots["sp"][t] != offset:
                    offset = None

            return offset
        
        def _test_valid_access_z3(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):

            nonlocal stack
            
            # should not happen???
            if elem is None:
                raise Exception("unexpected None argument")

            snapshots = {r: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for r in l_regs}
            snapshots.update({s_id: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for s_id in l_stack_jmp})

            z3_solver = z3.Solver()
            offset = z3.BitVec("offset", 64)

            _aux_id = 0
            def _convert_to_z3_expr(el: Structured_element, idx):
                
                nonlocal _aux_id

                if el.type == "64b_stack_val":

                    val = Stack_view.stack_values[el.info["id"]]
                    jmp = Stack_view.stack_values[el.info["id"]]

                    if val is not None:

                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        z3_solver.add(conv_el == val)

                        return conv_el
                    
                    elif jmp is not None:
                        
                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        z3_solver.add(conv_el == snapshots[el.info["id"]][idx])

                        return conv_el

                    else:
                        return z3.BitVec(f"stack{el.info['id']}", 64)

                else:

                    conv_el = z3.BitVec(f"c{_aux_id}", 64)
                    _aux_id += 1
                    
                    if el.type == "ct_val":
                        z3_solver.add(conv_el == el.info["value"])

                    elif el.type == "reg_in":
                        z3_solver.add(conv_el == snapshots[el.info["reg_name"]][idx])

                    elif el.type == "neg":
                        
                        t = _convert_to_z3_expr(el.info["term_1"], idx)
                        z3_solver.add(conv_el == ~t)

                    elif el.is_op():

                        t1 = _convert_to_z3_expr(el.info["term_1"], idx)
                        t2 = _convert_to_z3_expr(el.info["term_2"], idx)

                        if el.type == "add":
                            z3_solver.add(conv_el == t1 + t2)

                        elif el.type == "sub":
                            z3_solver.add(conv_el == t1 - t2)

                        elif el.type == "and":
                            z3_solver.add(conv_el == t1 & t2)

                        elif el.type == "or":
                            z3_solver.add(conv_el == t1 | t2)

                        elif el.type == "xor":
                            z3_solver.add(conv_el == t1 ^ t2)

                        elif el.type == "mul":
                            z3_solver.add(conv_el == t1 * t2)

                        elif el.type == "lsh":
                            z3_solver.add(conv_el == t1 << t2)

                        elif el.type == "rsh":
                            z3_solver.add(conv_el == z3.LShR(t1, t2))

                    return conv_el

            for t in range(cls.ARITH_P_TEST_CNT):
                
                expr = _convert_to_z3_expr(elem, t)
                
                conv_el = z3.BitVec(f"c{_aux_id}", 64)
                _aux_id += 1

                z3_solver.add(conv_el == snapshots["sp"][t])
                z3_solver.add(expr - conv_el == offset)

            z3_solver.add(offset % 8 == 0)

            for of, el in enumerate(stack.elements):

                if el.type == "64b_stack_val":
                    z3_solver.add(offset != of)

            # first, check if the offset can be inside the current stack view
            z3_solver_fst = deepcopy(z3_solver)
            z3_solver_fst.add(offset < len(stack.elements))

            if z3_solver_fst.check() == z3.sat:
                sm = z3_solver_fst.model()

                for stack_id in l_stack:

                    s_elem = z3.BitVec(f"stack{stack_id}", 64)
                    s_val = sm[s_elem]

                    if s_val is not None:
                        Stack_view.stack_values[stack_id] = s_val.as_long()

                if sm[offset] is None:
                    raise Exception("None offset when validating stack access with z3")

                return sm[offset].as_long()

            else:

                # try a wider range for offset
                z3_solver.add(offset < cls.VALIDATION_SEARCH_MAX_STACK_SIZE)

                if z3_solver.check() == z3.sat:
                    sm = z3_solver.model()

                    for stack_id in l_stack:

                        s_elem = z3.BitVec(f"stack{stack_id}", 64)
                        s_val = sm[s_elem]

                        if s_val is not None:
                            Stack_view.stack_values[stack_id] = s_val.as_long()

                    if sm[offset] is None:
                        raise Exception("None offset when validating stack access with z3")

                    return sm[offset].as_long()

                else:

                    if len(l_regs) > 1:
                        return None
                    return -1
        
        unassigned_stack_values = []
        jump_related_stack_values = []
        regs = []
        nested_derefs = _gather_variables(elem.info["expr"], unassigned_stack_values, jump_related_stack_values, regs)

        if nested_derefs is True:
            return None

        if len(regs) > 1 or len(jump_related_stack_values) > 0 or "sp" not in regs:
            return False

        # NOTE further code works even if len(regs) > 1
        #      (created this way in case previous constrains will be eliminated)

        if cls.Platform.use_z3 is False or len(unassigned_stack_values) == 0:      
            stack_offset = _test_valid_access_vanilla(elem.info["expr"], unassigned_stack_values, jump_related_stack_values, regs)
        else:
            stack_offset = _test_valid_access_z3(elem.info["expr"], unassigned_stack_values, jump_related_stack_values, regs)

        if stack_offset is None:
            return False

        if stack_offset < 0 or stack_offset > cls.VALIDATION_SEARCH_MAX_STACK_SIZE * 8:
            return None

        if stack_offset % 8 != 0:
            return None

        stack_offset //= 8

        for _ in range(len(stack.elements), stack_offset + 1):
            stack.push(cls.Elem.instantiate_structured_element("64b_stack_pad"))

        if stack.elements[stack_offset].type == "64b_stack_pad":

            stack.elements[stack_offset] = cls.Elem.instantiate_structured_element("64b_stack_val")
            stack.elements[stack_offset].info["id"] = Stack_view.get_elem_id()

        elem.type = "64b_stack_val"
        elem.info = {"id": stack.elements[stack_offset].info["id"]}

        return True

    # try to resolve stack access
    # it will automatically descend down any expression tree
    # and call _resolve_stack_access accordingly
    # returns:  True -> valid, 
    #           False -> invalid,
    #           None -> gadget / chain should be killed
    @classmethod
    def resolve_stack_access(cls, elem: Structured_element, stack: Stack_view):
        
        if elem is None:
            return True

        if elem.is_op():

            r1 = cls.resolve_stack_access(elem.info["term_1"], stack)
            r2 = cls.resolve_stack_access(elem.info["term_2"], stack)

            if r1 is None or r2 is None:
                return None

            return r1 and r2

        elif elem.type == "deref":
            return cls._resolve_stack_access(elem, stack)

        return True

    # currently uses Z3: https://github.com/Z3Prover/z3
    # possible type pairs (self, checked_ef):
    # ARITH, ARITH
    # MOV_RR, ARITH
    # LOAD_CT, ARITH
    def _match_arith(self, checked_ef: Effect):

        if self.destination_element.info["reg_name"] != checked_ef.destination_element.info["reg_name"]:
            return False

        # possible type pairs (wanted_ef, checked_ef):
        # ARITH, ARITH
        # MOV_RR, ARITH
        # LOAD_CT, ARITH
        # NOTE: if the WANTED EFFECT is of type ARITH, it is assumed it does NOT contain stack elements

        # match the operation trees, taking into account only commutativity of some operations
        def _tree_match(wanted_ef: Structured_element, checked_ef: Structured_element):

            if (wanted_ef is None) and (checked_ef is None):
                return True

            if wanted_ef.type != checked_ef.type:
                return False
            
            if wanted_ef.type == "64b_stack_val":

                if checked_ef.info["id"] == wanted_ef.info["id"]:
                    return True

                cid = checked_ef.info["id"]
                wid = wanted_ef.info["id"]

                if (Stack_view.stack_values[cid] == Stack_view.stack_values[wid]) \
                    or (Stack_view.stack_values[cid] is None and \
                        Stack_view.related_jump[cid] == Stack_view.related_jump[wid]):

                    val = Stack_view.stack_values[wanted_ef.info["id"]]

                    Stack_view.del_id(wanted_ef.info["id"])
                    
                    wanted_ef.info["id"] = checked_ef.info["id"]
                    Stack_view.stack_values[cid] = val

                    return True

                else:
                    return False

            if wanted_ef.type == "reg_in":
                return wanted_ef.info["reg_name"] == checked_ef.info["reg_name"]

            if wanted_ef.type == "ct_val":
                return wanted_ef.info["value"] == checked_ef.info["value"]

            if wanted_ef.type in ["sub", "neg", "rsh", "lsh"]:
                return _tree_match(wanted_ef.info["term_1"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_2"], checked_ef.info["term_2"])

            if wanted_ef.is_op():
                return (_tree_match(wanted_ef.info["term_1"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_2"], checked_ef.info["term_2"])) or\
                        (_tree_match(wanted_ef.info["term_2"], checked_ef.info["term_1"]) and _tree_match(wanted_ef.info["term_1"], checked_ef.info["term_2"]))

            raise RuntimeError(f"trying to match trees with unknown types: {wanted_ef.type}")

        # probabilistic match
        def _probabilistic_match(wanted_ef: Effect, checked_ef: Effect):

            stack_ids = set()

            jmp_stack_elements = {}
            reg_in_elements = {}

            # in case of stack assignments, z3 solver is used
            z3_solver = z3.Solver()
            
            # simulates the execution of the arith Effect
            def _simulate(op_element: Structured_element, local_stack_values: Dict[int, int], 
                            jmp_stack_values: Dict[int, int], reg_start_values: Dict[str, int]):
        
                if op_element.type == "64b_stack_val":

                    if Stack_view.related_jump[op_element.info["id"]] is None:
                        return local_stack_values[op_element.info["id"]]

                    return jmp_stack_elements[op_element.info["id"]]

                if op_element.type == "ct_val":
                    return op_element.info["value"]

                if op_element.type == "reg_in":
                    return reg_start_values[op_element.info["reg_name"]]

                if op_element.type == "add":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) +\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)
                
                if op_element.type == "sub":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) -\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "and":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) &\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "or":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) |\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "xor":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) ^\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "mul":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) *\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "lsh":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) <<\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "rsh":
                    return _simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values) >>\
                            _simulate(op_element.info["term_2"], local_stack_values, jmp_stack_values, reg_start_values)

                if op_element.type == "neg":
                    return ~(_simulate(op_element.info["term_1"], local_stack_values, jmp_stack_values, reg_start_values))

                raise Exception(f"unknown op element: {op_element}")

            # function that folds over the ARITH expression tree 
            # and updates the z3 solver
            _aux_id = 0
            def _convert_to_z3_expr(el: Structured_element):
                
                nonlocal _aux_id

                if el.type == "64b_stack_val":

                    val = Stack_view.stack_values[el.info["id"]]
                    jmp = Stack_view.related_jump[el.info["id"]]

                    if val is not None:

                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        _aux_id += 1
                        z3_solver.add(conv_el == val)

                        return conv_el
                    
                    elif jmp is not None:
                        
                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        _aux_id += 1
                        z3_solver.add(conv_el == jmp_stack_elements[el.info["id"]])

                        return conv_el

                    else:
                        return z3.BitVec(f"stack{el.info['id']}", 64)

                else:

                    conv_el = z3.BitVec(f"c{_aux_id}", 64)
                    _aux_id += 1
                    
                    if el.type == "ct_val":
                        z3_solver.add(conv_el == el.info["value"])

                    elif el.type == "reg_in":
                        z3_solver.add(conv_el == reg_in_elements[el.info["reg_name"]])

                    elif el.type == "neg":
                        
                        t = _convert_to_z3_expr(el.info["term_1"])
                        z3_solver.add(conv_el == ~t)

                    elif el.is_op():

                        t1 = _convert_to_z3_expr(el.info["term_1"])
                        t2 = _convert_to_z3_expr(el.info["term_2"])

                        if el.type == "add":
                            z3_solver.add(conv_el == t1 + t2)

                        elif el.type == "sub":
                            z3_solver.add(conv_el == t1 - t2)

                        elif el.type == "and":
                            z3_solver.add(conv_el == t1 & t2)

                        elif el.type == "or":
                            z3_solver.add(conv_el == t1 | t2)

                        elif el.type == "xor":
                            z3_solver.add(conv_el == t1 ^ t2)

                        elif el.type == "mul":
                            z3_solver.add(conv_el == t1 * t2)

                        elif el.type == "lsh":
                            z3_solver.add(conv_el == t1 << t2)

                        elif el.type == "rsh":
                            z3_solver.add(conv_el == z3.LShR(t1, t2))

                    return conv_el

            # method that determines whether the checked expression has unassigned stack elements or not
            # and if it has, initialize them as keys in the stack_elements_assignments dictionary
            # also, it retains the reg_in elements used
            def _check_stack_elements(el: Structured_element):

                if el is None:
                    return False

                if el.type == "64b_stack_val":
                    
                    if Stack_view.stack_values[el.info["id"]] is None:

                        if Stack_view.related_jump[el.info["id"]] is None:

                            stack_ids.add(el.info["id"])
                            return True

                        jmp_stack_elements.update({el.info["id"]: None})
                        return False

                    return False

                elif el.type == "reg_in":

                    reg_in_elements.update({el.info["reg_name"]: None})
                    return False

                elif el.type == "ct_val":
                    return False

                elif el.is_op():

                    checked_1 = _check_stack_elements(el.info["term_1"])
                    checked_2 = _check_stack_elements(el.info["term_2"])

                    return checked_1 or checked_2

                elif el.type == "deref":
                    raise Exception("deref found while matching arith")

                raise RuntimeError(f"unknown element type {el.type} when trying to match arith")

            stack_elements_found_inwanted = _check_stack_elements(wanted_ef.params[0])
            if stack_elements_found_inwanted is True:
                raise RuntimeError("stack element found in wanted effect")

            stack_elements_found = _check_stack_elements(checked_ef.params[0])

            for _ in range(Effect.ARITH_P_TEST_CNT):

                for reg_in in reg_in_elements.keys():
                    reg_in_elements[reg_in] = random.randint(0, 2 ** 64)

                for s_id in jmp_stack_elements.keys():
                    jmp_stack_elements[s_id] = random.randint(0, 2 ** 64)

                wanted_ef_val = 0

                if wanted_ef.type == "MOV_RR":
                    wanted_ef_val = reg_in_elements[wanted_ef.params[0].info["reg_name"]]

                elif wanted_ef.type == "LOAD_CT":
                    wanted_ef_val = wanted_ef.params[0].info["value"]

                elif wanted_ef.type == "ARITH":
                    wanted_ef_val = _simulate(wanted_ef.params[0], Stack_view.stack_values, jmp_stack_elements, reg_in_elements)

                # the checked_ef has no stack id to be assigned a value, only to compute the result based on reg_in values
                if stack_elements_found is False:

                    checked_ef_val = _simulate(checked_ef.params[0], Stack_view.stack_values, jmp_stack_elements, reg_in_elements)
                    if checked_ef_val != wanted_ef_val:
                        return False

                else:

                    if self.Platform.use_z3 is True:

                        # there are unknown stack values that need to be assigned a value
                        # before proceeding in checking the matching

                        z3_expr = _convert_to_z3_expr(checked_ef.params[0])
                        z3_solver.add(z3_expr == wanted_ef_val)

                    else:
                        return False

            # checking for stack element possible assignments 
            # so that checked_ef matches wanted_ef
            if stack_elements_found is True:

                if z3_solver.check() == z3.sat:

                    sm = z3_solver.model()
                    for stack_elem_id in stack_ids:

                        z3_stack_elem = z3.BitVec(f"stack{stack_elem_id}", 64)
                        val = sm[z3_stack_elem]

                        if val is not None:
                            Stack_view.stack_values[stack_elem_id] = val.as_long()
                        #else:
                            # irrelevant element, add some padding
                         #   Stack_view.stack_values[stack_elem_id] = int.from_bytes(b'A' * 8, 'little')

                else:
                    return False

            return True
        
        if Effect.ARITH_EXACT_MATCH is True:
            return _tree_match(self, checked_ef)
        else:
            return _probabilistic_match(self, checked_ef)

    # function that matches two effects
    # NOTE: when matching with LOAD_S effects, self stack element ID is changed
    def match(self, g_effect: Effect):

        if self.type == "JUMP" or g_effect.type == "JUMP":
            raise RuntimeError(f"unexpected match attempt with a JUMP effect: {self}")

        if self.destination_element.info["reg_name"] != g_effect.destination_element.info["reg_name"]:
            return False

        if self.type == "ARITH" or g_effect.type == "ARITH":
            return self._match_arith(g_effect)
        
        # LOAD_S is intentionally restricted to only other LOAD_S effects, for an efficient/ fast search
        # if one wants to have all the possible ways of loading a value in a register, LOAD_CT matching should be chosen instead
        # NOTE: unused???
        if self.type == "LOAD_S":
            
            if g_effect.type != "LOAD_S":
                return False

            if Stack_view.related_jump[g_effect.params[0].info["id"]] is not None:
                return False
            
            # either the wanted effect has the same value as the stack element (none or int value)
            # or the wanted effect has a concrete value and the stack element is none, case in which stack value is assigned the wanted one
            # or both the stack and the wanted elements have non-none values, but are different, case in which it fails
            # in any case it succeeds, the wanted value id <- the stack id
            if (Stack_view.stack_values[g_effect.params[0].info["id"]] == Stack_view.stack_values[self.params[0].info["id"]]) \
                or (Stack_view.stack_values[g_effect.params[0].info["id"]] is None):

                if g_effect.params[0].info["id"] != self.params[0].info["id"]:

                    val = Stack_view.stack_values[self.params[0].info["id"]]
                    Stack_view.del_id(self.params[0].info["id"])

                    self.params[0].info["id"] = g_effect.params[0].info["id"]
                    Stack_view.stack_values[g_effect.params[0].info["id"]] = val

                return True

            else:
                return False

        elif self.type == "LOAD_CT":
            
            if g_effect.type == "LOAD_CT":

                if g_effect.params[0].info["value"] != self.params[0].info["value"]:
                    return False
                return True

            elif g_effect.type == "LOAD_S":

                if Stack_view.related_jump[g_effect.params[0].info["id"]] is not None:
                    return False

                if (Stack_view.stack_values[g_effect.params[0].info["id"]] == self.params[0].info["value"]) \
                    or (Stack_view.stack_values[g_effect.params[0].info["id"]] is None):

                    Stack_view.stack_values[g_effect.params[0].info["id"]] = self.params[0].info["value"]
                    return True
            
                return False

            return False

        elif self.type == "MOV_RR":
            
            if g_effect.type == "MOV_RR":

                if self.params[0].info["reg_name"] != g_effect.params[0].info["reg_name"]:
                    return False
                return True

            return False

        raise RuntimeError(f"trying to match types {self.type}, {g_effect.type}")

    # valid jump <=> it can "jump" to any value in [1, 2 ** 64 - 1]
    #                   if z3 deactivated, valid jump <=>  jump [empty stack value]
    #                   if z3 is used, a probabilistic test is used
    # NOTE: this method SHOULD NOT be called when building payload
    # returns:  True -> valid
    #           False -> invalid
    #           None -> gadget / chain should be killed
    # NOTE: this is the only place a related_jump value can be set from None to a jump id
    # NOTE: by the time of calling this method, stack elems jump idx should be consistent
    #       (in particular, do NOT call this before joining effects and stacks)
    @classmethod
    def resolve_jump(cls, elem: Structured_element, jump_id: int):
        
        # returns whether there is a deref or not
        def _gather_variables(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):

            if elem is None:
                return False

            if elem.type == "64b_stack_val" and Stack_view.stack_values[elem.info["id"]] is None:

                if (Stack_view.related_jump[elem.info["id"]] is None or \
                    Stack_view.related_jump[elem.info["id"]] == jump_id) and \
                    elem.info["id"] not in l_stack:

                    l_stack.append(elem.info["id"])

                elif Stack_view.related_jump[elem.info["id"]] is not None and \
                    elem.info["id"] not in l_stack_jmp:

                    l_stack_jmp.append(elem.info["id"])

            elif elem.type == "reg_in" and elem.info["reg_name"] not in l_regs:

                l_regs.append(elem.info["reg_name"])

            elif elem.is_op():

                r1 = _gather_variables(elem.info["term_1"], l_stack, l_stack_jmp, l_regs)
                r2 = _gather_variables(elem.info["term_2"], l_stack, l_stack_jmp, l_regs)

                return r1 or r2

            elif elem.type == "deref":
                return True

            return False

        def _test_valid_jump_vanilla(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):
            
            if elem.type == "64b_stack_pad":
                raise Exception(f"unexpected stack pad at valid jump test {elem}")
            
            # already checked to be unassigned
            # and already jump-connected with this jump
            return elem.type == "64b_stack_val"

        def _test_valid_jump_z3(elem: Structured_element, l_stack: List[int], l_stack_jmp: List[int], l_regs: List[str]):
            
            # already checked to be unassigned
            # and already jump-connected with this jump
            if elem.type == "64b_stack_val":
                return True

            if elem.type == "64b_stack_pad":
                raise Exception(f"unexpected stack pad at valid jump test {elem}")

            snapshots = {r: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for r in l_regs}
            snapshots.update({s_id: [random.randint(0, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)] for s_id in l_stack_jmp})
            
            jump_addr = [random.randint(1, 2 ** 64 - 1) for _ in range(cls.ARITH_P_TEST_CNT)]

            _aux_id = 0
            def _convert_to_z3_expr(z3_solver: z3.Solver, el: Structured_element, idx):
                
                nonlocal _aux_id

                if el.type == "64b_stack_val":

                    val = Stack_view.stack_values[el.info["id"]]
                    jmp = Stack_view.related_jump[el.info["id"]]

                    if val is not None:

                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        z3_solver.add(conv_el == val)

                        return conv_el
                    
                    elif jmp is not None and jmp != jump_id:
                        
                        conv_el = z3.BitVec(f"c{_aux_id}", 64)
                        z3_solver.add(conv_el == snapshots[el.info["id"]][idx])

                        return conv_el

                    else:
                        return z3.BitVec(f"stack{el.info['id']}", 64)

                else:

                    conv_el = z3.BitVec(f"c{_aux_id}", 64)
                    _aux_id += 1
                    
                    if el.type == "ct_val":
                        z3_solver.add(conv_el == el.info["value"])

                    elif el.type == "reg_in":
                        z3_solver.add(conv_el == snapshots[el.info["reg_name"]][idx])

                    elif el.type == "neg":
                        
                        t = _convert_to_z3_expr(z3_solver, el.info["term_1"], idx)
                        z3_solver.add(conv_el == ~t)

                    elif el.is_op():

                        t1 = _convert_to_z3_expr(z3_solver, el.info["term_1"], idx)
                        t2 = _convert_to_z3_expr(z3_solver, el.info["term_2"], idx)

                        if el.type == "add":
                            z3_solver.add(conv_el == t1 + t2)

                        elif el.type == "sub":
                            z3_solver.add(conv_el == t1 - t2)

                        elif el.type == "and":
                            z3_solver.add(conv_el == t1 & t2)

                        elif el.type == "or":
                            z3_solver.add(conv_el == t1 | t2)

                        elif el.type == "xor":
                            z3_solver.add(conv_el == t1 ^ t2)

                        elif el.type == "mul":
                            z3_solver.add(conv_el == t1 * t2)

                        elif el.type == "lsh":
                            z3_solver.add(conv_el == t1 << t2)

                        elif el.type == "rsh":
                            z3_solver.add(conv_el == z3.LShR(t1, t2))

                    return conv_el

            for t in range(cls.ARITH_P_TEST_CNT):

                z3_solver = z3.Solver()
                
                expr = _convert_to_z3_expr(z3_solver, elem, t)
                z3_solver.add(expr == jump_addr[t])

                if z3_solver.check() != z3.sat:

                    if len(l_regs) == 0 and (len(l_stack) > 0 or len(l_stack_jmp) > 0):
                        return None
                        
                    return False

            return True

        unassigned_stack_values = []
        jump_related_stack_values = []
        regs = []
        derefs = _gather_variables(elem, unassigned_stack_values, jump_related_stack_values, regs)

        if len(regs) == 0 and len(unassigned_stack_values) == 0:
            return None

        if "sp" in regs:
            return None

        if elem.type == "64b_stack_val" and Stack_view.stack_values[elem.info["id"]] is not None:
            return None

        if elem.type == "64b_stack_val" and Stack_view.related_jump[elem.info["id"]] is not None and \
            Stack_view.related_jump[elem.info["id"]] != jump_id:
            return None

        # once a non-jump-related stack element is found inside the jump's expression
        # it "cannot escape" the interaction with this jump
        # so it is claimed even if the effect is not yet a valid jump
        # NOTE: above observation is not valid for derefs, but they are not analysed anyways
        
        # associate every id with this jump
        for s_id in unassigned_stack_values:
            Stack_view.related_jump[s_id] = jump_id

        if len(unassigned_stack_values) == 0:
            return False

        if derefs is True or len(regs) > 0:
            return False

        # NOTE below code works even if len(regs) > 0 or len(jump_related_stack_values) > 0
        #       and even with "sp" inside regs
        #       (created this way in case previous constrain will be eliminated)

        if cls.Platform.use_z3 is True:
            return _test_valid_jump_z3(elem, unassigned_stack_values, jump_related_stack_values, regs)

        return _test_valid_jump_vanilla(elem, unassigned_stack_values, jump_related_stack_values, regs)

    # method that converts each dissasembled instruction provided by Capstone into effects
    # it is also responsible for checking the validity of the instruction
    # NOTE: sp-related arithmetic is further processed (and reduced) inside join_instr_effects method
    @classmethod
    def analyse_instr(cls, instr: CsInsn):

        # checks whether the instruction effects 
        # are ignored (from the point of view of this algorithm)
        # and are treated as NOP
        def _ignored_instr(instr: CsInsn):

            if instr.mnemonic in cls.Platform.IGNORED_INSTR_MNEMONICS:
                return True

            return False

        def _to_xreg(reg):
            return "sp" if (reg == "sp") else ("x" + reg[1:])

        # arm64 synthax is more complex (than x86 at least)
        # so this function will be relatively slow
        # but it is necessary to also keep the code inteligible
        def _parse_opstr(s):

            before_sqb = []
            inside_sqb = None
            after_sqb = None
            has_exclamation = False
            
            if "[" in s:

                inside_sqb = []
                after_sqb = []

                s = s.split("[")
                s1 = s[1].split("]")

                s0, s1, s2 = s[0], s1[0], s1[1]

                if len(s2) > 0 and s2[0] == "!":
                    has_exclamation = True
                    s2 = s2[1:]

            else:
                s0, s1, s2 = s, '', ''

            for el in s0.split(","):
                el = el.strip()

                if len(el) == 0:
                    continue

                if el[0] == "#":
                    before_sqb.append(_is_int(el[1:]))

                elif _to_xreg(el) in cls.Platform.SUPPORTED_REGS or \
                    el in ["sp", "xzr"]:

                    before_sqb.append(el)

                elif el[:3] == "lsl":
                    before_sqb.append("lsl" + el[5:])

                elif el[:3] == "lsr":
                    before_sqb.append("lsr" + el[5:])

                else:
                    before_sqb.append(el)

            for el in s1.split(","):
                el = el.strip()

                if len(el) == 0:
                    continue

                if el[0] == "#":
                    inside_sqb.append(_is_int(el[1:]))

                elif _to_xreg(el) in cls.Platform.SUPPORTED_REGS or \
                    el in ["sp", "xzr"]:

                    inside_sqb.append(el)

                elif el[:3] == "lsl":
                    inside_sqb.append("lsl" + el[5:])

                elif el[:3] == "lsr":
                    inside_sqb.append("lsr" + el[5:])

                else:
                    inside_sqb.append(el)

            for el in s2.split(","):
                el = el.strip()

                if len(el) == 0:
                    continue

                if el[0] == "#":
                    after_sqb.append(_is_int(el[1:]))

                elif _to_xreg(el) in cls.Platform.SUPPORTED_REGS or \
                    el in ["sp", "xzr"]:

                    after_sqb.append(el)

                elif el[:3] == "lsl":
                    after_sqb.append("lsl" + el[5:])

                elif el[:3] == "lsr":
                    after_sqb.append("lsr" + el[5:])

                else:
                    after_sqb.append(el)

            return before_sqb, inside_sqb, after_sqb, has_exclamation

        # FIXME whether x30 is marked as changed at BLR / RET or not

        # NOTE: due to the complexity of the possible instructions
        #       only some of them are implemented
        #       others should be easily implemented, if one wants to

        try:

            instr_effects = []

            mnemonic = instr.mnemonic

            bl, il, al, excl = _parse_opstr(instr.op_str)

            # NEVER allow changes on sp as an effect;
            # sp changed only by:
            #       * add sp, sp, offset (constant)
            #       * pre/post increment at ldr / ldp
            # it can be concluded that sp changes only in the form of:
            #       sp = sp + constant, constant >= 0, (and also) constant % 16 == 0
            if len(bl) > 0 and bl[0] == "sp" and mnemonic != "add":
                return None

            # branching instructions

            if mnemonic == "ret":
                
                if len(bl) > 0:

                    if bl[0] not in cls.Platform.SUPPORTED_REGS:
                        return None

                    jump_effect = cls.make_jump_reg_effect(bl[0])
                    instr_effects.append(jump_effect)

                else:
                    jump_effect = cls.make_jump_reg_effect("x30")
                    instr_effects.append(jump_effect)
            
            elif mnemonic == "br":
                
                if bl[0] not in cls.Platform.SUPPORTED_REGS:
                    return None

                jump_effect = cls.make_jump_reg_effect(bl[0])
                instr_effects.append(jump_effect)

            elif mnemonic == "blr":

                # FIXME decide whether x30 is marked as changed at BLR or not
                
                if bl[0] not in cls.Platform.SUPPORTED_REGS:
                    return None

                jump_effect = cls.make_jump_reg_effect(bl[0])
                instr_effects.append(jump_effect)

            # move-related instructions

            elif mnemonic[:3] == "mov":
                
                if mnemonic == "mov":

                    # TODO remove after debug
                    if type(bl[1]) is int:
                        print(f"found mov reg, imm {instr.op_str}")
                        quit()

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src = _to_xreg(bl[0]), _to_xreg(bl[1])

                    if dest != bl[0]:

                        # dealing with w registers
                        # convert to x regs, with a bitmask operation
                        mov_rr_m32_effect = cls.make_arith_ct_effect("and", src, MASK_32b)
                        mov_rr_m32_effect.destination_element.info["reg_name"] = dest
                        
                        instr_effects.append(mov_rr_m32_effect)

                    else:
                        mov_rr_effect = cls.make_mov_rr_effect(dest, src)
                        instr_effects.append(mov_rr_effect)

                elif mnemonic == "movz":

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS:
                        return None
                    
                    dest, ct = _to_xreg(bl[0]), bl[1]

                    if len(bl) > 2:

                        if bl[2][:3] == "lsl":
                            ct <<= _is_int(bl[2][3:])

                        else:
                            print(f"instruction {mnemonic} {instr.op_str}; unsupported at the moment")
                            return None

                    # here, no difference between x and w regs
                    load_ct_effect = cls.make_load_ct_effect(dest, ct)
                    instr_effects.append(load_ct_effect)

                elif mnemonic == "movn":

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS:
                        return None
                    
                    dest, ct = _to_xreg(bl[0]), bl[1]

                    if len(bl) > 2:

                        if bl[2][:3] == "lsl":
                            ct <<= _is_int(bl[2][3:])

                        else:
                            #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                            return None

                    ct = ~ct

                    if dest != bl[0]:
                        ct &= MASK_32b
    
                    load_ct_effect = cls.make_load_ct_effect(dest, ct)
                    instr_effects.append(load_ct_effect)

                elif mnemonic == "movk":

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS:
                        return None
                    
                    dest, ct = _to_xreg(bl[0]), bl[1]

                    slot_mask = ~0xffff

                    if len(bl) > 2:

                        if bl[2][:3] == "lsl":
                            sh_ = _is_int(bl[2][3:])

                            ct <<= sh_
                            slot_mask = ~(0xffff << sh_)

                        else:
                            #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                            return None

                    if dest != bl[0]:
                        slot_mask &= MASK_32b

                    masked_oldval = cls.make_arith_ct_effect("and", dest, slot_mask)
                    movk_effect = cls.make_arith_ct_effect("or", dest, ct)
                    movk_effect.params[0].info["term_1"] = masked_oldval.params[0]

                    instr_effects.append(movk_effect)

            elif mnemonic == "mvn":
                
                # TODO remove after debug
                if type(bl[1]) is int:
                    print(f"found mvn reg, imm {instr.op_str}")
                    quit()

                if len(bl) == 2:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None

                    dest, src = _to_xreg(bl[0]), _to_xreg(bl[1])

                    mvn_effect = cls.make_neg_effect(dest, src)

                    if dest != bl[0]:

                        mvn_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        mvn_m32_effect.params[0].info["term_1"] = mvn_effect.params[0]

                        instr_effects.append(mvn_m32_effect)

                    else:
                        instr_effects.append(mvn_effect)
                        
                elif len(bl) == 3:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None

                    dest, src, sh_ = _to_xreg(bl[0]), _to_xreg(bl[1]), bl[2]
                    
                    if sh_[:3] == "lsl":
                        sh_op = "lsh"
                    elif sh_[:3] == "lsr":
                        sh_op = "rsh"
                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])

                    shift_src_effect = cls.make_arith_ct_effect(sh_op, src, sh_val)
                    mvn_effect = cls.make_neg_effect(dest)
                    mvn_effect.params[0].info["term_1"] = shift_src_effect.params[0]

                    if dest != bl[0]:

                        mvn_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        mvn_m32_effect.params[0].info["term_1"] = mvn_effect.params[0]

                        instr_effects.append(mvn_m32_effect)

                    else:
                        instr_effects.append(mvn_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            # arithmetic, logic ops

            elif mnemonic in ["add", "adds", "sub", "subs", "mul"]:

                op_type = mnemonic[:3]

                if type(bl[2]) is int:

                    if len(bl) > 3:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    if bl[0] == "sp":

                        if bl[1] == "sp":
                            instr_effects.append(cls.make_arith_ct_effect("add", "sp", bl[2]))
                        else:
                            return None

                    else:

                        if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                            bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                            return None
                        
                        dest, src1, ct = _to_xreg(bl[0]), _to_xreg(bl[1]), bl[2]

                        arith_effect = cls.make_arith_ct_effect(op_type, src1, ct)
                        arith_effect.destination_element.info["reg_name"] = dest

                        if dest != bl[0]:

                            arith_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                            arith_m32_effect.params[0].info["term_1"] = arith_effect.params[0]

                            instr_effects.append(arith_m32_effect)

                        else:
                            instr_effects.append(arith_effect)

                elif len(bl) == 3:

                    if bl[0] == "sp":
                        return None

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                
                    dest, src1, src2 = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2])

                    add_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                    add_effect.destination_element.info["reg_name"] = dest

                    if dest != bl[0]:

                        add_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        add_m32_effect.params[0].info["term_1"] = add_effect.params[0]

                        instr_effects.append(add_m32_effect)

                    else:
                        instr_effects.append(add_effect)

                elif len(bl) == 4:

                    if bl[0] == "sp":
                        return None

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src1, src2, sh_ = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2]), bl[3]

                    if sh_[:3] == "lsl":
                        sh_op = "lsh"
                    elif sh_[:3] == "lsr":
                        sh_op = "rsh"
                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])

                    shift_effect = cls.make_arith_ct_effect(sh_op, src2, sh_val)
                    add_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                    add_effect.destination_element.info["reg_name"] = dest
                    add_effect.params[0].info["term_2"] = shift_effect.params[0]

                    if dest != bl[0]:

                        add_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        add_m32_effect.params[0].info["term_1"] = add_effect.params[0]

                        instr_effects.append(add_m32_effect)

                    else:
                        instr_effects.append(add_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None
            
            elif mnemonic in ["madd", "msub"]:

                if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                    bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                    bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                    bl[3] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                    return None
                
                op_type = mnemonic[1:]

                dest, src1, src2, src3 = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2]), _to_xreg(bl[3])

                mul_effect = cls.make_arith_reg_effect("mul", src2, src3)
                add_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                add_effect.params[0].info["term_2"] = mul_effect.params[0]
                add_effect.destination_element.info["reg_name"] = dest

                if dest != bl[0]:

                    add_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                    add_m32_effect.params[0].info["term_1"] = add_effect.params[0]

                    instr_effects.append(add_m32_effect)

                else:
                    instr_effects.append(add_effect)

            elif mnemonic in ["and", "ands", "orr", "eor"]:
                
                if mnemonic[:3] == "and":
                    op_type = "and"
                elif mnemonic == "orr":
                    op_type = "or"
                elif mnemonic == "eor":
                    op_type = "xor"
                
                if type(bl[2]) is int:

                    if len(bl) > 3:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src1, ct = _to_xreg(bl[0]), _to_xreg(bl[1]), bl[2]

                    arith_effect = cls.make_arith_ct_effect(op_type, src1, ct)
                    arith_effect.destination_element.info["reg_name"] = dest

                    if dest != bl[0]:
                        
                        arith_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_m32_effect.params[0].info["term_1"] = arith_effect.params[0]

                        instr_effects.append(arith_m32_effect)

                    else:
                        instr_effects.append(arith_effect)

                elif len(bl) == 3:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                
                    dest, src1, src2 = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2])

                    arith_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                    arith_effect.destination_element.info["reg_name"] = dest

                    if dest != bl[0]:

                        arith_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_m32_effect.params[0].info["term_1"] = arith_effect.params[0]

                        instr_effects.append(arith_m32_effect)

                    else:
                        instr_effects.append(arith_effect)

                elif len(bl) == 4:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src1, src2, sh_ = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2]), bl[3]

                    if sh_[:3] == "lsl":
                        sh_op = "lsh"
                    elif sh_[:3] == "lsr":
                        sh_op = "rsh"
                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])

                    shift_effect = cls.make_arith_ct_effect(sh_op, src2, sh_val)
                    logical_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                    logical_effect.destination_element.info["reg_name"] = dest
                    logical_effect.params[0].info["term_2"] = shift_effect.params[0]

                    if dest != bl[0]:

                        logical_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        logical_m32_effect.params[0].info["term_1"] = logical_effect.params[0]

                        instr_effects.append(logical_m32_effect)

                    else:
                        instr_effects.append(logical_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            elif mnemonic in ["bic", "bics", "orn", "eon"]:
                            
                if mnemonic[:3] == "bic":
                    op_type = "and"
                elif mnemonic == "orn":
                    op_type = "or"
                elif mnemonic == "eon":
                    op_type = "xor"
                
                if type(bl[2]) is int:

                    if len(bl) >= 3:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src1, ct = _to_xreg(bl[0]), _to_xreg(bl[1]), bl[2]
                    ct = ~ct

                    arith_effect = cls.make_arith_ct_effect(op_type, src1, ct)
                    arith_effect.destination_element.info["reg_name"] = dest

                    if dest != bl[0]:

                        arith_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_m32_effect.params[0].info["term_1"] = arith_effect.params[0]

                        instr_effects.append(arith_m32_effect)

                    else:
                        instr_effects.append(arith_effect)

                elif len(bl) == 3:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                
                    dest, src1, src2 = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2])

                    neg_effect = cls.make_neg_effect(src2)
                    arith_effect = cls.make_arith_reg_effect(op_type, src1, src2)
                    arith_effect.params[0].info["term_2"] = neg_effect.params[0]

                    if dest != bl[0]:
                        
                        arith_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_m32_effect.params[0].info["term_1"] = arith_effect.params[0]

                        instr_effects.append(arith_m32_effect)

                    else:
                        instr_effects.append(arith_effect)

                elif len(bl) == 4:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[2] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src1, src2, sh_ = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(bl[2]), bl[3]

                    if sh_[:3] == "lsl":
                        sh_op = "lsh"
                    elif sh_[:3] == "lsr":
                        sh_op = "rsh"
                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])

                    shift_effect = cls.make_arith_ct_effect(sh_op, src2, sh_val)
                    not_effect = cls.make_neg_effect(src2)
                    not_effect.params[0].info["term_1"] = shift_effect.params[0]

                    logical_effect = cls.make_arith_reg_effect(op_type, dest, src1)
                    logical_effect.params[0].info["term_1"] = not_effect.params[0]

                    if dest != bl[0]:

                        logical_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        logical_m32_effect.params[0].info["term_1"] = logical_effect.params[0]

                        instr_effects.append(logical_m32_effect)

                    else:
                        instr_effects.append(logical_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            elif mnemonic in ["neg", "negs"]:

                if type(bl[1]) == int:

                    print(f"UNEXPECTED instruction detected: {instr.mnemonic} {instr.op_str}")

                    if len(bl) > 2:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS:
                        return None
                    
                    dest, ct = _to_xreg(bl[0]), bl[1]
                    ct = -ct

                    neg_effect = cls.make_load_ct_effect(dest, ct)

                    if dest != bl[0]:

                        neg_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        neg_m32_effect.params[0].info["term_1"] = neg_effect.params[0]
                        
                        instr_effects.append(neg_m32_effect)

                    else:
                        instr_effects.append(neg_effect)

                elif len(bl) == 2:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src = _to_xreg(bl[0]), _to_xreg(bl[1])

                    logical_not_effect = cls.make_neg_effect(src)
                    arith_neg_effect = cls.make_arith_ct_effect("add", dest, 1)
                    arith_neg_effect.params[0].info["term_1"] = logical_not_effect.params[0]

                    if dest != bl[0]:

                        arith_neg_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_neg_m32_effect.params[0].info["term_1"] = arith_neg_effect.params[0]

                        instr_effects.append(arith_neg_m32_effect)

                    else:
                        instr_effects.append(arith_neg_effect)

                elif len(bl) == 3:

                    if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                        bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                        return None
                    
                    dest, src, sh_ = _to_xreg(bl[0]), _to_xreg(bl[1]), bl[2]

                    if sh_[:3] == "lsl":
                        sh_op = "lsh"
                    elif sh_[:3] == "lsr":
                        sh_op = "rsh"
                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])

                    shift_src_effect = cls.make_arith_ct_effect(sh_op, src, sh_val)
                    logical_not_effect = cls.make_neg_effect(src)
                    logical_not_effect.params[0].info["term_1"] = shift_src_effect.params[0]

                    arith_neg_effect = cls.make_arith_ct_effect("add", dest, 1)
                    arith_neg_effect.params[0].info["term_1"] = logical_not_effect.params[0]

                    if dest != bl[0]:

                        arith_neg_m32_effect = cls.make_arith_ct_effect("and", dest, MASK_32b)
                        arith_neg_m32_effect.params[0].info["term_1"] = arith_neg_effect.params[0]

                        instr_effects.append(arith_neg_m32_effect)

                    else:
                        instr_effects.append(arith_neg_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            # load from stack (pop)

            # NOTE load offset % 8 != 0 not allowed
            #       but it is verified later (inside resolve_stack_access())
            
            elif mnemonic == "ldp":

                if bl[1] == "sp":
                    return None

                if il is None:
                    return None

                if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS or \
                    bl[1] not in cls.Platform.SUPPORTED_EXTENDED_REGS:

                    return None
                
                dest1, dest2, src = _to_xreg(bl[0]), _to_xreg(bl[1]), _to_xreg(il[0])

                # forbid LDP, w, w, [...]
                # due to increased complexity 
                # for a relatively rare case
                if dest1 != bl[0]:
                    return None

                if len(il) == 1:
                    
                    if len(al) == 0:
                        
                        load_s_effect = cls.make_load_s_offset_effect(dest1, src, 0, False)
                        instr_effects.append(load_s_effect)

                        load_s_effect = cls.make_load_s_offset_effect(dest2, src, 8, False)
                        instr_effects.append(load_s_effect)

                    elif len(al) == 1:

                        off = al[0]

                        if type(off) is not int:
                            #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                            return None
                        
                        load_s_effect = cls.make_load_s_offset_effect(dest1, src, 0, False)
                        instr_effects.append(load_s_effect)

                        load_s_effect = cls.make_load_s_offset_effect(dest2, src, 8, False)
                        instr_effects.append(load_s_effect)

                        update_reg_effect = cls.make_arith_ct_effect("add", src, off)
                        instr_effects.append(update_reg_effect)

                elif len(il) == 2:

                    off = il[1]

                    if type(off) is not int:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None
                    
                    if excl is True:
                        
                        update_reg_effect = cls.make_arith_ct_effect("add", src, off)
                        instr_effects.append(update_reg_effect)

                        load_s_effect = cls.make_load_s_offset_effect(dest1, src, 0, False)
                        instr_effects.append(load_s_effect)

                        load_s_effect = cls.make_load_s_offset_effect(dest2, src, 8, False)
                        instr_effects.append(load_s_effect)

                    else:
                        
                        load_s_effect = cls.make_load_s_offset_effect(dest1, src, off, False)
                        instr_effects.append(load_s_effect)

                        load_s_effect = cls.make_load_s_offset_effect(dest2, src, 8 + off, False)
                        instr_effects.append(load_s_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            elif mnemonic in ["ldr", "ldur"]:

                if bl[0] not in cls.Platform.SUPPORTED_EXTENDED_REGS:
                    return None

                if il is None:
                    return None
                
                dest, src1 = _to_xreg(bl[0]), _to_xreg(il[0])

                if len(il) == 1:
                    
                    if len(al) == 0:
                        
                        load_s_effect = cls.make_load_s_offset_effect(dest, src1, 0, dest != bl[0])
                        instr_effects.append(load_s_effect)
                
                    elif len(al) == 1:

                        off = al[0]

                        if type(off) is not int:
                            #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                            return None
                        
                        load_s_effect = cls.make_load_s_offset_effect(dest, src1, 0, dest != bl[0])
                        instr_effects.append(load_s_effect)

                        update_reg_effect = cls.make_arith_ct_effect("add", src1, off)
                        instr_effects.append(update_reg_effect)

                elif len(il) == 2:
                    
                    if type(il[1]) is int:

                        off = il[1]
                        
                        if excl is True:
                            
                            update_reg_effect = cls.make_arith_ct_effect("add", src1, off)
                            instr_effects.append(update_reg_effect)

                            load_s_effect = cls.make_load_s_offset_effect(dest, src1, 0, dest != bl[0])
                            instr_effects.append(load_s_effect)

                        else:
                            
                            load_s_effect = cls.make_load_s_offset_effect(dest, src1, off, dest != bl[0])
                            instr_effects.append(load_s_effect)

                    elif _to_xreg(il[1]) in cls.Platform.SUPPORTED_REGS:

                        src2 = _to_xreg(il[1])
                    
                        load_s_effect = cls.make_load_s_lshift_effect(dest, src1, src2, 0, dest != bl[0])
                        instr_effects.append(load_s_effect)

                    else:
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                elif len(il) == 3:
                    
                    src2, sh_ = _to_xreg(il[1]), il[2]

                    if sh_[:3] != "lsl":
                        #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                        return None

                    sh_val = _is_int(sh_[3:])
                    
                    load_s_effect = cls.make_load_s_lshift_effect(dest, src1, src2, sh_val, dest != bl[0])
                    instr_effects.append(load_s_effect)

                else:
                    #print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                    return None

            elif mnemonic == "nop" or _ignored_instr(instr):
                
                nop_effect = cls.instantiate_effect("NO_OP")
                instr_effects.append(nop_effect)

            else:
                # print(f"unsupported instruction {instr.mnemonic} {instr.op_str}")
                return None

            #print("OK", instr_effects[0])
            return instr_effects          

        except Exception as e:
            print(f"EXCEPTION {e} {instr.mnemonic} {instr.op_str}")
            return None

    # method responsible for creating gadget attributes from separate (but ordered) instruction effects
    # the joining should resemble joining effects when building rop chains from gadgets
    # NOTE: it also handles unresolved_derefs
    @classmethod
    def join_instr_effects(cls, ordered_effects: List[List[Effect]]):
    
        # depth-first exploration of <op>-type Structured_element arithmetic tree
        # yielding every Structured_element of type "reg_in"
        def _recursive_arith_exploration(element: Structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem

            elif element.type == "deref":

                for reg_in_elem in _recursive_arith_exploration(element.info["expr"]):
                    yield reg_in_elem
        
        # yield all deref elements
        # as usual, if nested derefs are found, it is signaled
        # returns whether there is a nested deref or not
        def _recursive_find_derefs(element: Structured_element_ARM64, l: List[Structured_element_ARM64]):

            if element is None:
                return
            
            if element.type == "deref":
                l.append(element)
                # nested derefs will be processed later
                _recursive_find_derefs(element.info["expr"], l)
            
            elif element.is_op():
                _recursive_find_derefs(element.info["term_1"], l)
                _recursive_find_derefs(element.info["term_2"], l)

        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: Effect):

            if ef.type == "NO_OP":
                return True

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            return False

        # find the total increment on SP register
        # that is equivalent to stack view length (w/o unresolved refs)
        # and also equivalent with the end sp pos
        def _find_sp_end(ef: Effect):
            
            if ef.type == "add":
                return _find_sp_end(ef.info["term_1"]) + \
                        _find_sp_end(ef.info["term_2"])

            elif ef.type == "ct_val":
                return ef.info["value"]

            elif ef.type == "reg_in" and ef.info["reg_name"] == "sp":
                return 0

            else:
                raise Exception(f"found unexpected effect in _find_sp_end: {ef}")

        if len(ordered_effects) == 0:
            return None, None, None, None, None, None

        # the joining (currently) has 7 steps 
        # (notice the stack-related differences on ARM64, vs x86)
        #
        #   1) initialize the joined effects list with the second effects list
        #   2) for every instruction in the joined effects list, 
        #       replace every "reg_in" with the corresponding "reg_out" from the first effects list
        #       including when the "reg_in" is "sp",
        #   3) search for every deref and put it in deref_list
        #   4) copy every effect from the first effects list into the joined effects list, that has the destination reg
        #       different from any other destination reg from the joined effects list,
        #       and also skip NO_OP effects
        #   5) (optionally) iterate over all effects from the joined effects list and filter them
        #       so that effects of type move ri, ri are eliminated, or for simplifying arithmetic effects
        #   6) the first effects list is assigned the newly created joined effects list, and the loop continues 
        #       until all effect lists are processed
        #   7) stack-related effects are processed (including derefs from deref_list)
        #   8) check for valid_jump
        #   9) a new gadget's attributes are created with the final effects list and the obtained stack, some validity constraints are imposed
        #       and, optionally, other optimizations

        # NOTE: no two effects from a single effect list contain the same destination register
        #       proof by induction: base case assured by the analyse_instr, 
        #                           induction step proven by the rest of the current algorithm's steps

        acc_effects: List[Effect] = []
        deref_list: List[Structured_element_ARM64] = []

        for i in range(len(ordered_effects)):
            
            # step 1)
            new_acc_effect_list = deepcopy(ordered_effects[i])

            # step 2)
            for ef in new_acc_effect_list:

                if ef.type == "MOV_RR":
                    
                    reg_in_name = ef.params[0].info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in acc_effects:

                        if before_ef.type != "JUMP" and \
                            before_ef.destination_element.info["reg_name"] == reg_in_name:
                            
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:
                        
                        if corresp_before_ef.type == "MOV_RR":
                            ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:
                            
                            # example for ARITH, analogous for rest
                            # r1 = t1 <op> t2
                            # r2 = r1
                            # joined (for r2): r2 = t1 <op> t2

                            ef.type = corresp_before_ef.type
                            ef.params = deepcopy(corresp_before_ef.params)

                elif ef.type in ["ARITH", "LOAD_S", "JUMP"]:
                    
                    expr = ef.params[0]
                    for reg_in_elem in _recursive_arith_exploration(expr):
                        
                        reg_in_name = reg_in_elem.info["reg_name"]

                        corresp_before_ef = None
                        for before_ef in acc_effects:

                            if before_ef.type != "JUMP" and \
                                before_ef.destination_element.info["reg_name"] == reg_in_name:
                                
                                corresp_before_ef = before_ef
                                break

                        if corresp_before_ef is not None:

                            if corresp_before_ef.type == "LOAD_CT":
                                
                                reg_in_elem.type = "ct_val"
                                reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                            elif corresp_before_ef.type == "MOV_RR":
                                reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                            elif corresp_before_ef.type in ["ARITH", "LOAD_S"]:
                                
                                reg_in_elem.type = corresp_before_ef.params[0].type
                                reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)

            # step 3)
            for ef in new_acc_effect_list:
                if ef.type in ["ARITH", "LOAD_S", "JUMP"]:
                    _recursive_find_derefs(ef.params[0], deref_list)

            # step 4) and 5)
            for before_ef in acc_effects:
                
                # NOTE: JUMP will always be the last effect list to be joined
                #       so it will not reach this step
                #       still, do checks for consistency
                if before_ef.type != "JUMP" and ef.destination_element is not None:

                    before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                    overridden = False
                    for ef in new_acc_effect_list:

                        if ef.type != "JUMP" and ef.destination_element is not None and \
                            ef.destination_element.info["reg_name"] == before_ef_dest_reg_name:

                            overridden = True

                    if overridden is False:
                        new_acc_effect_list.append(before_ef)
                    
            # step 5) and 6)
            acc_effects.clear()
            for ef in new_acc_effect_list:
                
                if _ignored_effect(ef) is False:
                    acc_effects.append(ef)

        # step 7) 

        acc_stack = Stack_view()

        valid_stack_access = True
        valid_jump = True

        # NOTE: end_sp_pos is NOT necessarily equal with len(acc_stack)

        # length of stack view, considering 64 bit elements (real sp byte offset = sp_pos * 8 bytes)
        end_sp_pos = 0
        for ef in acc_effects:

            if ef.type == "ARITH" and \
                ef.destination_element.info["reg_name"] == "sp":

                end_sp_pos = _find_sp_end(ef.params[0])

                if end_sp_pos % cls.SP_ALIGNMENT != 0:
                    return None, None, None, None, None, None

                # converting to ul
                end_sp_pos //= 8

                # initially, filling with pad
                for _ in range(end_sp_pos):
                    acc_stack.push(cls.Elem.instantiate_structured_element("64b_stack_pad"))

                # SP arith effect is NOT removed

                break

        for ef in acc_effects:
            if ef.type in ["ARITH", "LOAD_S", "JUMP"]:

                is_valid = cls.resolve_stack_access(ef.params[0], acc_stack)
                valid_stack_access = valid_stack_access and is_valid

                if is_valid is None:
                    return None, None, None, None, None, None

        old_deref_list = deref_list
        deref_list = []

        for el in old_deref_list:

            is_valid = cls.resolve_stack_access(el, acc_stack)
            valid_stack_access = valid_stack_access and is_valid

            if is_valid is None:
                return None, None, None, None, None, None

            if is_valid is False:
                deref_list.append(el)

        # step 8)
        for ef in acc_effects:
            if ef.type == "JUMP":

                valid_jump = cls.resolve_jump(ef.params[0], 1)
                if valid_jump is None:
                    return None, None, None, None, None, None

                # NOTE: in a gadget, only one jump effect exists
                break

        # step 9)
        acc_effects_filtered = []
        for ef in acc_effects:
            
            if _ignored_effect(ef) is False:
                acc_effects_filtered.append(ef)

        return acc_stack, acc_effects_filtered, valid_stack_access, \
                valid_jump, end_sp_pos, deref_list

    # method responsible for joining two effects list
    # does NOT make any deep copy - fst and snd should be created copies
    # resembles join_instr_effects, but:
    #   * does not take any stack into consideration
    #   * only two effects list can be joined at a time
    #   * does not re-calculate validity 
    #   * does NOT try to resolve stack accesses where needed
    #   * it adjusts JUMP effects, if they exist, and the associated stack elements
    @staticmethod
    def join_effects(fst: List[Effect], snd: List[Effect]):

        if len(fst) == 0 or len(snd) == 0:
            return fst + snd

        # depth-first exploration of <op>-type Structured_element arithmetic tree
        # yielding every Structured_element of type "reg_in"
        def _recursive_arith_exploration(element: Structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem

            elif element.type == "deref":

                for reg_in_elem in _recursive_arith_exploration(element.info["expr"]):
                    yield reg_in_elem
        
        # eliminate from the joined list effects such as NO_OP or "move r_i, r_i"
        def _ignored_effect(ef: Effect):

            if ef.type == "NO_OP":
                return True

            if ef.type == "MOV_RR" and ef.destination_element.info["reg_name"] == ef.params[0].info["reg_name"]:
                return True

            return False

        _already_adjusted = set()
        def _adjust_jump_related(el: Structured_element, offset: int):

            if el is None:
                return
            
            if el.type == "64b_stack_val" and Stack_view.related_jump[el.info["id"]] is not None and \
                el.info["id"] not in _already_adjusted:

                Stack_view.related_jump[el.info["id"]] += offset
                _already_adjusted.add(el.info["id"])

            elif el.is_op():
                _adjust_jump_related(el.info["term_1"], offset)
                _adjust_jump_related(el.info["term_2"], offset)

            elif el.type == "deref":
                _adjust_jump_related(el.info["expr"], offset)

        # adjusting jumps, if they exist
        idx_offset = 0
        for ef in fst:
            if ef.type == "JUMP" and ef.destination_element.info["value"] > idx_offset:
                idx_offset = ef.destination_element.info["value"]

        for ef in snd:
            if ef.type == "JUMP":
                ef.destination_element.info["value"] += idx_offset

        for ef in snd:
            _adjust_jump_related(ef.params[0], idx_offset)

        res = snd
        
        # replacing every reg_in from res(=snd) with corresponding reg_out from fst
        for ef in res:

            if ef.type == "MOV_RR":
                
                reg_in_name = ef.params[0].info["reg_name"]

                corresp_before_ef = None
                for before_ef in fst:

                    if before_ef.type != "JUMP" and \
                        before_ef.destination_element.info["reg_name"] == reg_in_name:
                        
                        corresp_before_ef = before_ef
                        break

                if corresp_before_ef is not None:
                    
                    if corresp_before_ef.type == "MOV_RR":
                        ef.params[0].info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                    elif corresp_before_ef.type in ["ARITH", "LOAD_S", "LOAD_CT"]:
                        
                        # example for ARITH, analogous for rest
                        # r1 = t1 <op> t2
                        # r2 = r1
                        # joined (for r2): r2 = t1 <op> t2

                        ef.type = corresp_before_ef.type
                        ef.params = deepcopy(corresp_before_ef.params)

            elif ef.type in ["ARITH", "LOAD_S", "JUMP"]:
                
                expr = ef.params[0]
                for reg_in_elem in _recursive_arith_exploration(expr):
                    
                    reg_in_name = reg_in_elem.info["reg_name"]

                    corresp_before_ef = None
                    for before_ef in fst:

                        if before_ef.type != "JUMP" and \
                            before_ef.destination_element.info["reg_name"] == reg_in_name:
                            
                            corresp_before_ef = before_ef
                            break

                    if corresp_before_ef is not None:

                        if corresp_before_ef.type == "LOAD_CT":
                            
                            reg_in_elem.type = "ct_val"
                            reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                        elif corresp_before_ef.type == "MOV_RR":
                            reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                        elif corresp_before_ef.type in ["ARITH", "LOAD_S"]:
                            
                            reg_in_elem.type = corresp_before_ef.params[0].type
                            reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)
    
        # copying every effect from fst that has reg_out which is not in any reg_out from res
        for before_ef in fst:
            if before_ef.type != "JUMP" and ef.destination_element is not None:

                before_ef_dest_reg_name = before_ef.destination_element.info["reg_name"]

                overridden = False
                for ef in res:

                    if ef.type != "JUMP" and ef.destination_element is not None and \
                        ef.destination_element.info["reg_name"] == before_ef_dest_reg_name:

                        overridden = True

                if overridden is False:
                    res.append(before_ef)

        # adding jumps
        for ef in fst:
            if ef.type == "JUMP":
                res.append(ef)

        # filtering
        res_filtered = []
        for ef in res:
            
            if _ignored_effect(ef) is False:
                res_filtered.append(ef)

        return res_filtered
    
    # method responsible for joining (and updating)
    # unresolved dereference lists
    # it resembles join_effects
    @staticmethod
    def join_unresolved_derefs(fst_efs: List[Effect], fst_derefs: List[Structured_element_ARM64],
                                snd_derefs: List[Structured_element_ARM64]):

        if len(fst_efs) == 0:
            return fst_derefs + snd_derefs

        # depth-first exploration of <op>-type Structured_element arithmetic tree
        # yielding every Structured_element of type "reg_in"
        def _recursive_arith_exploration(element: Structured_element):
        
            if element.type == "reg_in":
                yield element

            elif element.is_op():
                
                if element.info["term_1"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_1"]):
                        yield reg_in_elem

                if element.info["term_2"] is not None:
                    for reg_in_elem in _recursive_arith_exploration(element.info["term_2"]):
                        yield reg_in_elem

            elif element.type == "deref":

                for reg_in_elem in _recursive_arith_exploration(element.info["expr"]):
                    yield reg_in_elem

        res_derefs = snd_derefs
        
        # replacing every reg_in from res_derefs(=snd_derefs) with corresponding reg_out from fst
        for deref in res_derefs:

            for reg_in_elem in _recursive_arith_exploration(deref):
                
                reg_in_name = reg_in_elem.info["reg_name"]

                corresp_before_ef = None
                for before_ef in fst_efs:

                    if before_ef.type != "JUMP" and \
                        before_ef.destination_element.info["reg_name"] == reg_in_name:
                        
                        corresp_before_ef = before_ef
                        break

                if corresp_before_ef is not None:

                    if corresp_before_ef.type == "LOAD_CT":
                        
                        reg_in_elem.type = "ct_val"
                        reg_in_elem.info = {"value": corresp_before_ef.params[0].info["value"]}

                    elif corresp_before_ef.type == "MOV_RR":
                        reg_in_elem.info["reg_name"] = corresp_before_ef.params[0].info["reg_name"]

                    elif corresp_before_ef.type in ["ARITH", "LOAD_S"]:
                        
                        reg_in_elem.type = corresp_before_ef.params[0].type
                        reg_in_elem.info = deepcopy(corresp_before_ef.params[0].info)

        res_derefs = fst_derefs + res_derefs
        return res_derefs
