from __future__ import annotations
from typing import Dict, List
# above imports only for type hints

import requests
import json

from logger import Logger

class niklasb_libc_db:

    def __init__(self):

        self.db_url = "https://libc.rip/api"
        self.header = {"Content-Type": "application/json"}
    
    # symbols_dict: {"symbol_name": address(as int)}
    def search_libc_version(self, symbols_dict: Dict[str, int]) -> List[str]:

        req_data = {"symbols": {}}
        for sym_name, sym_addr in symbols_dict.items():
            req_data["symbols"].update({sym_name: hex(sym_addr)[-3:]})

        req_url = f"{self.db_url}/find"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)

        if isinstance(res, list):
            return [info["id"] for info in res]
        else:
            return [res["id"]]

    # symbols_dict: {"symbol_name": address(as int)}
    def search_libc_info(self, symbols_dict: Dict[str, int]):

        req_data = {"symbols": {}}
        for sym_name, sym_addr in symbols_dict.items():
            req_data["symbols"].update({sym_name: hex(sym_addr)[-3:]})

        req_url = f"{self.db_url}/find"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)

        if isinstance(res, dict):
            return [res]
        return res

    # symbols_list: ["symbol_name"]
    def search_symbol_by_libc_version(self, libc_version: str, symbols_list: List[str]) -> Dict[str, int]:

        req_data = {"symbols": symbols_list}

        req_url = f"{self.db_url}/libc/{libc_version}"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)
        
        return {sym_name: int(res["symbols"][sym_name], 16) for sym_name in symbols_list}

    # download specified libc version
    def download_libc_by_version(self, libc_version: str, download_path = None) -> None:
        
        if download_path is None:
            download_path = f"{libc_version}.so"

        download_url = f"https://libc.rip/download/{libc_version}.so"
        res = requests.get(headers=self.header, url=download_url)

        if res.status_code != 200:
            raise RuntimeError(f"Could not download libc version {libc_version}.so")
        
        with open(download_path, "wb") as libc_bin:
            libc_bin.write(res._content)

# currently only https://github.com/niklasb/libc-database/tree/master/searchengine is supported
class LIBC_util:

    SUPPORTED_LIBC_DB = ["niklasb-libc-database"]

    def __init__(self, db_name="niklasb-libc-database", print_log=True, session_name="LIBC_util"):

        def _init_db_handle():

            if self.db_name == "nikslab-libc-database":
                return niklasb_libc_db()

        def _validate_libc_db(db_name):
            return db_name in LIBC_util.SUPPORTED_LIBC_DB

        if _validate_libc_db(db_name) is False:
            raise RuntimeError("Only https://github.com/niklasb/libc-database API supported at this time!")

        self.db_name = db_name
        self.db_handle = _init_db_handle()

        # for collecting leaked pairs of type {symbol: address} 
        # from the exterior of the class
        self.symbols_dict: Dict[str, int] = {}

        # list of possible libc versions
        self.libc_version: List[str] = []

        # dictionary of the form {"version_name": base_addr(int)}
        # for storing each possible base address (depending on the version)
        self.libc_base_addr: Dict[str, int] = {}

        # dictionary of the form {"version_name": {"sym_name": sym_offset(int)}}
        # for storing symbol offsets for each possible libc version
        self.searched_symbols: Dict[str, Dict[str, int]] = {}

        self.logger = Logger(session_name = session_name, print_log = print_log)

    # collect leaked symbols for later use (eg. find possible libc versions, find the base address, etc)
    # every other operation depends mostly on those leaked addresses
    # so, if imprecise or wrong information is given, 
    # all other operations might give wrong results, without any warning
    #
    # NOTE: if previous operations were executed, collecting any new informations resets the previously cached results
    def collect_leaked_symbols(self, leaked_sym_dict: Dict[str, int]) -> None:

        self.symbols_dict.update(leaked_sym_dict)

        self.libc_version = []
        self.libc_base_addr = {}
        self.searched_symbols = {}

    # search for all possible libc versions
    def search_libc_version(self) -> List[str]:

        _t = self.logger.log_info("Searching for libc version(s)...", start_timer = True)

        if len(self.symbols_dict) == 0:
            raise RuntimeError("Cannot search for libc versions if there are no leaked symbols")
        
        self.libc_version = self.db_handle.search_libc_version(self.symbols_dict)

        if len(self.libc_version) == 0:
            self.logger.log_warning("No libc version was found; returning empty list", end_timer = _t)
            return []

        self.searched_symbols = {ver_name: {} for ver_name in self.libc_version}

        self.logger.log_success(f"Found {len(self.libc_version)} libc version(s): {self.libc_version}", end_timer = _t)
        return self.libc_version

    # symbols_list: ["symbol_name"]
    # returns the offsets (relative to the base address) of each symbol given in symbol_name
    # return format: {"version_name": {"sym_name": sym_offset(int)}}
    def search_symbols_offsets(self, symbols_list: List[str]) -> Dict[str, Dict[str, int]]:

        _t = self.logger.log_info(f"Searching for symbol offsets for {symbols_list}...", start_timer = True)
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot search symbol offsets if no libc version is known")

        for ver_name in self.libc_version:

            symbols_list_aux = []
            for sym_name in symbols_list:
                if sym_name not in self.searched_symbols[ver_name]:
                    symbols_list_aux.append(sym_name)
            
            search_res = self.db_handle.search_symbol_by_libc_version(ver_name, symbols_list_aux)

            if len(search_res) == 0:
                self.logger.log_warning(f"Could not find searched symbols for version {ver_name}", end_timer = _t)
            else:
                self.searched_symbols[ver_name].update(search_res)

        self.logger.log_success("Done searching symbol offsets", end_timer = _t)
        
        currently_searched_symbols = {ver_name: {} for ver_name in self.libc_version}

        for ver_name in self.libc_version:
            for sym_name in symbols_list:

                currently_searched_symbols[ver_name].update({sym_name: self.searched_symbols[ver_name][sym_name]})

        return currently_searched_symbols

    # tries to filter out some libc previously taken into consideration
    # it does that based on the property that:
    #       for each libc version:
    #           the difference between any leaked address and its symbol offset for that version ARE EQUAL
    # this MUST happen because the libc base address (which is equal to the above mentioned difference) 
    # is fully determined by a single (better said any single) leaked address and a libc version
    # so if for a list of leaked symbol addresses and a candidate libc version, there can be more than one base address,
    # then that libc version is ruled out
    def filter_inconsistent_versions_byoffset(self) -> None:

        _t = self.logger.log_info("Filtering inconsistent libc versions...", start_timer = True)

        if len(self.symbols_dict) == 0:
            raise RuntimeError("Cannot filter inconsistent libc versions when there is no leaked address")
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot filter inconsistent libc versions when no libc version is known")

        self.libc_base_addr = {}

        # eliminating from both structures the inconsistent libc versions
        filtered_searched_symbols = {}
        filtered_libc_version = []

        leaked_symbols_list = [sym_name for sym_name in self.symbols_dict.keys()]
        self.search_symbols_offsets(leaked_symbols_list)

        for ver_name in self.libc_version:

            consistent = True
            
            base_addr = None
            for sym_name in leaked_symbols_list:
                
                if base_addr is None:
                    base_addr = self.symbols_dict[sym_name] - self.searched_symbols[ver_name][sym_name]

                elif base_addr != self.symbols_dict[sym_name] - self.searched_symbols[ver_name][sym_name]:
                    consistent = False
                    break

            if consistent:

                self.libc_base_addr.update({ver_name: base_addr})

                filtered_searched_symbols.update({ver_name: self.searched_symbols[ver_name]})
                filtered_libc_version.append(ver_name)

        self.libc_version = filtered_libc_version
        self.searched_symbols = filtered_searched_symbols

        self.logger.log_info("Done filtering", end_timer = _t)

    # calculate the libc base address
    # due to implementation structure
    # this method wraps the filter_inconsistent_versions_byoffset function
    def find_libc_base_addr(self) -> Dict[str, int]:

        _t = self.logger.log_info("Searching for libc base address...", start_timer = True)

        self.filter_inconsistent_versions_byoffset()

        self.logger.log_success("Done searching for libc base addresses", end_timer = _t)

        return self.libc_base_addr

    # symbols_list: ["symbol_name"]
    # returns the offsets (relative to the base address) of each symbol given in symbol_name
    # return format: {"version_name": {"sym_name": sym_addr(int)}}
    def search_symbols_addrs(self, symbols_list: List[str]) -> Dict[str, Dict[str, int]]:

        _t = self.logger.log_info(f"Searching for symbol addresses for {symbols_list}...", start_timer = True)
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot search symbol addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("Cannot search symbol addresses if the base libc addresses are not known")

        self.search_symbols_offsets(symbols_list)

        symbols_addrs = {ver_name: {} for ver_name in self.libc_version}

        for ver_name in self.libc_version:
            for sym_name in symbols_list:
                
                symbols_addrs[ver_name][sym_name] = self.searched_symbols[ver_name][sym_name] + self.libc_base_addr[ver_name]

        self.logger.log_success("Done searching symbol addresses", end_timer = _t)
        return symbols_addrs

    # checks whether the symbols have the same offset even if libc versions are different
    # if not, it throws RuntimeError
    # if ok, it returns the addreses
    def assert_unicate_offsets(self) -> Dict[str, int]:

        _t = self.logger.log_info("Checking for unicate searched symbol offsets...", start_timer = True)

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the unicity of symbol offsets if no libc version is known")

        if len(self.searched_symbols) == 0:
            self.logger.log_warning("No searched symbols were found; nothing to check, returning...")
            return None

        filtered_offsets = {}

        for v_sym_dict in self.searched_symbols.values():
            for sym_name, sym_offset in v_sym_dict.items():

                if sym_name not in filtered_offsets.keys():
                    filtered_offsets.update({sym_name: sym_offset})

                elif filtered_offsets[sym_name] != sym_offset:
                    raise RuntimeError(f"Two different offsets for symbol {sym_name} were found: {sym_offset}, {filtered_offsets[sym_name]}; terminating")

        self.logger.log_info("Done checking", end_timer = _t)
        return filtered_offsets

    # checks whether the symbols have the same addresses even if libc versions are different
    # if not, it throws RuntimeError
    # if ok, it returns the addreses
    # almost identical to assert_unicate_offsets
    def assert_unicate_addrs(self) -> Dict[str, int]:

        _t = self.logger.log_info("Checking for unicate searched symbol addresses...", start_timer = True)

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the unicity of symbol addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("No base address is known")

        if len(self.searched_symbols) == 0:
            self.logger.log_warning("No searched symbols were found; nothing to check, returning...")
            return None

        filtered_addrs = {}

        for libc_ver_name, v_sym_dict in self.searched_symbols.items():
            for sym_name, sym_offset in v_sym_dict.items():

                sym_addr = sym_offset + self.libc_base_addr[libc_ver_name]

                if sym_name not in filtered_addrs.keys():
                    filtered_addrs.update({sym_name: sym_addr})

                elif filtered_addrs[sym_name] != sym_addr:
                    raise RuntimeError(f"Two different offsets for symbol {sym_name} were found: {sym_addr}, {filtered_addrs[sym_name]}; terminating")

        self.logger.log_info("Done checking", end_timer = _t)
        return filtered_addrs

    # checks whether all candidate libc versions give the same base address or not
    # if not, it throws RuntimeError
    # if ok, it returns the (unicate) base address
    def assert_unicate_base_addr(self) -> int:

        _t = self.logger.log_info("Checking candidate base addresses unicity...", start_timer = True)

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the base addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("No base address is known")

        base_addr = None
        for v_base_addr in self.libc_base_addr.values():

            if base_addr is None:
                base_addr = v_base_addr

            elif base_addr != v_base_addr:
                raise RuntimeError(f"Found two different base addresses: {base_addr} and {v_base_addr}")

        self.logger.log_info("Done checking", end_timer = _t)
        return base_addr

    # downloads one or more libc versions
    # if a libc version is specified,
    # this function explicitly tries to download it
    # if not, all the candidate libc versions stored in self.libc_version are downloaded
    # NOTE: expect up to 2Mb per downloaded binary
    # NOTE: downloaded binaries are stored with the owner as the current processes' owner and WITHOUT execution privilleges
    def download_libc_bin(self, version_name: str = None, download_path: str = None) -> None:
    
        _t = self.logger.log_info("Beginning libc download...", start_timer = True)
        
        if version_name is None:

            if len(self.libc_version) == 0:
                self.logger.log_warning("No libc version to download; returning without any change...")

            for ver_name in self.libc_version:
                self.db_handle.download_libc_by_version(ver_name, download_path)

        else:
            self.db_handle.download_libc_by_version(version_name)

        self.logger.log_success("Libc version(s) successfully downloaded", end_timer = _t)
