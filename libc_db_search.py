import requests
import json

from logger import Logger

class niklasb_libc_db:

    def __init__(self):

        self.db_url = "https://libc.rip/api"
        self.header = {"Content-Type": "application/json"}
    
    # symbols_dict: {"symbol_name": address(as int)}
    def search_libc_version(self, symbols_dict: dict):

        req_data = {"symbols": {}}
        for sym_name, sym_addr in symbols_dict.items():
            req_data["symbols"].update({sym_name: hex(sym_addr)[-3:]})

        req_url = f"{self.db_url}/find"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)

        if isinstance(res, list):
            return [info["id"] for info in res]
        else:
            return [res["id"]]

    # symbols_dict: {"symbol_name": address(as int)}
    def search_libc_info(self, symbols_dict: dict):

        req_data = {"symbols": {}}
        for sym_name, sym_addr in symbols_dict.items():
            req_data["symbols"].update({sym_name: hex(sym_addr)[-3:]})

        req_url = f"{self.db_url}/find"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)

        if isinstance(res, dict):
            return [res]
        return res

    # symbols_list: ["symbol_name"]
    def search_symbol_by_libc_version(self, libc_version, symbols_list):

        req_data = {"symbols": symbols_list}

        req_url = f"{self.db_url}/libc/{libc_version}"

        res = requests.post(headers=self.header, url=req_url, data=json.dumps(req_data))
        res = json.loads(res.text)
        
        return {sym_name: int(res["symbols"][sym_name], 16) for sym_name in symbols_list}

# currently only https://github.com/niklasb/libc-database/tree/master/searchengine supported

class LIBC_util:

    SUPPORTED_LIBC_DB = ["nikslab-libc-database"]

    @staticmethod
    def _validate_libc_db(db_name):
        return db_name in LIBC_util.SUPPORTED_LIBC_DB

    def _init_db_handle(self):

        if self.db_name == "nikslab-libc-database":
            self.db_handle = niklasb_libc_db()

    def __init__(self, db_name="nikslab-libc-database", print_log=True, session_name="LIBC_util"):

        if LIBC_util._validate_libc_db(db_name) is False:
            raise RuntimeError("Only https://github.com/niklasb/libc-database API supported at this time!")

        self.db_name = db_name
        self._init_db_handle()

        # for collecting leaked pairs of type {symbol: address} 
        # from the exterior of the class
        self.symbols_dict = {}

        # list of possible libc versions
        self.libc_version = []

        # dictionary of the form {"version_name": base_addr(int)}
        # for storing each possible base address (depending on the version)
        self.libc_base_addr = {}

        # dictionary of the form {"version_name": {"sym_name": sym_offset(int)}}
        # for storing symbol offsets for each possible libc version
        self.searched_symbols = {}

        self.logger = Logger(session_name = session_name, print_log = print_log)

    # collect leaked symbols for later use (eg. find possible libc versions, find the base address, etc)
    # every other operation depends mostly on those leaked addresses
    # so, if imprecise or wrong information is given, 
    # all other operations might give wrong results, without any warning
    #
    # NOTE: if previous operations were executed, collecting any new informations resets the previously cached results
    def collect_leaked_symbols(self, leaked_sym_dict: dict):

        self.symbols_dict.update(leaked_sym_dict)

        self.libc_version = []
        self.libc_base_addr = {}
        self.searched_symbols = {}

    # search for all possible libc versions
    def search_libc_version(self):

        self.logger.log_info("Searching for libc version(s)...")

        if len(self.symbols_dict) == 0:
            raise RuntimeError("Cannot search for libc versions if there are no leaked symbols")
        
        self.libc_version = self.db_handle.search_libc_version(self.symbols_dict)

        if len(self.libc_version) == 0:
            self.logger.log_warning("No libc version was found; returning empty list")
            return []

        self.searched_symbols = {ver_name: {} for ver_name in self.libc_version}

        self.logger.log_success(f"Found {len(self.libc_version)} libc version(s): {self.libc_version}")
        return self.libc_version

    # symbols_list: ["symbol_name"]
    # returns the offsets (relative to the base address) of each symbol given in symbol_name
    # return format: {"version_name": {"sym_name": sym_offset(int)}}
    def search_symbols_offsets(self, symbols_list: list):

        self.logger.log_info(f"Searching for symbol offsets for {symbols_list}...")
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot search symbol offsets if no libc version is known")

        for ver_name in self.libc_version:

            symbols_list_aux = []
            for sym_name in symbols_list:
                if sym_name not in self.searched_symbols[ver_name]:
                    symbols_list_aux.append(sym_name)
            
            search_res = self.db_handle.search_symbol_by_libc_version(ver_name, symbols_list_aux)

            if len(search_res) == 0:
                self.logger.log_warning(f"Could not find searched symbols for version {ver_name}")
            else:
                self.searched_symbols[ver_name].update(search_res)

        self.logger.log_success("Done searching symbol offsets")
        
        currently_searched_symbols = {ver_name: {} for ver_name in self.libc_version}

        for ver_name in self.libc_version:
            for sym_name in symbols_list:

                currently_searched_symbols[ver_name].update({sym_name: self.searched_symbols[ver_name][sym_name]})

        return currently_searched_symbols

    # tries to filter out some libc previously taken into consideration
    # it does that based on the property that:
    #       for each libc version:
    #           the difference between any leaked address and its symbol offset for that version ARE EQUAL
    # this MUST happen because the libc base address (which is equal to the above mentioned difference) 
    # is fully determined by a single (better said any single) leaked address and a libc version
    # so if for a list of leaked symbol addresses and a candidate libc version, there can be more than one base address,
    # then that libc version is ruled out
    def filter_inconsistent_versions_byoffset(self):

        self.logger.log_info("Filtering inconsistent libc versions...")

        if len(self.symbols_dict) == 0:
            raise RuntimeError("Cannot filter inconsistent libc versions when there is no leaked address")
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot filter inconsistent libc versions when no libc version is known")

        self.libc_base_addr = {}

        # eliminating from both structures the inconsistent libc versions
        filtered_searched_symbols = {}
        filtered_libc_version = []

        leaked_symbols_list = [sym_name for sym_name in self.symbols_dict.keys()]
        self.search_symbols_offsets(leaked_symbols_list)

        for ver_name in self.libc_version:

            consistent = True
            
            base_addr = None
            for sym_name in leaked_symbols_list:
                
                if base_addr is None:
                    base_addr = self.symbols_dict[sym_name] - self.searched_symbols[ver_name][sym_name]

                elif base_addr != self.symbols_dict[sym_name] - self.searched_symbols[ver_name][sym_name]:
                    consistent = False
                    break

            if consistent:

                self.libc_base_addr.update({ver_name: base_addr})

                filtered_searched_symbols.update({ver_name: self.searched_symbols[ver_name]})
                filtered_libc_version.append(ver_name)

        self.libc_version = filtered_libc_version
        self.searched_symbols = filtered_searched_symbols

        self.logger.log_info("Done filtering")

    # calculate the libc base address
    # due to implementation structure
    # this method wraps the filter_inconsistent_versions_byoffset function
    def find_libc_base_addr(self):

        self.logger.log_info("Searching for libc base address...")
        self.filter_inconsistent_versions_byoffset()
        self.logger.log_success("Done searching for libc base addresses")

        return self.libc_base_addr

    # symbols_list: ["symbol_name"]
    # returns the offsets (relative to the base address) of each symbol given in symbol_name
    # return format: {"version_name": {"sym_name": sym_addr(int)}}
    def search_symbols_addrs(self, symbols_list: list):

        self.logger.log_info(f"Searching for symbol addresses for {symbols_list}...")
        
        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot search symbol addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("Cannot search symbol addresses if the base libc addresses are not known")

        self.search_symbols_offsets(symbols_list)

        symbols_addrs = {ver_name: {} for ver_name in self.libc_version}

        for ver_name in self.libc_version:
            for sym_name in symbols_list:
                
                symbols_addrs[ver_name][sym_name] = self.searched_symbols[ver_name][sym_name] + self.libc_base_addr[ver_name]

        self.logger.log_success("Done searching symbol addresses")
        return symbols_addrs

    # checks whether the symbols have the same offset even if libc versions are different
    # if not, it throws RuntimeError
    # if ok, it returns the addreses
    def assert_unicate_offsets(self):

        self.logger.log_info("Checking for unicate searched symbol offsets...")

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the unicity of symbol offsets if no libc version is known")

        if len(self.searched_symbols) == 0:
            self.logger.log_warning("No searched symbols were found; nothing to check, returning...")
            return None

        filtered_offsets = {}

        for v_sym_dict in self.searched_symbols.values():
            for sym_name, sym_offset in v_sym_dict.items():

                if sym_name not in filtered_offsets.keys():
                    filtered_offsets.update({sym_name: sym_offset})

                elif filtered_offsets[sym_name] != sym_offset:
                    raise RuntimeError(f"Two different offsets for symbol {sym_name} were found: {sym_offset}, {filtered_offsets[sym_name]}; terminating")

        self.logger.log_info("Done checking")
        return filtered_offsets

    # checks whether the symbols have the same addresses even if libc versions are different
    # if not, it throws RuntimeError
    # if ok, it returns the addreses
    def assert_unicate_addrs(self):

        self.logger.log_info("Checking for unicate searched symbol addresses...")

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the unicity of symbol addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("No base address is known")

        if len(self.searched_symbols) == 0:
            self.logger.log_warning("No searched symbols were found; nothing to check, returning...")
            return None

        filtered_addrs = {}

        for libc_ver_name, v_sym_dict in self.searched_symbols.items():
            for sym_name, sym_offset in v_sym_dict.items():

                sym_addr = sym_offset + self.libc_base_addr[libc_ver_name]

                if sym_name not in filtered_addrs.keys():
                    filtered_addrs.update({sym_name: sym_addr})

                elif filtered_addrs[sym_name] != sym_addr:
                    raise RuntimeError(f"Two different offsets for symbol {sym_name} were found: {sym_addr}, {filtered_addrs[sym_name]}; terminating")

        self.logger.log_info("Done checking")
        return filtered_addrs

    # checks whether all candidate libc versions give the same base address or not
    # if not, it throws RuntimeError
    # if ok, it returns the (unicate) base address
    def assert_unicate_base_addr(self):

        self.logger.log_info("Checking candidate base addresses unicity...")

        if len(self.libc_version) == 0:
            raise RuntimeError("Cannot check the base addresses if no libc version is known")

        if len(self.libc_base_addr) == 0:
            raise RuntimeError("No base address is known")

        base_addr = None
        for v_base_addr in self.libc_base_addr.values():

            if base_addr is None:
                base_addr = v_base_addr

            elif base_addr != v_base_addr:
                raise RuntimeError(f"Found two different base addresses: {base_addr} and {v_base_addr}")

        return base_addr

